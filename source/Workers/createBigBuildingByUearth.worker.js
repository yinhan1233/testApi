/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "../dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/_babel-loader@7.1.5@babel-loader/lib/index.js?!./lib/threejs/createBigBuildingByUearth.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/threejs/BufferGeometryUtils.js":
/*!********************************************!*\
  !*** ./lib/threejs/BufferGeometryUtils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * changed by zhgu\r\n */\nvar THREE = __webpack_require__(/*! ./extrudeAndBufferAttribute.js */ \"./lib/threejs/extrudeAndBufferAttribute.js\");\nTHREE.BufferGeometryUtils1 = {\n    /**\r\n     * @param  {Array<THREE.BufferGeometry>} geometries\r\n     * @param  {Boolean} useGroups\r\n     * maxCount 最大顶点数量默认 50000 added by zhgu\r\n     * @return {THREE.BufferGeometry}\r\n     */\n    mergeBufferGeometries1: function mergeBufferGeometries1(geometries, maxCount, useGroups) {\n        maxCount = maxCount || 50000;\n        // maxCount *= 3;\n        var curCount = 0;\n        var index = 0;\n        var resultGeo = [[]];\n        for (var i = 0; i < geometries.length; i++) {\n            var geometry = geometries[i];\n            if (geometry.attributes.position) {\n                var positionCount = geometry.attributes.position.count;\n                curCount += positionCount;\n                if (curCount < maxCount) {\n                    if (!(resultGeo[index] instanceof Array)) {\n                        resultGeo[index] = [];\n                    }\n                    resultGeo[index].push(geometry);\n                } else {\n                    curCount = 0;\n                    if (!(resultGeo[index] instanceof Array)) {\n                        resultGeo[index] = [];\n                    }\n                    resultGeo[index].push(geometry);\n                    index++;\n                }\n            } else {\n                console.warn('该geometry' + geometry.id + '无position，请检查是否存在问题');\n            }\n        }\n        var mergedResult = [];\n        for (var k = 0; k < resultGeo.length; k++) {\n            var mergedGeometry = this.mergeBufferGeometries(resultGeo[k], useGroups);\n            //继续合并groups\n            if (useGroups) {\n                this.mergeGroups(mergedGeometry);\n            }\n            mergedResult.push(mergedGeometry);\n        }\n        return mergedResult;\n    },\n    /**\r\n     * @param  {Array<THREE.BufferGeometry>} geometries\r\n     * @param  {Boolean} useGroups\r\n     * maxCount 最大顶点数量默认 50000 added by zhgu\r\n     * @return {THREE.BufferGeometry}\r\n     */\n    mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {\n\n        var isIndexed = geometries[0].index !== null;\n\n        var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n        var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n\n        var attributes = {};\n        var morphAttributes = {};\n\n        var mergedGeometry = new THREE.BufferGeometry();\n\n        var offset = 0;\n\n        for (var i = 0; i < geometries.length; ++i) {\n\n            var geometry = geometries[i];\n\n            // ensure that all geometries are indexed, or none\n\n            if (isIndexed !== (geometry.index !== null)) return null;\n\n            // gather attributes, exit early if they're different\n\n            for (var name in geometry.attributes) {\n\n                if (!attributesUsed.has(name)) return null;\n\n                if (attributes[name] === undefined) attributes[name] = [];\n\n                attributes[name].push(geometry.attributes[name]);\n            }\n\n            // gather morph attributes, exit early if they're different\n\n            for (var name in geometry.morphAttributes) {\n\n                if (!morphAttributesUsed.has(name)) return null;\n\n                if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n\n                morphAttributes[name].push(geometry.morphAttributes[name]);\n            }\n\n            // gather .userData\n\n            mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n            mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n            if (useGroups) {\n\n                var count;\n\n                if (isIndexed) {\n\n                    count = geometry.index.count;\n                } else if (geometry.attributes.position !== undefined) {\n\n                    count = geometry.attributes.position.count;\n                } else {\n\n                    return null;\n                }\n\n                // mergedGeometry.addGroup( offset, count, i );\n                //changed by zhgu\n                if (geometry.groups) {\n                    geometry.groups.map(function (v) {\n                        var start = v.start;\n                        var nums = v.count;\n                        var materialIndex = v.materialIndex;\n                        mergedGeometry.addGroup(offset + start, nums, materialIndex);\n                    });\n                }\n                offset += count;\n            }\n\n            //needMerge\n            if (geometry._needMerge) {\n                for (var key in geometry._needMerge) {\n                    if (!mergedGeometry._needMerge) {\n                        mergedGeometry._needMerge = {};\n                    }\n                    if (!mergedGeometry._needMerge[key]) {\n                        mergedGeometry._needMerge[key] = [];\n                    }\n                    mergedGeometry._needMerge[key].push(geometry._needMerge[key]);\n                }\n            }\n        }\n\n        // merge indices\n\n        if (isIndexed) {\n\n            var indexOffset = 0;\n            var mergedIndex = [];\n\n            for (var i = 0; i < geometries.length; ++i) {\n\n                var index = geometries[i].index;\n\n                for (var j = 0; j < index.count; ++j) {\n\n                    mergedIndex.push(index.getX(j) + indexOffset);\n                }\n\n                indexOffset += geometries[i].attributes.position.count;\n            }\n\n            mergedGeometry.setIndex(mergedIndex);\n        }\n\n        // merge attributes\n\n        for (var name in attributes) {\n\n            var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n\n            if (!mergedAttribute) return null;\n\n            mergedGeometry.addAttribute(name, mergedAttribute);\n        }\n\n        // merge morph attributes\n\n        for (var name in morphAttributes) {\n\n            var numMorphTargets = morphAttributes[name][0].length;\n\n            if (numMorphTargets === 0) break;\n\n            mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n            mergedGeometry.morphAttributes[name] = [];\n\n            for (var i = 0; i < numMorphTargets; ++i) {\n\n                var morphAttributesToMerge = [];\n\n                for (var j = 0; j < morphAttributes[name].length; ++j) {\n\n                    morphAttributesToMerge.push(morphAttributes[name][j][i]);\n                }\n\n                var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n\n                if (!mergedMorphAttribute) return null;\n\n                mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n            }\n        }\n\n        return mergedGeometry;\n    },\n\n    /**\r\n     *@author zhuguang <zhuguang@uinnova.com>\r\n     *@descripition 为了极限增加性能，需要对geometry的groups进行二次merge\r\n     *@type {String}\r\n     */\n    mergeGroups: function mergeGroups(geometry) {\n        var groups = geometry.groups;\n        var indexArr = {};\n        //目前只考虑attribute的合并\n        //收集index\n        for (var i = 0, len = groups.length; i < len; i++) {\n            var group = groups[i];\n            var materialIndex = group.materialIndex;\n            if (!indexArr[materialIndex]) {\n                indexArr[materialIndex] = [];\n            }\n            indexArr[materialIndex].push(group);\n        }\n        //遍历attribute\n        for (var name in geometry.attributes) {\n            //var attr = geometry.attributes(name);\n            if (name.indexOf('position') !== -1) {\n                geometry.addAttribute('position', new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr, true), 3));\n            } else if (name.indexOf('uv') !== -1) {\n                geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 2));\n            } else if (name.indexOf('normal') !== -1) {\n                geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 3));\n            } else if (name.indexOf('id') !== -1) {\n                geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 1));\n            }\n        }\n    },\n    _recombinationArr: function _recombinationArr(geometry, name, indexArr, updateGroups) {\n        var arr = geometry.attributes[name].array;\n        var res = new Float32Array(arr.length);\n        var IndexMap = {};\n        var resIndex = 0;\n        // arr = arr.join(',');\n        var interval = geometry.attributes[name].itemSize;\n        for (var k in indexArr) {\n            IndexMap[k] = { start: resIndex / interval };\n            var index = indexArr[k];\n            var end = 0;\n            for (var i = 0, len = index.length; i < len; i++) {\n                var group = index[i];\n                var start = group.start * interval;\n                var size = group.count * interval;\n                this._getNewArrayFromArr(res, resIndex, arr, start, size);\n                resIndex += size;\n                end += size;\n            }\n            IndexMap[k].count = end / interval;\n        }\n        //处理groups,先清空\n        if (updateGroups) {\n            geometry.groups = [];\n            for (var nums in IndexMap) {\n                var indexMap0 = IndexMap[nums];\n                geometry.addGroup(indexMap0.start, indexMap0.count, parseInt(nums));\n            }\n        }\n\n        return res;\n        //\n        // for(var t in res){\n        //     final = final.concat(res[t]);\n        // }\n        //\n        // return final;\n    },\n\n    _getNewArrayFromArr: function _getNewArrayFromArr(res, resIndex, arr, start, count) {\n        for (var i = start; i < start + count; i++) {\n            res[resIndex] = arr[i];\n            resIndex++;\n        }\n    },\n\n    /**\r\n     * @param {Array<THREE.BufferAttribute>} attributes\r\n     * @return {THREE.BufferAttribute}\r\n     */\n    mergeBufferAttributes: function mergeBufferAttributes(attributes) {\n\n        var TypedArray;\n        var itemSize;\n        var normalized;\n        var arrayLength = 0;\n\n        for (var i = 0; i < attributes.length; ++i) {\n\n            var attribute = attributes[i];\n\n            if (attribute.isInterleavedBufferAttribute) return null;\n\n            if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n            if (TypedArray !== attribute.array.constructor) return null;\n\n            if (itemSize === undefined) itemSize = attribute.itemSize;\n            if (itemSize !== attribute.itemSize) return null;\n\n            if (normalized === undefined) normalized = attribute.normalized;\n            if (normalized !== attribute.normalized) return null;\n\n            arrayLength += attribute.array.length;\n        }\n\n        var array = new TypedArray(arrayLength);\n        var offset = 0;\n\n        for (var i = 0; i < attributes.length; ++i) {\n\n            array.set(attributes[i].array, offset);\n\n            offset += attributes[i].array.length;\n        }\n\n        return new THREE.BufferAttribute(array, itemSize, normalized);\n    }\n\n};\n\n//# sourceURL=webpack:///./lib/threejs/BufferGeometryUtils.js?");

/***/ }),

/***/ "./lib/threejs/extrudeAndBufferAttribute.js":
/*!**************************************************!*\
  !*** ./lib/threejs/extrudeAndBufferAttribute.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (global, factory) {\n\t\t\t( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(undefined, function (exports) {\n\t\t\t'use strict';\n\n\t\t\t// Polyfills\n\n\t\t\tif (Number.EPSILON === undefined) {\n\n\t\t\t\t\t\tNumber.EPSILON = Math.pow(2, -52);\n\t\t\t}\n\n\t\t\tif (Number.isInteger === undefined) {\n\n\t\t\t\t\t\t// Missing in IE\n\t\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n\n\t\t\t\t\t\tNumber.isInteger = function (value) {\n\n\t\t\t\t\t\t\t\t\treturn typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n\t\t\t\t\t\t};\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif (Math.sign === undefined) {\n\n\t\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\t\t\t\t\t\tMath.sign = function (x) {\n\n\t\t\t\t\t\t\t\t\treturn x < 0 ? -1 : x > 0 ? 1 : +x;\n\t\t\t\t\t\t};\n\t\t\t}\n\n\t\t\tif ('name' in Function.prototype === false) {\n\n\t\t\t\t\t\t// Missing in IE\n\t\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\t\t\t\t\t\tObject.defineProperty(Function.prototype, 'name', {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.toString().match(/^\\s*function\\s*([^\\(\\s]*)/)[1];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (Object.assign === undefined) {\n\n\t\t\t\t\t\t// Missing in IE\n\t\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t\t\t\t\t\t(function () {\n\n\t\t\t\t\t\t\t\t\tObject.assign = function (target) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (target === undefined || target === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError('Cannot convert undefined or null to object');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar output = Object(target);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var index = 1; index < arguments.length; index++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar source = arguments[index];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (source !== undefined && source !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var nextKey in source) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(source, nextKey)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toutput[nextKey] = source[nextKey];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn output;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t})();\n\t\t\t}\n\n\t\t\t/**\r\n    * https://github.com/mrdoob/eventdispatcher.js/\r\n    */\n\n\t\t\tfunction EventDispatcher() {}\n\n\t\t\tObject.assign(EventDispatcher.prototype, {\n\n\t\t\t\t\t\taddEventListener: function addEventListener(type, listener) {\n\n\t\t\t\t\t\t\t\t\tif (this._listeners === undefined) this._listeners = {};\n\n\t\t\t\t\t\t\t\t\tvar listeners = this._listeners;\n\n\t\t\t\t\t\t\t\t\tif (listeners[type] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tlisteners[type] = [];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (listeners[type].indexOf(listener) === -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tlisteners[type].push(listener);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\thasEventListener: function hasEventListener(type, listener) {\n\n\t\t\t\t\t\t\t\t\tif (this._listeners === undefined) return false;\n\n\t\t\t\t\t\t\t\t\tvar listeners = this._listeners;\n\n\t\t\t\t\t\t\t\t\treturn listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tremoveEventListener: function removeEventListener(type, listener) {\n\n\t\t\t\t\t\t\t\t\tif (this._listeners === undefined) return;\n\n\t\t\t\t\t\t\t\t\tvar listeners = this._listeners;\n\t\t\t\t\t\t\t\t\tvar listenerArray = listeners[type];\n\n\t\t\t\t\t\t\t\t\tif (listenerArray !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar index = listenerArray.indexOf(listener);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdispatchEvent: function dispatchEvent(event) {\n\n\t\t\t\t\t\t\t\t\tif (this._listeners === undefined) return;\n\n\t\t\t\t\t\t\t\t\tvar listeners = this._listeners;\n\t\t\t\t\t\t\t\t\tvar listenerArray = listeners[event.type];\n\n\t\t\t\t\t\t\t\t\tif (listenerArray !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tevent.target = this;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array = listenerArray.slice(0);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tarray[i].call(this, event);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author alteredq / http://alteredqualia.com/\r\n    * @author mrdoob / http://mrdoob.com/\r\n    */\n\n\t\t\tvar _Math = {\n\n\t\t\t\t\t\tDEG2RAD: Math.PI / 180,\n\t\t\t\t\t\tRAD2DEG: 180 / Math.PI,\n\n\t\t\t\t\t\tgenerateUUID: function () {\n\n\t\t\t\t\t\t\t\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\t\t\t\t\t\t\t\t\tvar lut = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < 256; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tlut[i] = (i < 16 ? '0' : '') + i.toString(16);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn function generateUUID() {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar d0 = Math.random() * 0xffffffff | 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar d1 = Math.random() * 0xffffffff | 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar d2 = Math.random() * 0xffffffff | 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar d3 = Math.random() * 0xffffffff | 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];\n\n\t\t\t\t\t\t\t\t\t\t\t\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\n\t\t\t\t\t\t\t\t\t\t\t\treturn uuid.toUpperCase();\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tclamp: function clamp(value, min, max) {\n\n\t\t\t\t\t\t\t\t\treturn Math.max(min, Math.min(max, value));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// compute euclidian modulo of m % n\n\t\t\t\t\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\t\t\t\t\t\teuclideanModulo: function euclideanModulo(n, m) {\n\n\t\t\t\t\t\t\t\t\treturn (n % m + m) % m;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\t\t\t\t\t\tmapLinear: function mapLinear(x, a1, a2, b1, b2) {\n\n\t\t\t\t\t\t\t\t\treturn b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// https://en.wikipedia.org/wiki/Linear_interpolation\n\n\t\t\t\t\t\tlerp: function lerp(x, y, t) {\n\n\t\t\t\t\t\t\t\t\treturn (1 - t) * x + t * y;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\t\t\t\t\t\tsmoothstep: function smoothstep(x, min, max) {\n\n\t\t\t\t\t\t\t\t\tif (x <= min) return 0;\n\t\t\t\t\t\t\t\t\tif (x >= max) return 1;\n\n\t\t\t\t\t\t\t\t\tx = (x - min) / (max - min);\n\n\t\t\t\t\t\t\t\t\treturn x * x * (3 - 2 * x);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsmootherstep: function smootherstep(x, min, max) {\n\n\t\t\t\t\t\t\t\t\tif (x <= min) return 0;\n\t\t\t\t\t\t\t\t\tif (x >= max) return 1;\n\n\t\t\t\t\t\t\t\t\tx = (x - min) / (max - min);\n\n\t\t\t\t\t\t\t\t\treturn x * x * x * (x * (x * 6 - 15) + 10);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Random integer from <low, high> interval\n\n\t\t\t\t\t\trandInt: function randInt(low, high) {\n\n\t\t\t\t\t\t\t\t\treturn low + Math.floor(Math.random() * (high - low + 1));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Random float from <low, high> interval\n\n\t\t\t\t\t\trandFloat: function randFloat(low, high) {\n\n\t\t\t\t\t\t\t\t\treturn low + Math.random() * (high - low);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Random float from <-range/2, range/2> interval\n\n\t\t\t\t\t\trandFloatSpread: function randFloatSpread(range) {\n\n\t\t\t\t\t\t\t\t\treturn range * (0.5 - Math.random());\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdegToRad: function degToRad(degrees) {\n\n\t\t\t\t\t\t\t\t\treturn degrees * _Math.DEG2RAD;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tradToDeg: function radToDeg(radians) {\n\n\t\t\t\t\t\t\t\t\treturn radians * _Math.RAD2DEG;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tisPowerOfTwo: function isPowerOfTwo(value) {\n\n\t\t\t\t\t\t\t\t\treturn (value & value - 1) === 0 && value !== 0;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tceilPowerOfTwo: function ceilPowerOfTwo(value) {\n\n\t\t\t\t\t\t\t\t\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfloorPowerOfTwo: function floorPowerOfTwo(value) {\n\n\t\t\t\t\t\t\t\t\treturn Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    */\n\n\t\t\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t\t\t\t\t\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t\t\t\t\t\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t\t\t\t\t\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t\t\t\t\t\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t\t\t\t\t\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t\t\t\t\t\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t\t\t\t\t\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t\t\t\t\t\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t\t\t\t\t\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t\t\t\t\t\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t\t\t\t\t\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t\t\t\t\t\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t\t\t\t\t\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t\t\t\t\t\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t\t\t\t\t\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t\t\t\t\t\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t\t\t\t\t\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t\t\t\t\t\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t\t\t\t\t\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t\t\t\t\t\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t\t\t\t\t\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t\t\t\t\t\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t\t\t\t\t\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n\t\t\tfunction Color(r, g, b) {\n\n\t\t\t\t\t\tif (g === undefined && b === undefined) {\n\n\t\t\t\t\t\t\t\t\t// r is THREE.Color, hex or string\n\t\t\t\t\t\t\t\t\treturn this.set(r);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn this.setRGB(r, g, b);\n\t\t\t}\n\n\t\t\tObject.assign(Color.prototype, {\n\n\t\t\t\t\t\tisColor: true,\n\n\t\t\t\t\t\tr: 1, g: 1, b: 1,\n\n\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\tif (value && value.isColor) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.copy(value);\n\t\t\t\t\t\t\t\t\t} else if (typeof value === 'number') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setHex(value);\n\t\t\t\t\t\t\t\t\t} else if (typeof value === 'string') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setStyle(value);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetScalar: function setScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\tthis.r = scalar;\n\t\t\t\t\t\t\t\t\tthis.g = scalar;\n\t\t\t\t\t\t\t\t\tthis.b = scalar;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetHex: function setHex(hex) {\n\n\t\t\t\t\t\t\t\t\thex = Math.floor(hex);\n\n\t\t\t\t\t\t\t\t\tthis.r = (hex >> 16 & 255) / 255;\n\t\t\t\t\t\t\t\t\tthis.g = (hex >> 8 & 255) / 255;\n\t\t\t\t\t\t\t\t\tthis.b = (hex & 255) / 255;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetRGB: function setRGB(r, g, b) {\n\n\t\t\t\t\t\t\t\t\tthis.r = r;\n\t\t\t\t\t\t\t\t\tthis.g = g;\n\t\t\t\t\t\t\t\t\tthis.b = b;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetHSL: function () {\n\n\t\t\t\t\t\t\t\t\tfunction hue2rgb(p, q, t) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (t < 0) t += 1;\n\t\t\t\t\t\t\t\t\t\t\t\tif (t > 1) t -= 1;\n\t\t\t\t\t\t\t\t\t\t\t\tif (t < 1 / 6) return p + (q - p) * 6 * t;\n\t\t\t\t\t\t\t\t\t\t\t\tif (t < 1 / 2) return q;\n\t\t\t\t\t\t\t\t\t\t\t\tif (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n\t\t\t\t\t\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn function setHSL(h, s, l) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\t\t\t\t\t\t\t\t\th = _Math.euclideanModulo(h, 1);\n\t\t\t\t\t\t\t\t\t\t\t\ts = _Math.clamp(s, 0, 1);\n\t\t\t\t\t\t\t\t\t\t\t\tl = _Math.clamp(l, 0, 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (s === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.r = this.g = this.b = l;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar q = 2 * l - p;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.r = hue2rgb(q, p, h + 1 / 3);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.g = hue2rgb(q, p, h);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.b = hue2rgb(q, p, h - 1 / 3);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tsetStyle: function setStyle(style) {\n\n\t\t\t\t\t\t\t\t\tfunction handleAlpha(string) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (string === undefined) return;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (parseFloat(string) < 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar m;\n\n\t\t\t\t\t\t\t\t\tif (m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(style)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// rgb / hsl\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar color;\n\t\t\t\t\t\t\t\t\t\t\t\tvar name = m[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar components = m[2];\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (name) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'rgb':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'rgba':\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.r = Math.min(255, parseInt(color[1], 10)) / 255;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.g = Math.min(255, parseInt(color[2], 10)) / 255;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.b = Math.min(255, parseInt(color[3], 10)) / 255;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thandleAlpha(color[5]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.r = Math.min(100, parseInt(color[1], 10)) / 100;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.g = Math.min(100, parseInt(color[2], 10)) / 100;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.b = Math.min(100, parseInt(color[3], 10)) / 100;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thandleAlpha(color[5]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'hsl':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'hsla':\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar h = parseFloat(color[1]) / 360;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar s = parseInt(color[2], 10) / 100;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar l = parseInt(color[3], 10) / 100;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thandleAlpha(color[5]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.setHSL(h, s, l);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (m = /^\\#([A-Fa-f0-9]+)$/.exec(style)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// hex color\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar hex = m[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar size = hex.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (size === 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// #ff0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (size === 6) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// #ff0000\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (style && style.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// color keywords\n\t\t\t\t\t\t\t\t\t\t\t\tvar hex = ColorKeywords[style];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hex !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// red\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.setHex(hex);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// unknown color\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Color: Unknown color ' + style);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor(this.r, this.g, this.b);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(color) {\n\n\t\t\t\t\t\t\t\t\tthis.r = color.r;\n\t\t\t\t\t\t\t\t\tthis.g = color.g;\n\t\t\t\t\t\t\t\t\tthis.b = color.b;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyGammaToLinear: function copyGammaToLinear(color, gammaFactor) {\n\n\t\t\t\t\t\t\t\t\tif (gammaFactor === undefined) gammaFactor = 2.0;\n\n\t\t\t\t\t\t\t\t\tthis.r = Math.pow(color.r, gammaFactor);\n\t\t\t\t\t\t\t\t\tthis.g = Math.pow(color.g, gammaFactor);\n\t\t\t\t\t\t\t\t\tthis.b = Math.pow(color.b, gammaFactor);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyLinearToGamma: function copyLinearToGamma(color, gammaFactor) {\n\n\t\t\t\t\t\t\t\t\tif (gammaFactor === undefined) gammaFactor = 2.0;\n\n\t\t\t\t\t\t\t\t\tvar safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\n\n\t\t\t\t\t\t\t\t\tthis.r = Math.pow(color.r, safeInverse);\n\t\t\t\t\t\t\t\t\tthis.g = Math.pow(color.g, safeInverse);\n\t\t\t\t\t\t\t\t\tthis.b = Math.pow(color.b, safeInverse);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tconvertGammaToLinear: function convertGammaToLinear(gammaFactor) {\n\n\t\t\t\t\t\t\t\t\tthis.copyGammaToLinear(this, gammaFactor);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tconvertLinearToGamma: function convertLinearToGamma(gammaFactor) {\n\n\t\t\t\t\t\t\t\t\tthis.copyLinearToGamma(this, gammaFactor);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopySRGBToLinear: function () {\n\n\t\t\t\t\t\t\t\t\tfunction SRGBToLinear(c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn function copySRGBToLinear(color) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.r = SRGBToLinear(color.r);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.g = SRGBToLinear(color.g);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.b = SRGBToLinear(color.b);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tcopyLinearToSRGB: function () {\n\n\t\t\t\t\t\t\t\t\tfunction LinearToSRGB(c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn function copyLinearToSRGB(color) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.r = LinearToSRGB(color.r);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.g = LinearToSRGB(color.g);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.b = LinearToSRGB(color.b);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tconvertSRGBToLinear: function convertSRGBToLinear() {\n\n\t\t\t\t\t\t\t\t\tthis.copySRGBToLinear(this);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tconvertLinearToSRGB: function convertLinearToSRGB() {\n\n\t\t\t\t\t\t\t\t\tthis.copyLinearToSRGB(this);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetHex: function getHex() {\n\n\t\t\t\t\t\t\t\t\treturn this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetHexString: function getHexString() {\n\n\t\t\t\t\t\t\t\t\treturn ('000000' + this.getHex().toString(16)).slice(-6);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetHSL: function getHSL(target) {\n\n\t\t\t\t\t\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Color: .getHSL() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = { h: 0, s: 0, l: 0 };\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar r = this.r,\n\t\t\t\t\t\t\t\t\t    g = this.g,\n\t\t\t\t\t\t\t\t\t    b = this.b;\n\n\t\t\t\t\t\t\t\t\tvar max = Math.max(r, g, b);\n\t\t\t\t\t\t\t\t\tvar min = Math.min(r, g, b);\n\n\t\t\t\t\t\t\t\t\tvar hue, saturation;\n\t\t\t\t\t\t\t\t\tvar lightness = (min + max) / 2.0;\n\n\t\t\t\t\t\t\t\t\tif (min === max) {\n\n\t\t\t\t\t\t\t\t\t\t\t\thue = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tsaturation = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar delta = max - min;\n\n\t\t\t\t\t\t\t\t\t\t\t\tsaturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (max) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase r:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thue = (g - b) / delta + (g < b ? 6 : 0);break;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase g:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thue = (b - r) / delta + 2;break;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase b:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thue = (r - g) / delta + 4;break;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\thue /= 6;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttarget.h = hue;\n\t\t\t\t\t\t\t\t\ttarget.s = saturation;\n\t\t\t\t\t\t\t\t\ttarget.l = lightness;\n\n\t\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetStyle: function getStyle() {\n\n\t\t\t\t\t\t\t\t\treturn 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\toffsetHSL: function () {\n\n\t\t\t\t\t\t\t\t\tvar hsl = {};\n\n\t\t\t\t\t\t\t\t\treturn function (h, s, l) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.getHSL(hsl);\n\n\t\t\t\t\t\t\t\t\t\t\t\thsl.h += h;hsl.s += s;hsl.l += l;\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setHSL(hsl.h, hsl.s, hsl.l);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tadd: function add(color) {\n\n\t\t\t\t\t\t\t\t\tthis.r += color.r;\n\t\t\t\t\t\t\t\t\tthis.g += color.g;\n\t\t\t\t\t\t\t\t\tthis.b += color.b;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddColors: function addColors(color1, color2) {\n\n\t\t\t\t\t\t\t\t\tthis.r = color1.r + color2.r;\n\t\t\t\t\t\t\t\t\tthis.g = color1.g + color2.g;\n\t\t\t\t\t\t\t\t\tthis.b = color1.b + color2.b;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddScalar: function addScalar(s) {\n\n\t\t\t\t\t\t\t\t\tthis.r += s;\n\t\t\t\t\t\t\t\t\tthis.g += s;\n\t\t\t\t\t\t\t\t\tthis.b += s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsub: function sub(color) {\n\n\t\t\t\t\t\t\t\t\tthis.r = Math.max(0, this.r - color.r);\n\t\t\t\t\t\t\t\t\tthis.g = Math.max(0, this.g - color.g);\n\t\t\t\t\t\t\t\t\tthis.b = Math.max(0, this.b - color.b);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiply: function multiply(color) {\n\n\t\t\t\t\t\t\t\t\tthis.r *= color.r;\n\t\t\t\t\t\t\t\t\tthis.g *= color.g;\n\t\t\t\t\t\t\t\t\tthis.b *= color.b;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyScalar: function multiplyScalar(s) {\n\n\t\t\t\t\t\t\t\t\tthis.r *= s;\n\t\t\t\t\t\t\t\t\tthis.g *= s;\n\t\t\t\t\t\t\t\t\tthis.b *= s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlerp: function lerp(color, alpha) {\n\n\t\t\t\t\t\t\t\t\tthis.r += (color.r - this.r) * alpha;\n\t\t\t\t\t\t\t\t\tthis.g += (color.g - this.g) * alpha;\n\t\t\t\t\t\t\t\t\tthis.b += (color.b - this.b) * alpha;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlerpHSL: function () {\n\n\t\t\t\t\t\t\t\t\tvar hslA = { h: 0, s: 0, l: 0 };\n\t\t\t\t\t\t\t\t\tvar hslB = { h: 0, s: 0, l: 0 };\n\n\t\t\t\t\t\t\t\t\treturn function lerpHSL(color, alpha) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.getHSL(hslA);\n\t\t\t\t\t\t\t\t\t\t\t\tcolor.getHSL(hslB);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar h = _Math.lerp(hslA.h, hslB.h, alpha);\n\t\t\t\t\t\t\t\t\t\t\t\tvar s = _Math.lerp(hslA.s, hslB.s, alpha);\n\t\t\t\t\t\t\t\t\t\t\t\tvar l = _Math.lerp(hslA.l, hslB.l, alpha);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setHSL(h, s, l);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tequals: function equals(c) {\n\n\t\t\t\t\t\t\t\t\treturn c.r === this.r && c.g === this.g && c.b === this.b;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromArray: function fromArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tthis.r = array[offset];\n\t\t\t\t\t\t\t\t\tthis.g = array[offset + 1];\n\t\t\t\t\t\t\t\t\tthis.b = array[offset + 2];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoArray: function toArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (array === undefined) array = [];\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tarray[offset] = this.r;\n\t\t\t\t\t\t\t\t\tarray[offset + 1] = this.g;\n\t\t\t\t\t\t\t\t\tarray[offset + 2] = this.b;\n\n\t\t\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoJSON: function toJSON() {\n\n\t\t\t\t\t\t\t\t\treturn this.getHex();\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetColorKeyword: function getColorKeyword() {\n\n\t\t\t\t\t\t\t\t\treturn ColorKeywords;\n\t\t\t\t\t\t}\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    * @author supereggbert / http://www.paulbrunt.co.uk/\r\n    * @author philogb / http://blog.thejit.org/\r\n    * @author jordi_ros / http://plattsoft.com\r\n    * @author D1plo1d / http://github.com/D1plo1d\r\n    * @author alteredq / http://alteredqualia.com/\r\n    * @author mikael emtinger / http://gomo.se/\r\n    * @author timknip / http://www.floorplanner.com/\r\n    * @author bhouston / http://clara.io\r\n    * @author WestLangley / http://github.com/WestLangley\r\n    */\n\n\t\t\tfunction Matrix4() {\n\n\t\t\t\t\t\tthis.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n\t\t\t\t\t\tif (arguments.length > 0) {\n\n\t\t\t\t\t\t\t\t\tconsole.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject.assign(Matrix4.prototype, {\n\n\t\t\t\t\t\tisMatrix4: true,\n\n\t\t\t\t\t\tset: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tte[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;\n\t\t\t\t\t\t\t\t\tte[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;\n\t\t\t\t\t\t\t\t\tte[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;\n\t\t\t\t\t\t\t\t\tte[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tidentity: function identity() {\n\n\t\t\t\t\t\t\t\t\tthis.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new Matrix4().fromArray(this.elements);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(m) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\tvar me = m.elements;\n\n\t\t\t\t\t\t\t\t\tte[0] = me[0];te[1] = me[1];te[2] = me[2];te[3] = me[3];\n\t\t\t\t\t\t\t\t\tte[4] = me[4];te[5] = me[5];te[6] = me[6];te[7] = me[7];\n\t\t\t\t\t\t\t\t\tte[8] = me[8];te[9] = me[9];te[10] = me[10];te[11] = me[11];\n\t\t\t\t\t\t\t\t\tte[12] = me[12];te[13] = me[13];te[14] = me[14];te[15] = me[15];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyPosition: function copyPosition(m) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements,\n\t\t\t\t\t\t\t\t\t    me = m.elements;\n\n\t\t\t\t\t\t\t\t\tte[12] = me[12];\n\t\t\t\t\t\t\t\t\tte[13] = me[13];\n\t\t\t\t\t\t\t\t\tte[14] = me[14];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\textractBasis: function extractBasis(xAxis, yAxis, zAxis) {\n\n\t\t\t\t\t\t\t\t\txAxis.setFromMatrixColumn(this, 0);\n\t\t\t\t\t\t\t\t\tyAxis.setFromMatrixColumn(this, 1);\n\t\t\t\t\t\t\t\t\tzAxis.setFromMatrixColumn(this, 2);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeBasis: function makeBasis(xAxis, yAxis, zAxis) {\n\n\t\t\t\t\t\t\t\t\tthis.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\textractRotation: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function extractRotation(m) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// this method does not support reflection matrices\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\t\t\t\tvar me = m.elements;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();\n\t\t\t\t\t\t\t\t\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();\n\t\t\t\t\t\t\t\t\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[0] = me[0] * scaleX;\n\t\t\t\t\t\t\t\t\t\t\t\tte[1] = me[1] * scaleX;\n\t\t\t\t\t\t\t\t\t\t\t\tte[2] = me[2] * scaleX;\n\t\t\t\t\t\t\t\t\t\t\t\tte[3] = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[4] = me[4] * scaleY;\n\t\t\t\t\t\t\t\t\t\t\t\tte[5] = me[5] * scaleY;\n\t\t\t\t\t\t\t\t\t\t\t\tte[6] = me[6] * scaleY;\n\t\t\t\t\t\t\t\t\t\t\t\tte[7] = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[8] = me[8] * scaleZ;\n\t\t\t\t\t\t\t\t\t\t\t\tte[9] = me[9] * scaleZ;\n\t\t\t\t\t\t\t\t\t\t\t\tte[10] = me[10] * scaleZ;\n\t\t\t\t\t\t\t\t\t\t\t\tte[11] = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[12] = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tte[13] = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tte[14] = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tte[15] = 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tmakeRotationFromEuler: function makeRotationFromEuler(euler) {\n\n\t\t\t\t\t\t\t\t\tif (!(euler && euler.isEuler)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tvar x = euler.x,\n\t\t\t\t\t\t\t\t\t    y = euler.y,\n\t\t\t\t\t\t\t\t\t    z = euler.z;\n\t\t\t\t\t\t\t\t\tvar a = Math.cos(x),\n\t\t\t\t\t\t\t\t\t    b = Math.sin(x);\n\t\t\t\t\t\t\t\t\tvar c = Math.cos(y),\n\t\t\t\t\t\t\t\t\t    d = Math.sin(y);\n\t\t\t\t\t\t\t\t\tvar e = Math.cos(z),\n\t\t\t\t\t\t\t\t\t    f = Math.sin(z);\n\n\t\t\t\t\t\t\t\t\tif (euler.order === 'XYZ') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar ae = a * e,\n\t\t\t\t\t\t\t\t\t\t\t\t    af = a * f,\n\t\t\t\t\t\t\t\t\t\t\t\t    be = b * e,\n\t\t\t\t\t\t\t\t\t\t\t\t    bf = b * f;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[0] = c * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[4] = -c * f;\n\t\t\t\t\t\t\t\t\t\t\t\tte[8] = d;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[1] = af + be * d;\n\t\t\t\t\t\t\t\t\t\t\t\tte[5] = ae - bf * d;\n\t\t\t\t\t\t\t\t\t\t\t\tte[9] = -b * c;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[2] = bf - ae * d;\n\t\t\t\t\t\t\t\t\t\t\t\tte[6] = be + af * d;\n\t\t\t\t\t\t\t\t\t\t\t\tte[10] = a * c;\n\t\t\t\t\t\t\t\t\t} else if (euler.order === 'YXZ') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar ce = c * e,\n\t\t\t\t\t\t\t\t\t\t\t\t    cf = c * f,\n\t\t\t\t\t\t\t\t\t\t\t\t    de = d * e,\n\t\t\t\t\t\t\t\t\t\t\t\t    df = d * f;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[0] = ce + df * b;\n\t\t\t\t\t\t\t\t\t\t\t\tte[4] = de * b - cf;\n\t\t\t\t\t\t\t\t\t\t\t\tte[8] = a * d;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[1] = a * f;\n\t\t\t\t\t\t\t\t\t\t\t\tte[5] = a * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[9] = -b;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[2] = cf * b - de;\n\t\t\t\t\t\t\t\t\t\t\t\tte[6] = df + ce * b;\n\t\t\t\t\t\t\t\t\t\t\t\tte[10] = a * c;\n\t\t\t\t\t\t\t\t\t} else if (euler.order === 'ZXY') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar ce = c * e,\n\t\t\t\t\t\t\t\t\t\t\t\t    cf = c * f,\n\t\t\t\t\t\t\t\t\t\t\t\t    de = d * e,\n\t\t\t\t\t\t\t\t\t\t\t\t    df = d * f;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[0] = ce - df * b;\n\t\t\t\t\t\t\t\t\t\t\t\tte[4] = -a * f;\n\t\t\t\t\t\t\t\t\t\t\t\tte[8] = de + cf * b;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[1] = cf + de * b;\n\t\t\t\t\t\t\t\t\t\t\t\tte[5] = a * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[9] = df - ce * b;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[2] = -a * d;\n\t\t\t\t\t\t\t\t\t\t\t\tte[6] = b;\n\t\t\t\t\t\t\t\t\t\t\t\tte[10] = a * c;\n\t\t\t\t\t\t\t\t\t} else if (euler.order === 'ZYX') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar ae = a * e,\n\t\t\t\t\t\t\t\t\t\t\t\t    af = a * f,\n\t\t\t\t\t\t\t\t\t\t\t\t    be = b * e,\n\t\t\t\t\t\t\t\t\t\t\t\t    bf = b * f;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[0] = c * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[4] = be * d - af;\n\t\t\t\t\t\t\t\t\t\t\t\tte[8] = ae * d + bf;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[1] = c * f;\n\t\t\t\t\t\t\t\t\t\t\t\tte[5] = bf * d + ae;\n\t\t\t\t\t\t\t\t\t\t\t\tte[9] = af * d - be;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[2] = -d;\n\t\t\t\t\t\t\t\t\t\t\t\tte[6] = b * c;\n\t\t\t\t\t\t\t\t\t\t\t\tte[10] = a * c;\n\t\t\t\t\t\t\t\t\t} else if (euler.order === 'YZX') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar ac = a * c,\n\t\t\t\t\t\t\t\t\t\t\t\t    ad = a * d,\n\t\t\t\t\t\t\t\t\t\t\t\t    bc = b * c,\n\t\t\t\t\t\t\t\t\t\t\t\t    bd = b * d;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[0] = c * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[4] = bd - ac * f;\n\t\t\t\t\t\t\t\t\t\t\t\tte[8] = bc * f + ad;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[1] = f;\n\t\t\t\t\t\t\t\t\t\t\t\tte[5] = a * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[9] = -b * e;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[2] = -d * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[6] = ad * f + bc;\n\t\t\t\t\t\t\t\t\t\t\t\tte[10] = ac - bd * f;\n\t\t\t\t\t\t\t\t\t} else if (euler.order === 'XZY') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar ac = a * c,\n\t\t\t\t\t\t\t\t\t\t\t\t    ad = a * d,\n\t\t\t\t\t\t\t\t\t\t\t\t    bc = b * c,\n\t\t\t\t\t\t\t\t\t\t\t\t    bd = b * d;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[0] = c * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[4] = -f;\n\t\t\t\t\t\t\t\t\t\t\t\tte[8] = d * e;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[1] = ac * f + bd;\n\t\t\t\t\t\t\t\t\t\t\t\tte[5] = a * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[9] = ad * f - bc;\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[2] = bc * f - ad;\n\t\t\t\t\t\t\t\t\t\t\t\tte[6] = b * e;\n\t\t\t\t\t\t\t\t\t\t\t\tte[10] = bd * f + ac;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// bottom row\n\t\t\t\t\t\t\t\t\tte[3] = 0;\n\t\t\t\t\t\t\t\t\tte[7] = 0;\n\t\t\t\t\t\t\t\t\tte[11] = 0;\n\n\t\t\t\t\t\t\t\t\t// last column\n\t\t\t\t\t\t\t\t\tte[12] = 0;\n\t\t\t\t\t\t\t\t\tte[13] = 0;\n\t\t\t\t\t\t\t\t\tte[14] = 0;\n\t\t\t\t\t\t\t\t\tte[15] = 1;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeRotationFromQuaternion: function () {\n\n\t\t\t\t\t\t\t\t\tvar zero = new Vector3(0, 0, 0);\n\t\t\t\t\t\t\t\t\tvar one = new Vector3(1, 1, 1);\n\n\t\t\t\t\t\t\t\t\treturn function makeRotationFromQuaternion(q) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.compose(zero, q, one);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tlookAt: function () {\n\n\t\t\t\t\t\t\t\t\tvar x = new Vector3();\n\t\t\t\t\t\t\t\t\tvar y = new Vector3();\n\t\t\t\t\t\t\t\t\tvar z = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function lookAt(eye, target, up) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\t\t\t\tz.subVectors(eye, target);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (z.lengthSq() === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// eye and target are in the same position\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz.z = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tz.normalize();\n\t\t\t\t\t\t\t\t\t\t\t\tx.crossVectors(up, z);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (x.lengthSq() === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// up and z are parallel\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(up.z) === 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz.x += 0.0001;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz.normalize();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx.crossVectors(up, z);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tx.normalize();\n\t\t\t\t\t\t\t\t\t\t\t\ty.crossVectors(z, x);\n\n\t\t\t\t\t\t\t\t\t\t\t\tte[0] = x.x;te[4] = y.x;te[8] = z.x;\n\t\t\t\t\t\t\t\t\t\t\t\tte[1] = x.y;te[5] = y.y;te[9] = z.y;\n\t\t\t\t\t\t\t\t\t\t\t\tte[2] = x.z;te[6] = y.z;te[10] = z.z;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tmultiply: function multiply(m, n) {\n\n\t\t\t\t\t\t\t\t\tif (n !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.multiplyMatrices(m, n);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyMatrices(this, m);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tpremultiply: function premultiply(m) {\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyMatrices(m, this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyMatrices: function multiplyMatrices(a, b) {\n\n\t\t\t\t\t\t\t\t\tvar ae = a.elements;\n\t\t\t\t\t\t\t\t\tvar be = b.elements;\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tvar a11 = ae[0],\n\t\t\t\t\t\t\t\t\t    a12 = ae[4],\n\t\t\t\t\t\t\t\t\t    a13 = ae[8],\n\t\t\t\t\t\t\t\t\t    a14 = ae[12];\n\t\t\t\t\t\t\t\t\tvar a21 = ae[1],\n\t\t\t\t\t\t\t\t\t    a22 = ae[5],\n\t\t\t\t\t\t\t\t\t    a23 = ae[9],\n\t\t\t\t\t\t\t\t\t    a24 = ae[13];\n\t\t\t\t\t\t\t\t\tvar a31 = ae[2],\n\t\t\t\t\t\t\t\t\t    a32 = ae[6],\n\t\t\t\t\t\t\t\t\t    a33 = ae[10],\n\t\t\t\t\t\t\t\t\t    a34 = ae[14];\n\t\t\t\t\t\t\t\t\tvar a41 = ae[3],\n\t\t\t\t\t\t\t\t\t    a42 = ae[7],\n\t\t\t\t\t\t\t\t\t    a43 = ae[11],\n\t\t\t\t\t\t\t\t\t    a44 = ae[15];\n\n\t\t\t\t\t\t\t\t\tvar b11 = be[0],\n\t\t\t\t\t\t\t\t\t    b12 = be[4],\n\t\t\t\t\t\t\t\t\t    b13 = be[8],\n\t\t\t\t\t\t\t\t\t    b14 = be[12];\n\t\t\t\t\t\t\t\t\tvar b21 = be[1],\n\t\t\t\t\t\t\t\t\t    b22 = be[5],\n\t\t\t\t\t\t\t\t\t    b23 = be[9],\n\t\t\t\t\t\t\t\t\t    b24 = be[13];\n\t\t\t\t\t\t\t\t\tvar b31 = be[2],\n\t\t\t\t\t\t\t\t\t    b32 = be[6],\n\t\t\t\t\t\t\t\t\t    b33 = be[10],\n\t\t\t\t\t\t\t\t\t    b34 = be[14];\n\t\t\t\t\t\t\t\t\tvar b41 = be[3],\n\t\t\t\t\t\t\t\t\t    b42 = be[7],\n\t\t\t\t\t\t\t\t\t    b43 = be[11],\n\t\t\t\t\t\t\t\t\t    b44 = be[15];\n\n\t\t\t\t\t\t\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\t\t\t\t\t\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\t\t\t\t\t\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\t\t\t\t\t\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\t\t\t\t\t\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\t\t\t\t\t\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\t\t\t\t\t\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\t\t\t\t\t\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\t\t\t\t\t\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\t\t\t\t\t\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\t\t\t\t\t\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\t\t\t\t\t\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\t\t\t\t\t\t\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\t\t\t\t\t\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\t\t\t\t\t\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\t\t\t\t\t\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyScalar: function multiplyScalar(s) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tte[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;\n\t\t\t\t\t\t\t\t\tte[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;\n\t\t\t\t\t\t\t\t\tte[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;\n\t\t\t\t\t\t\t\t\tte[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyToBufferAttribute: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function applyToBufferAttribute(attribute) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = attribute.count; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.x = attribute.getX(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.y = attribute.getY(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.z = attribute.getZ(i);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.applyMatrix4(this);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.setXYZ(i, v1.x, v1.y, v1.z);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn attribute;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tdeterminant: function determinant() {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tvar n11 = te[0],\n\t\t\t\t\t\t\t\t\t    n12 = te[4],\n\t\t\t\t\t\t\t\t\t    n13 = te[8],\n\t\t\t\t\t\t\t\t\t    n14 = te[12];\n\t\t\t\t\t\t\t\t\tvar n21 = te[1],\n\t\t\t\t\t\t\t\t\t    n22 = te[5],\n\t\t\t\t\t\t\t\t\t    n23 = te[9],\n\t\t\t\t\t\t\t\t\t    n24 = te[13];\n\t\t\t\t\t\t\t\t\tvar n31 = te[2],\n\t\t\t\t\t\t\t\t\t    n32 = te[6],\n\t\t\t\t\t\t\t\t\t    n33 = te[10],\n\t\t\t\t\t\t\t\t\t    n34 = te[14];\n\t\t\t\t\t\t\t\t\tvar n41 = te[3],\n\t\t\t\t\t\t\t\t\t    n42 = te[7],\n\t\t\t\t\t\t\t\t\t    n43 = te[11],\n\t\t\t\t\t\t\t\t\t    n44 = te[15];\n\n\t\t\t\t\t\t\t\t\t//TODO: make this more efficient\n\t\t\t\t\t\t\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\t\t\t\t\t\t\treturn n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttranspose: function transpose() {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\tvar tmp;\n\n\t\t\t\t\t\t\t\t\ttmp = te[1];te[1] = te[4];te[4] = tmp;\n\t\t\t\t\t\t\t\t\ttmp = te[2];te[2] = te[8];te[8] = tmp;\n\t\t\t\t\t\t\t\t\ttmp = te[6];te[6] = te[9];te[9] = tmp;\n\n\t\t\t\t\t\t\t\t\ttmp = te[3];te[3] = te[12];te[12] = tmp;\n\t\t\t\t\t\t\t\t\ttmp = te[7];te[7] = te[13];te[13] = tmp;\n\t\t\t\t\t\t\t\t\ttmp = te[11];te[11] = te[14];te[14] = tmp;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetPosition: function setPosition(v) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tte[12] = v.x;\n\t\t\t\t\t\t\t\t\tte[13] = v.y;\n\t\t\t\t\t\t\t\t\tte[14] = v.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetInverse: function getInverse(m, throwOnDegenerate) {\n\n\t\t\t\t\t\t\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\t\t\t\t\t\t\tvar te = this.elements,\n\t\t\t\t\t\t\t\t\t    me = m.elements,\n\t\t\t\t\t\t\t\t\t    n11 = me[0],\n\t\t\t\t\t\t\t\t\t    n21 = me[1],\n\t\t\t\t\t\t\t\t\t    n31 = me[2],\n\t\t\t\t\t\t\t\t\t    n41 = me[3],\n\t\t\t\t\t\t\t\t\t    n12 = me[4],\n\t\t\t\t\t\t\t\t\t    n22 = me[5],\n\t\t\t\t\t\t\t\t\t    n32 = me[6],\n\t\t\t\t\t\t\t\t\t    n42 = me[7],\n\t\t\t\t\t\t\t\t\t    n13 = me[8],\n\t\t\t\t\t\t\t\t\t    n23 = me[9],\n\t\t\t\t\t\t\t\t\t    n33 = me[10],\n\t\t\t\t\t\t\t\t\t    n43 = me[11],\n\t\t\t\t\t\t\t\t\t    n14 = me[12],\n\t\t\t\t\t\t\t\t\t    n24 = me[13],\n\t\t\t\t\t\t\t\t\t    n34 = me[14],\n\t\t\t\t\t\t\t\t\t    n44 = me[15],\n\t\t\t\t\t\t\t\t\t    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\t\t\t\t\t\t    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\t\t\t\t\t\t    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\t\t\t\t\t\t    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\t\t\t\t\t\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\t\t\t\t\t\t\t\tif (det === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (throwOnDegenerate === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn(msg);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.identity();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar detInv = 1 / det;\n\n\t\t\t\t\t\t\t\t\tte[0] = t11 * detInv;\n\t\t\t\t\t\t\t\t\tte[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n\t\t\t\t\t\t\t\t\tte[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n\t\t\t\t\t\t\t\t\tte[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n\n\t\t\t\t\t\t\t\t\tte[4] = t12 * detInv;\n\t\t\t\t\t\t\t\t\tte[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n\t\t\t\t\t\t\t\t\tte[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n\t\t\t\t\t\t\t\t\tte[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n\n\t\t\t\t\t\t\t\t\tte[8] = t13 * detInv;\n\t\t\t\t\t\t\t\t\tte[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n\t\t\t\t\t\t\t\t\tte[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n\t\t\t\t\t\t\t\t\tte[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n\n\t\t\t\t\t\t\t\t\tte[12] = t14 * detInv;\n\t\t\t\t\t\t\t\t\tte[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n\t\t\t\t\t\t\t\t\tte[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n\t\t\t\t\t\t\t\t\tte[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tscale: function scale(v) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\tvar x = v.x,\n\t\t\t\t\t\t\t\t\t    y = v.y,\n\t\t\t\t\t\t\t\t\t    z = v.z;\n\n\t\t\t\t\t\t\t\t\tte[0] *= x;te[4] *= y;te[8] *= z;\n\t\t\t\t\t\t\t\t\tte[1] *= x;te[5] *= y;te[9] *= z;\n\t\t\t\t\t\t\t\t\tte[2] *= x;te[6] *= y;te[10] *= z;\n\t\t\t\t\t\t\t\t\tte[3] *= x;te[7] *= y;te[11] *= z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetMaxScaleOnAxis: function getMaxScaleOnAxis() {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\t\t\t\t\t\t\t\t\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\t\t\t\t\t\t\t\t\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n\t\t\t\t\t\t\t\t\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeTranslation: function makeTranslation(x, y, z) {\n\n\t\t\t\t\t\t\t\t\tthis.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeRotationX: function makeRotationX(theta) {\n\n\t\t\t\t\t\t\t\t\tvar c = Math.cos(theta),\n\t\t\t\t\t\t\t\t\t    s = Math.sin(theta);\n\n\t\t\t\t\t\t\t\t\tthis.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeRotationY: function makeRotationY(theta) {\n\n\t\t\t\t\t\t\t\t\tvar c = Math.cos(theta),\n\t\t\t\t\t\t\t\t\t    s = Math.sin(theta);\n\n\t\t\t\t\t\t\t\t\tthis.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeRotationZ: function makeRotationZ(theta) {\n\n\t\t\t\t\t\t\t\t\tvar c = Math.cos(theta),\n\t\t\t\t\t\t\t\t\t    s = Math.sin(theta);\n\n\t\t\t\t\t\t\t\t\tthis.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeRotationAxis: function makeRotationAxis(axis, angle) {\n\n\t\t\t\t\t\t\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\t\t\t\t\t\t\t\tvar c = Math.cos(angle);\n\t\t\t\t\t\t\t\t\tvar s = Math.sin(angle);\n\t\t\t\t\t\t\t\t\tvar t = 1 - c;\n\t\t\t\t\t\t\t\t\tvar x = axis.x,\n\t\t\t\t\t\t\t\t\t    y = axis.y,\n\t\t\t\t\t\t\t\t\t    z = axis.z;\n\t\t\t\t\t\t\t\t\tvar tx = t * x,\n\t\t\t\t\t\t\t\t\t    ty = t * y;\n\n\t\t\t\t\t\t\t\t\tthis.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeScale: function makeScale(x, y, z) {\n\n\t\t\t\t\t\t\t\t\tthis.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeShear: function makeShear(x, y, z) {\n\n\t\t\t\t\t\t\t\t\tthis.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcompose: function compose(position, quaternion, scale) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tvar x = quaternion._x,\n\t\t\t\t\t\t\t\t\t    y = quaternion._y,\n\t\t\t\t\t\t\t\t\t    z = quaternion._z,\n\t\t\t\t\t\t\t\t\t    w = quaternion._w;\n\t\t\t\t\t\t\t\t\tvar x2 = x + x,\n\t\t\t\t\t\t\t\t\t    y2 = y + y,\n\t\t\t\t\t\t\t\t\t    z2 = z + z;\n\t\t\t\t\t\t\t\t\tvar xx = x * x2,\n\t\t\t\t\t\t\t\t\t    xy = x * y2,\n\t\t\t\t\t\t\t\t\t    xz = x * z2;\n\t\t\t\t\t\t\t\t\tvar yy = y * y2,\n\t\t\t\t\t\t\t\t\t    yz = y * z2,\n\t\t\t\t\t\t\t\t\t    zz = z * z2;\n\t\t\t\t\t\t\t\t\tvar wx = w * x2,\n\t\t\t\t\t\t\t\t\t    wy = w * y2,\n\t\t\t\t\t\t\t\t\t    wz = w * z2;\n\n\t\t\t\t\t\t\t\t\tvar sx = scale.x,\n\t\t\t\t\t\t\t\t\t    sy = scale.y,\n\t\t\t\t\t\t\t\t\t    sz = scale.z;\n\n\t\t\t\t\t\t\t\t\tte[0] = (1 - (yy + zz)) * sx;\n\t\t\t\t\t\t\t\t\tte[1] = (xy + wz) * sx;\n\t\t\t\t\t\t\t\t\tte[2] = (xz - wy) * sx;\n\t\t\t\t\t\t\t\t\tte[3] = 0;\n\n\t\t\t\t\t\t\t\t\tte[4] = (xy - wz) * sy;\n\t\t\t\t\t\t\t\t\tte[5] = (1 - (xx + zz)) * sy;\n\t\t\t\t\t\t\t\t\tte[6] = (yz + wx) * sy;\n\t\t\t\t\t\t\t\t\tte[7] = 0;\n\n\t\t\t\t\t\t\t\t\tte[8] = (xz + wy) * sz;\n\t\t\t\t\t\t\t\t\tte[9] = (yz - wx) * sz;\n\t\t\t\t\t\t\t\t\tte[10] = (1 - (xx + yy)) * sz;\n\t\t\t\t\t\t\t\t\tte[11] = 0;\n\n\t\t\t\t\t\t\t\t\tte[12] = position.x;\n\t\t\t\t\t\t\t\t\tte[13] = position.y;\n\t\t\t\t\t\t\t\t\tte[14] = position.z;\n\t\t\t\t\t\t\t\t\tte[15] = 1;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdecompose: function () {\n\n\t\t\t\t\t\t\t\t\tvar vector = new Vector3();\n\t\t\t\t\t\t\t\t\tvar matrix = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function decompose(position, quaternion, scale) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar sx = vector.set(te[0], te[1], te[2]).length();\n\t\t\t\t\t\t\t\t\t\t\t\tvar sy = vector.set(te[4], te[5], te[6]).length();\n\t\t\t\t\t\t\t\t\t\t\t\tvar sz = vector.set(te[8], te[9], te[10]).length();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\t\t\t\t\t\t\t\t\tvar det = this.determinant();\n\t\t\t\t\t\t\t\t\t\t\t\tif (det < 0) sx = -sx;\n\n\t\t\t\t\t\t\t\t\t\t\t\tposition.x = te[12];\n\t\t\t\t\t\t\t\t\t\t\t\tposition.y = te[13];\n\t\t\t\t\t\t\t\t\t\t\t\tposition.z = te[14];\n\n\t\t\t\t\t\t\t\t\t\t\t\t// scale the rotation part\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.copy(this);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\t\t\t\t\t\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\t\t\t\t\t\t\t\t\tvar invSZ = 1 / sz;\n\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[0] *= invSX;\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[1] *= invSX;\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[2] *= invSX;\n\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[4] *= invSY;\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[5] *= invSY;\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[6] *= invSY;\n\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[8] *= invSZ;\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[9] *= invSZ;\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.elements[10] *= invSZ;\n\n\t\t\t\t\t\t\t\t\t\t\t\tquaternion.setFromRotationMatrix(matrix);\n\n\t\t\t\t\t\t\t\t\t\t\t\tscale.x = sx;\n\t\t\t\t\t\t\t\t\t\t\t\tscale.y = sy;\n\t\t\t\t\t\t\t\t\t\t\t\tscale.z = sz;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tmakePerspective: function makePerspective(left, right, top, bottom, near, far) {\n\n\t\t\t\t\t\t\t\t\tif (far === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\tvar x = 2 * near / (right - left);\n\t\t\t\t\t\t\t\t\tvar y = 2 * near / (top - bottom);\n\n\t\t\t\t\t\t\t\t\tvar a = (right + left) / (right - left);\n\t\t\t\t\t\t\t\t\tvar b = (top + bottom) / (top - bottom);\n\t\t\t\t\t\t\t\t\tvar c = -(far + near) / (far - near);\n\t\t\t\t\t\t\t\t\tvar d = -2 * far * near / (far - near);\n\n\t\t\t\t\t\t\t\t\tte[0] = x;te[4] = 0;te[8] = a;te[12] = 0;\n\t\t\t\t\t\t\t\t\tte[1] = 0;te[5] = y;te[9] = b;te[13] = 0;\n\t\t\t\t\t\t\t\t\tte[2] = 0;te[6] = 0;te[10] = c;te[14] = d;\n\t\t\t\t\t\t\t\t\tte[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\tvar w = 1.0 / (right - left);\n\t\t\t\t\t\t\t\t\tvar h = 1.0 / (top - bottom);\n\t\t\t\t\t\t\t\t\tvar p = 1.0 / (far - near);\n\n\t\t\t\t\t\t\t\t\tvar x = (right + left) * w;\n\t\t\t\t\t\t\t\t\tvar y = (top + bottom) * h;\n\t\t\t\t\t\t\t\t\tvar z = (far + near) * p;\n\n\t\t\t\t\t\t\t\t\tte[0] = 2 * w;te[4] = 0;te[8] = 0;te[12] = -x;\n\t\t\t\t\t\t\t\t\tte[1] = 0;te[5] = 2 * h;te[9] = 0;te[13] = -y;\n\t\t\t\t\t\t\t\t\tte[2] = 0;te[6] = 0;te[10] = -2 * p;te[14] = -z;\n\t\t\t\t\t\t\t\t\tte[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tequals: function equals(matrix) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\tvar me = matrix.elements;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < 16; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (te[i] !== me[i]) return false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromArray: function fromArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < 16; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.elements[i] = array[i + offset];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoArray: function toArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (array === undefined) array = [];\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tarray[offset] = te[0];\n\t\t\t\t\t\t\t\t\tarray[offset + 1] = te[1];\n\t\t\t\t\t\t\t\t\tarray[offset + 2] = te[2];\n\t\t\t\t\t\t\t\t\tarray[offset + 3] = te[3];\n\n\t\t\t\t\t\t\t\t\tarray[offset + 4] = te[4];\n\t\t\t\t\t\t\t\t\tarray[offset + 5] = te[5];\n\t\t\t\t\t\t\t\t\tarray[offset + 6] = te[6];\n\t\t\t\t\t\t\t\t\tarray[offset + 7] = te[7];\n\n\t\t\t\t\t\t\t\t\tarray[offset + 8] = te[8];\n\t\t\t\t\t\t\t\t\tarray[offset + 9] = te[9];\n\t\t\t\t\t\t\t\t\tarray[offset + 10] = te[10];\n\t\t\t\t\t\t\t\t\tarray[offset + 11] = te[11];\n\n\t\t\t\t\t\t\t\t\tarray[offset + 12] = te[12];\n\t\t\t\t\t\t\t\t\tarray[offset + 13] = te[13];\n\t\t\t\t\t\t\t\t\tarray[offset + 14] = te[14];\n\t\t\t\t\t\t\t\t\tarray[offset + 15] = te[15];\n\n\t\t\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mikael emtinger / http://gomo.se/\r\n    * @author alteredq / http://alteredqualia.com/\r\n    * @author WestLangley / http://github.com/WestLangley\r\n    * @author bhouston / http://clara.io\r\n    */\n\n\t\t\tfunction Quaternion(x, y, z, w) {\n\n\t\t\t\t\t\tthis._x = x || 0;\n\t\t\t\t\t\tthis._y = y || 0;\n\t\t\t\t\t\tthis._z = z || 0;\n\t\t\t\t\t\tthis._w = w !== undefined ? w : 1;\n\t\t\t}\n\n\t\t\tObject.assign(Quaternion, {\n\n\t\t\t\t\t\tslerp: function slerp(qa, qb, qm, t) {\n\n\t\t\t\t\t\t\t\t\treturn qm.copy(qa).slerp(qb, t);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tslerpFlat: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n\n\t\t\t\t\t\t\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\t\t\t\t\t\t\t\tvar x0 = src0[srcOffset0 + 0],\n\t\t\t\t\t\t\t\t\t    y0 = src0[srcOffset0 + 1],\n\t\t\t\t\t\t\t\t\t    z0 = src0[srcOffset0 + 2],\n\t\t\t\t\t\t\t\t\t    w0 = src0[srcOffset0 + 3],\n\t\t\t\t\t\t\t\t\t    x1 = src1[srcOffset1 + 0],\n\t\t\t\t\t\t\t\t\t    y1 = src1[srcOffset1 + 1],\n\t\t\t\t\t\t\t\t\t    z1 = src1[srcOffset1 + 2],\n\t\t\t\t\t\t\t\t\t    w1 = src1[srcOffset1 + 3];\n\n\t\t\t\t\t\t\t\t\tif (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar s = 1 - t,\n\t\t\t\t\t\t\t\t\t\t\t\t    cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\t\t\t\t\t\t\t\t\t    dir = cos >= 0 ? 1 : -1,\n\t\t\t\t\t\t\t\t\t\t\t\t    sqrSin = 1 - cos * cos;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\t\t\t\t\t\t\t\t\tif (sqrSin > Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar sin = Math.sqrt(sqrSin),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    len = Math.atan2(sin, cos * dir);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ts = Math.sin(s * len) / sin;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tt = Math.sin(t * len) / sin;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar tDir = t * dir;\n\n\t\t\t\t\t\t\t\t\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\t\t\t\t\t\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\t\t\t\t\t\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\t\t\t\t\t\t\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\t\t\t\t\t\t\t\t\tif (s === 1 - t) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx0 *= f;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty0 *= f;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz0 *= f;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tw0 *= f;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdst[dstOffset] = x0;\n\t\t\t\t\t\t\t\t\tdst[dstOffset + 1] = y0;\n\t\t\t\t\t\t\t\t\tdst[dstOffset + 2] = z0;\n\t\t\t\t\t\t\t\t\tdst[dstOffset + 3] = w0;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tObject.defineProperties(Quaternion.prototype, {\n\n\t\t\t\t\t\tx: {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this._x;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = value;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ty: {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this._y;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = value;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tz: {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this._z;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = value;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tw: {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this._w;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = value;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tObject.assign(Quaternion.prototype, {\n\n\t\t\t\t\t\tisQuaternion: true,\n\n\t\t\t\t\t\tset: function set(x, y, z, w) {\n\n\t\t\t\t\t\t\t\t\tthis._x = x;\n\t\t\t\t\t\t\t\t\tthis._y = y;\n\t\t\t\t\t\t\t\t\tthis._z = z;\n\t\t\t\t\t\t\t\t\tthis._w = w;\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor(this._x, this._y, this._z, this._w);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(quaternion) {\n\n\t\t\t\t\t\t\t\t\tthis._x = quaternion.x;\n\t\t\t\t\t\t\t\t\tthis._y = quaternion.y;\n\t\t\t\t\t\t\t\t\tthis._z = quaternion.z;\n\t\t\t\t\t\t\t\t\tthis._w = quaternion.w;\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromEuler: function setFromEuler(euler, update) {\n\n\t\t\t\t\t\t\t\t\tif (!(euler && euler.isEuler)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar x = euler._x,\n\t\t\t\t\t\t\t\t\t    y = euler._y,\n\t\t\t\t\t\t\t\t\t    z = euler._z,\n\t\t\t\t\t\t\t\t\t    order = euler.order;\n\n\t\t\t\t\t\t\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t\t\t\t\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t\t\t\t\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\t\t\t\t\t\t\tvar cos = Math.cos;\n\t\t\t\t\t\t\t\t\tvar sin = Math.sin;\n\n\t\t\t\t\t\t\t\t\tvar c1 = cos(x / 2);\n\t\t\t\t\t\t\t\t\tvar c2 = cos(y / 2);\n\t\t\t\t\t\t\t\t\tvar c3 = cos(z / 2);\n\n\t\t\t\t\t\t\t\t\tvar s1 = sin(x / 2);\n\t\t\t\t\t\t\t\t\tvar s2 = sin(y / 2);\n\t\t\t\t\t\t\t\t\tvar s3 = sin(z / 2);\n\n\t\t\t\t\t\t\t\t\tif (order === 'XYZ') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t} else if (order === 'YXZ') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t} else if (order === 'ZXY') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t} else if (order === 'ZYX') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t} else if (order === 'YZX') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t} else if (order === 'XZY') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (update !== false) this.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromAxisAngle: function setFromAxisAngle(axis, angle) {\n\n\t\t\t\t\t\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t\t\t\t\t\t\t\t// assumes axis is normalized\n\n\t\t\t\t\t\t\t\t\tvar halfAngle = angle / 2,\n\t\t\t\t\t\t\t\t\t    s = Math.sin(halfAngle);\n\n\t\t\t\t\t\t\t\t\tthis._x = axis.x * s;\n\t\t\t\t\t\t\t\t\tthis._y = axis.y * s;\n\t\t\t\t\t\t\t\t\tthis._z = axis.z * s;\n\t\t\t\t\t\t\t\t\tthis._w = Math.cos(halfAngle);\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromRotationMatrix: function setFromRotationMatrix(m) {\n\n\t\t\t\t\t\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t\t\t\t\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\t\t\t\t\t\t\tvar te = m.elements,\n\t\t\t\t\t\t\t\t\t    m11 = te[0],\n\t\t\t\t\t\t\t\t\t    m12 = te[4],\n\t\t\t\t\t\t\t\t\t    m13 = te[8],\n\t\t\t\t\t\t\t\t\t    m21 = te[1],\n\t\t\t\t\t\t\t\t\t    m22 = te[5],\n\t\t\t\t\t\t\t\t\t    m23 = te[9],\n\t\t\t\t\t\t\t\t\t    m31 = te[2],\n\t\t\t\t\t\t\t\t\t    m32 = te[6],\n\t\t\t\t\t\t\t\t\t    m33 = te[10],\n\t\t\t\t\t\t\t\t\t    trace = m11 + m22 + m33,\n\t\t\t\t\t\t\t\t\t    s;\n\n\t\t\t\t\t\t\t\t\tif (trace > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ts = 0.5 / Math.sqrt(trace + 1.0);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = (m32 - m23) * s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = (m13 - m31) * s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = (m21 - m12) * s;\n\t\t\t\t\t\t\t\t\t} else if (m11 > m22 && m11 > m33) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ts = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = (m32 - m23) / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = (m12 + m21) / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = (m13 + m31) / s;\n\t\t\t\t\t\t\t\t\t} else if (m22 > m33) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ts = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = (m13 - m31) / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = (m12 + m21) / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = (m23 + m32) / s;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\ts = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = (m21 - m12) / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = (m13 + m31) / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = (m23 + m32) / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = 0.25 * s;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromUnitVectors: function () {\n\n\t\t\t\t\t\t\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\t\t\t\t\t\t\t\t\tvar r;\n\n\t\t\t\t\t\t\t\t\tvar EPS = 0.000001;\n\n\t\t\t\t\t\t\t\t\treturn function setFromUnitVectors(vFrom, vTo) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (v1 === undefined) v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\t\t\t\tr = vFrom.dot(vTo) + 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (r < EPS) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tr = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.set(-vFrom.y, vFrom.x, 0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.set(0, -vFrom.z, vFrom.y);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.crossVectors(vFrom, vTo);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = v1.x;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = v1.y;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = v1.z;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = r;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.normalize();\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tangleTo: function angleTo(q) {\n\n\t\t\t\t\t\t\t\t\treturn 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\trotateTowards: function rotateTowards(q, step) {\n\n\t\t\t\t\t\t\t\t\tvar angle = this.angleTo(q);\n\n\t\t\t\t\t\t\t\t\tif (angle === 0) return this;\n\n\t\t\t\t\t\t\t\t\tvar t = Math.min(1, step / angle);\n\n\t\t\t\t\t\t\t\t\tthis.slerp(q, t);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tinverse: function inverse() {\n\n\t\t\t\t\t\t\t\t\t// quaternion is assumed to have unit length\n\n\t\t\t\t\t\t\t\t\treturn this.conjugate();\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tconjugate: function conjugate() {\n\n\t\t\t\t\t\t\t\t\tthis._x *= -1;\n\t\t\t\t\t\t\t\t\tthis._y *= -1;\n\t\t\t\t\t\t\t\t\tthis._z *= -1;\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdot: function dot(v) {\n\n\t\t\t\t\t\t\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlengthSq: function lengthSq() {\n\n\t\t\t\t\t\t\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlength: function length() {\n\n\t\t\t\t\t\t\t\t\treturn Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnormalize: function normalize() {\n\n\t\t\t\t\t\t\t\t\tvar l = this.length();\n\n\t\t\t\t\t\t\t\t\tif (l === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = 1;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tl = 1 / l;\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = this._x * l;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = this._y * l;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = this._z * l;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = this._w * l;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiply: function multiply(q, p) {\n\n\t\t\t\t\t\t\t\t\tif (p !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.multiplyQuaternions(q, p);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyQuaternions(this, q);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tpremultiply: function premultiply(q) {\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyQuaternions(q, this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyQuaternions: function multiplyQuaternions(a, b) {\n\n\t\t\t\t\t\t\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\t\t\t\t\t\t\t\tvar qax = a._x,\n\t\t\t\t\t\t\t\t\t    qay = a._y,\n\t\t\t\t\t\t\t\t\t    qaz = a._z,\n\t\t\t\t\t\t\t\t\t    qaw = a._w;\n\t\t\t\t\t\t\t\t\tvar qbx = b._x,\n\t\t\t\t\t\t\t\t\t    qby = b._y,\n\t\t\t\t\t\t\t\t\t    qbz = b._z,\n\t\t\t\t\t\t\t\t\t    qbw = b._w;\n\n\t\t\t\t\t\t\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\t\t\t\t\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\t\t\t\t\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\t\t\t\t\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tslerp: function slerp(qb, t) {\n\n\t\t\t\t\t\t\t\t\tif (t === 0) return this;\n\t\t\t\t\t\t\t\t\tif (t === 1) return this.copy(qb);\n\n\t\t\t\t\t\t\t\t\tvar x = this._x,\n\t\t\t\t\t\t\t\t\t    y = this._y,\n\t\t\t\t\t\t\t\t\t    z = this._z,\n\t\t\t\t\t\t\t\t\t    w = this._w;\n\n\t\t\t\t\t\t\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\t\t\t\t\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\t\t\t\t\t\t\tif (cosHalfTheta < 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = -qb._w;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = -qb._x;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = -qb._y;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = -qb._z;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcosHalfTheta = -cosHalfTheta;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.copy(qb);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (cosHalfTheta >= 1.0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = w;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = x;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = y;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = z;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\t\t\t\t\t\t\t\tif (sqrSinHalfTheta <= Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar s = 1 - t;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._w = s * w + t * this._w;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = s * x + t * this._x;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = s * y + t * this._y;\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.normalize();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n\t\t\t\t\t\t\t\t\tvar halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n\t\t\t\t\t\t\t\t\tvar ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n\t\t\t\t\t\t\t\t\t    ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n\n\t\t\t\t\t\t\t\t\tthis._w = w * ratioA + this._w * ratioB;\n\t\t\t\t\t\t\t\t\tthis._x = x * ratioA + this._x * ratioB;\n\t\t\t\t\t\t\t\t\tthis._y = y * ratioA + this._y * ratioB;\n\t\t\t\t\t\t\t\t\tthis._z = z * ratioA + this._z * ratioB;\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tequals: function equals(quaternion) {\n\n\t\t\t\t\t\t\t\t\treturn quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromArray: function fromArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tthis._x = array[offset];\n\t\t\t\t\t\t\t\t\tthis._y = array[offset + 1];\n\t\t\t\t\t\t\t\t\tthis._z = array[offset + 2];\n\t\t\t\t\t\t\t\t\tthis._w = array[offset + 3];\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoArray: function toArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (array === undefined) array = [];\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tarray[offset] = this._x;\n\t\t\t\t\t\t\t\t\tarray[offset + 1] = this._y;\n\t\t\t\t\t\t\t\t\tarray[offset + 2] = this._z;\n\t\t\t\t\t\t\t\t\tarray[offset + 3] = this._w;\n\n\t\t\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tonChange: function onChange(callback) {\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback = callback;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tonChangeCallback: function onChangeCallback() {}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    * @author kile / http://kile.stravaganza.org/\r\n    * @author philogb / http://blog.thejit.org/\r\n    * @author mikael emtinger / http://gomo.se/\r\n    * @author egraether / http://egraether.com/\r\n    * @author WestLangley / http://github.com/WestLangley\r\n    */\n\n\t\t\tfunction Vector3(x, y, z) {\n\n\t\t\t\t\t\tthis.x = x || 0;\n\t\t\t\t\t\tthis.y = y || 0;\n\t\t\t\t\t\tthis.z = z || 0;\n\t\t\t}\n\n\t\t\tObject.assign(Vector3.prototype, {\n\n\t\t\t\t\t\tisVector3: true,\n\n\t\t\t\t\t\tset: function set(x, y, z) {\n\n\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\tthis.z = z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetScalar: function setScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\tthis.x = scalar;\n\t\t\t\t\t\t\t\t\tthis.y = scalar;\n\t\t\t\t\t\t\t\t\tthis.z = scalar;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetX: function setX(x) {\n\n\t\t\t\t\t\t\t\t\tthis.x = x;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetY: function setY(y) {\n\n\t\t\t\t\t\t\t\t\tthis.y = y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetZ: function setZ(z) {\n\n\t\t\t\t\t\t\t\t\tthis.z = z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetComponent: function setComponent(index, value) {\n\n\t\t\t\t\t\t\t\t\tswitch (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.z = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetComponent: function getComponent(index) {\n\n\t\t\t\t\t\t\t\t\tswitch (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.x;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.y;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.z;\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor(this.x, this.y, this.z);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = v.x;\n\t\t\t\t\t\t\t\t\tthis.y = v.y;\n\t\t\t\t\t\t\t\t\tthis.z = v.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tadd: function add(v, w) {\n\n\t\t\t\t\t\t\t\t\tif (w !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.addVectors(v, w);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x += v.x;\n\t\t\t\t\t\t\t\t\tthis.y += v.y;\n\t\t\t\t\t\t\t\t\tthis.z += v.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddScalar: function addScalar(s) {\n\n\t\t\t\t\t\t\t\t\tthis.x += s;\n\t\t\t\t\t\t\t\t\tthis.y += s;\n\t\t\t\t\t\t\t\t\tthis.z += s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddVectors: function addVectors(a, b) {\n\n\t\t\t\t\t\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\t\t\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\t\t\t\t\t\tthis.z = a.z + b.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddScaledVector: function addScaledVector(v, s) {\n\n\t\t\t\t\t\t\t\t\tthis.x += v.x * s;\n\t\t\t\t\t\t\t\t\tthis.y += v.y * s;\n\t\t\t\t\t\t\t\t\tthis.z += v.z * s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsub: function sub(v, w) {\n\n\t\t\t\t\t\t\t\t\tif (w !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.subVectors(v, w);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x -= v.x;\n\t\t\t\t\t\t\t\t\tthis.y -= v.y;\n\t\t\t\t\t\t\t\t\tthis.z -= v.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsubScalar: function subScalar(s) {\n\n\t\t\t\t\t\t\t\t\tthis.x -= s;\n\t\t\t\t\t\t\t\t\tthis.y -= s;\n\t\t\t\t\t\t\t\t\tthis.z -= s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsubVectors: function subVectors(a, b) {\n\n\t\t\t\t\t\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\t\t\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\t\t\t\t\t\tthis.z = a.z - b.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiply: function multiply(v, w) {\n\n\t\t\t\t\t\t\t\t\tif (w !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.multiplyVectors(v, w);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x *= v.x;\n\t\t\t\t\t\t\t\t\tthis.y *= v.y;\n\t\t\t\t\t\t\t\t\tthis.z *= v.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyScalar: function multiplyScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\t\t\t\t\tthis.y *= scalar;\n\t\t\t\t\t\t\t\t\tthis.z *= scalar;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyVectors: function multiplyVectors(a, b) {\n\n\t\t\t\t\t\t\t\t\tthis.x = a.x * b.x;\n\t\t\t\t\t\t\t\t\tthis.y = a.y * b.y;\n\t\t\t\t\t\t\t\t\tthis.z = a.z * b.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyEuler: function () {\n\n\t\t\t\t\t\t\t\t\tvar quaternion = new Quaternion();\n\n\t\t\t\t\t\t\t\t\treturn function applyEuler(euler) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!(euler && euler.isEuler)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.applyQuaternion(quaternion.setFromEuler(euler));\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tapplyAxisAngle: function () {\n\n\t\t\t\t\t\t\t\t\tvar quaternion = new Quaternion();\n\n\t\t\t\t\t\t\t\t\treturn function applyAxisAngle(axis, angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tapplyMatrix3: function applyMatrix3(m) {\n\n\t\t\t\t\t\t\t\t\tvar x = this.x,\n\t\t\t\t\t\t\t\t\t    y = this.y,\n\t\t\t\t\t\t\t\t\t    z = this.z;\n\t\t\t\t\t\t\t\t\tvar e = m.elements;\n\n\t\t\t\t\t\t\t\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\n\t\t\t\t\t\t\t\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\n\t\t\t\t\t\t\t\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyMatrix4: function applyMatrix4(m) {\n\n\t\t\t\t\t\t\t\t\tvar x = this.x,\n\t\t\t\t\t\t\t\t\t    y = this.y,\n\t\t\t\t\t\t\t\t\t    z = this.z;\n\t\t\t\t\t\t\t\t\tvar e = m.elements;\n\n\t\t\t\t\t\t\t\t\tvar w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n\n\t\t\t\t\t\t\t\t\tthis.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n\t\t\t\t\t\t\t\t\tthis.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n\t\t\t\t\t\t\t\t\tthis.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyQuaternion: function applyQuaternion(q) {\n\n\t\t\t\t\t\t\t\t\tvar x = this.x,\n\t\t\t\t\t\t\t\t\t    y = this.y,\n\t\t\t\t\t\t\t\t\t    z = this.z;\n\t\t\t\t\t\t\t\t\tvar qx = q.x,\n\t\t\t\t\t\t\t\t\t    qy = q.y,\n\t\t\t\t\t\t\t\t\t    qz = q.z,\n\t\t\t\t\t\t\t\t\t    qw = q.w;\n\n\t\t\t\t\t\t\t\t\t// calculate quat * vector\n\n\t\t\t\t\t\t\t\t\tvar ix = qw * x + qy * z - qz * y;\n\t\t\t\t\t\t\t\t\tvar iy = qw * y + qz * x - qx * z;\n\t\t\t\t\t\t\t\t\tvar iz = qw * z + qx * y - qy * x;\n\t\t\t\t\t\t\t\t\tvar iw = -qx * x - qy * y - qz * z;\n\n\t\t\t\t\t\t\t\t\t// calculate result * inverse quat\n\n\t\t\t\t\t\t\t\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\t\t\t\t\t\t\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\t\t\t\t\t\t\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tproject: function project(camera) {\n\n\t\t\t\t\t\t\t\t\treturn this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tunproject: function () {\n\n\t\t\t\t\t\t\t\t\tvar matrix = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function unproject(camera) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.applyMatrix4(matrix.getInverse(camera.projectionMatrix)).applyMatrix4(camera.matrixWorld);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttransformDirection: function transformDirection(m) {\n\n\t\t\t\t\t\t\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t\t\t\t\t\t\t// vector interpreted as a direction\n\n\t\t\t\t\t\t\t\t\tvar x = this.x,\n\t\t\t\t\t\t\t\t\t    y = this.y,\n\t\t\t\t\t\t\t\t\t    z = this.z;\n\t\t\t\t\t\t\t\t\tvar e = m.elements;\n\n\t\t\t\t\t\t\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z;\n\t\t\t\t\t\t\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z;\n\t\t\t\t\t\t\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\n\n\t\t\t\t\t\t\t\t\treturn this.normalize();\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdivide: function divide(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x /= v.x;\n\t\t\t\t\t\t\t\t\tthis.y /= v.y;\n\t\t\t\t\t\t\t\t\tthis.z /= v.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdivideScalar: function divideScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmin: function min(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.min(this.z, v.z);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmax: function max(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.max(this.z, v.z);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclamp: function clamp(min, max) {\n\n\t\t\t\t\t\t\t\t\t// assumes min < max, componentwise\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\t\t\t\t\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\t\t\t\t\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclampScalar: function () {\n\n\t\t\t\t\t\t\t\t\tvar min = new Vector3();\n\t\t\t\t\t\t\t\t\tvar max = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function clampScalar(minVal, maxVal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin.set(minVal, minVal, minVal);\n\t\t\t\t\t\t\t\t\t\t\t\tmax.set(maxVal, maxVal, maxVal);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.clamp(min, max);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tclampLength: function clampLength(min, max) {\n\n\t\t\t\t\t\t\t\t\tvar length = this.length();\n\n\t\t\t\t\t\t\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfloor: function floor() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.floor(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.floor(this.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.floor(this.z);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tceil: function ceil() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.ceil(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.ceil(this.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.ceil(this.z);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tround: function round() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.round(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.round(this.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.round(this.z);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\troundToZero: function roundToZero() {\n\n\t\t\t\t\t\t\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\t\t\t\t\t\t\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnegate: function negate() {\n\n\t\t\t\t\t\t\t\t\tthis.x = -this.x;\n\t\t\t\t\t\t\t\t\tthis.y = -this.y;\n\t\t\t\t\t\t\t\t\tthis.z = -this.z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdot: function dot(v) {\n\n\t\t\t\t\t\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// TODO lengthSquared?\n\n\t\t\t\t\t\tlengthSq: function lengthSq() {\n\n\t\t\t\t\t\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlength: function length() {\n\n\t\t\t\t\t\t\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmanhattanLength: function manhattanLength() {\n\n\t\t\t\t\t\t\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnormalize: function normalize() {\n\n\t\t\t\t\t\t\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetLength: function setLength(length) {\n\n\t\t\t\t\t\t\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlerp: function lerp(v, alpha) {\n\n\t\t\t\t\t\t\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\t\t\t\t\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\t\t\t\t\t\t\tthis.z += (v.z - this.z) * alpha;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlerpVectors: function lerpVectors(v1, v2, alpha) {\n\n\t\t\t\t\t\t\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcross: function cross(v, w) {\n\n\t\t\t\t\t\t\t\t\tif (w !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.crossVectors(v, w);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this.crossVectors(this, v);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcrossVectors: function crossVectors(a, b) {\n\n\t\t\t\t\t\t\t\t\tvar ax = a.x,\n\t\t\t\t\t\t\t\t\t    ay = a.y,\n\t\t\t\t\t\t\t\t\t    az = a.z;\n\t\t\t\t\t\t\t\t\tvar bx = b.x,\n\t\t\t\t\t\t\t\t\t    by = b.y,\n\t\t\t\t\t\t\t\t\t    bz = b.z;\n\n\t\t\t\t\t\t\t\t\tthis.x = ay * bz - az * by;\n\t\t\t\t\t\t\t\t\tthis.y = az * bx - ax * bz;\n\t\t\t\t\t\t\t\t\tthis.z = ax * by - ay * bx;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tprojectOnVector: function projectOnVector(vector) {\n\n\t\t\t\t\t\t\t\t\tvar scalar = vector.dot(this) / vector.lengthSq();\n\n\t\t\t\t\t\t\t\t\treturn this.copy(vector).multiplyScalar(scalar);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tprojectOnPlane: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function projectOnPlane(planeNormal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tv1.copy(this).projectOnVector(planeNormal);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.sub(v1);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\treflect: function () {\n\n\t\t\t\t\t\t\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t\t\t\t\t\t\t// normal is assumed to have unit length\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function reflect(normal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tangleTo: function angleTo(v) {\n\n\t\t\t\t\t\t\t\t\tvar theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());\n\n\t\t\t\t\t\t\t\t\t// clamp, to handle numerical problems\n\n\t\t\t\t\t\t\t\t\treturn Math.acos(_Math.clamp(theta, -1, 1));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdistanceTo: function distanceTo(v) {\n\n\t\t\t\t\t\t\t\t\treturn Math.sqrt(this.distanceToSquared(v));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdistanceToSquared: function distanceToSquared(v) {\n\n\t\t\t\t\t\t\t\t\tvar dx = this.x - v.x,\n\t\t\t\t\t\t\t\t\t    dy = this.y - v.y,\n\t\t\t\t\t\t\t\t\t    dz = this.z - v.z;\n\n\t\t\t\t\t\t\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmanhattanDistanceTo: function manhattanDistanceTo(v) {\n\n\t\t\t\t\t\t\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromSpherical: function setFromSpherical(s) {\n\n\t\t\t\t\t\t\t\t\treturn this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromSphericalCoords: function setFromSphericalCoords(radius, phi, theta) {\n\n\t\t\t\t\t\t\t\t\tvar sinPhiRadius = Math.sin(phi) * radius;\n\n\t\t\t\t\t\t\t\t\tthis.x = sinPhiRadius * Math.sin(theta);\n\t\t\t\t\t\t\t\t\tthis.y = Math.cos(phi) * radius;\n\t\t\t\t\t\t\t\t\tthis.z = sinPhiRadius * Math.cos(theta);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromCylindrical: function setFromCylindrical(c) {\n\n\t\t\t\t\t\t\t\t\treturn this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromCylindricalCoords: function setFromCylindricalCoords(radius, theta, y) {\n\n\t\t\t\t\t\t\t\t\tthis.x = radius * Math.sin(theta);\n\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\tthis.z = radius * Math.cos(theta);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromMatrixPosition: function setFromMatrixPosition(m) {\n\n\t\t\t\t\t\t\t\t\tvar e = m.elements;\n\n\t\t\t\t\t\t\t\t\tthis.x = e[12];\n\t\t\t\t\t\t\t\t\tthis.y = e[13];\n\t\t\t\t\t\t\t\t\tthis.z = e[14];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromMatrixScale: function setFromMatrixScale(m) {\n\n\t\t\t\t\t\t\t\t\tvar sx = this.setFromMatrixColumn(m, 0).length();\n\t\t\t\t\t\t\t\t\tvar sy = this.setFromMatrixColumn(m, 1).length();\n\t\t\t\t\t\t\t\t\tvar sz = this.setFromMatrixColumn(m, 2).length();\n\n\t\t\t\t\t\t\t\t\tthis.x = sx;\n\t\t\t\t\t\t\t\t\tthis.y = sy;\n\t\t\t\t\t\t\t\t\tthis.z = sz;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromMatrixColumn: function setFromMatrixColumn(m, index) {\n\n\t\t\t\t\t\t\t\t\treturn this.fromArray(m.elements, index * 4);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tequals: function equals(v) {\n\n\t\t\t\t\t\t\t\t\treturn v.x === this.x && v.y === this.y && v.z === this.z;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromArray: function fromArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tthis.x = array[offset];\n\t\t\t\t\t\t\t\t\tthis.y = array[offset + 1];\n\t\t\t\t\t\t\t\t\tthis.z = array[offset + 2];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoArray: function toArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (array === undefined) array = [];\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tarray[offset] = this.x;\n\t\t\t\t\t\t\t\t\tarray[offset + 1] = this.y;\n\t\t\t\t\t\t\t\t\tarray[offset + 2] = this.z;\n\n\t\t\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x = attribute.getX(index);\n\t\t\t\t\t\t\t\t\tthis.y = attribute.getY(index);\n\t\t\t\t\t\t\t\t\tthis.z = attribute.getZ(index);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    * @author alteredq / http://alteredqualia.com/\r\n    */\n\n\t\t\tfunction Face3(a, b, c, normal, color, materialIndex) {\n\n\t\t\t\t\t\tthis.a = a;\n\t\t\t\t\t\tthis.b = b;\n\t\t\t\t\t\tthis.c = c;\n\n\t\t\t\t\t\tthis.normal = normal && normal.isVector3 ? normal : new Vector3();\n\t\t\t\t\t\tthis.vertexNormals = Array.isArray(normal) ? normal : [];\n\n\t\t\t\t\t\tthis.color = color && color.isColor ? color : new Color();\n\t\t\t\t\t\tthis.vertexColors = Array.isArray(color) ? color : [];\n\n\t\t\t\t\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\t\t\t}\n\n\t\t\tObject.assign(Face3.prototype, {\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor().copy(this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source) {\n\n\t\t\t\t\t\t\t\t\tthis.a = source.a;\n\t\t\t\t\t\t\t\t\tthis.b = source.b;\n\t\t\t\t\t\t\t\t\tthis.c = source.c;\n\n\t\t\t\t\t\t\t\t\tthis.normal.copy(source.normal);\n\t\t\t\t\t\t\t\t\tthis.color.copy(source.color);\n\n\t\t\t\t\t\t\t\t\tthis.materialIndex = source.materialIndex;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vertexNormals[i] = source.vertexNormals[i].clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, il = source.vertexColors.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vertexColors[i] = source.vertexColors[i].clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author alteredq / http://alteredqualia.com/\r\n    * @author WestLangley / http://github.com/WestLangley\r\n    * @author bhouston / http://clara.io\r\n    * @author tschw\r\n    */\n\n\t\t\tfunction Matrix3() {\n\n\t\t\t\t\t\tthis.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n\t\t\t\t\t\tif (arguments.length > 0) {\n\n\t\t\t\t\t\t\t\t\tconsole.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tObject.assign(Matrix3.prototype, {\n\n\t\t\t\t\t\tisMatrix3: true,\n\n\t\t\t\t\t\tset: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tte[0] = n11;te[1] = n21;te[2] = n31;\n\t\t\t\t\t\t\t\t\tte[3] = n12;te[4] = n22;te[5] = n32;\n\t\t\t\t\t\t\t\t\tte[6] = n13;te[7] = n23;te[8] = n33;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tidentity: function identity() {\n\n\t\t\t\t\t\t\t\t\tthis.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor().fromArray(this.elements);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(m) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\tvar me = m.elements;\n\n\t\t\t\t\t\t\t\t\tte[0] = me[0];te[1] = me[1];te[2] = me[2];\n\t\t\t\t\t\t\t\t\tte[3] = me[3];te[4] = me[4];te[5] = me[5];\n\t\t\t\t\t\t\t\t\tte[6] = me[6];te[7] = me[7];te[8] = me[8];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromMatrix4: function setFromMatrix4(m) {\n\n\t\t\t\t\t\t\t\t\tvar me = m.elements;\n\n\t\t\t\t\t\t\t\t\tthis.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyToBufferAttribute: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function applyToBufferAttribute(attribute) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = attribute.count; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.x = attribute.getX(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.y = attribute.getY(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.z = attribute.getZ(i);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.applyMatrix3(this);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.setXYZ(i, v1.x, v1.y, v1.z);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn attribute;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tmultiply: function multiply(m) {\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyMatrices(this, m);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tpremultiply: function premultiply(m) {\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyMatrices(m, this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyMatrices: function multiplyMatrices(a, b) {\n\n\t\t\t\t\t\t\t\t\tvar ae = a.elements;\n\t\t\t\t\t\t\t\t\tvar be = b.elements;\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tvar a11 = ae[0],\n\t\t\t\t\t\t\t\t\t    a12 = ae[3],\n\t\t\t\t\t\t\t\t\t    a13 = ae[6];\n\t\t\t\t\t\t\t\t\tvar a21 = ae[1],\n\t\t\t\t\t\t\t\t\t    a22 = ae[4],\n\t\t\t\t\t\t\t\t\t    a23 = ae[7];\n\t\t\t\t\t\t\t\t\tvar a31 = ae[2],\n\t\t\t\t\t\t\t\t\t    a32 = ae[5],\n\t\t\t\t\t\t\t\t\t    a33 = ae[8];\n\n\t\t\t\t\t\t\t\t\tvar b11 = be[0],\n\t\t\t\t\t\t\t\t\t    b12 = be[3],\n\t\t\t\t\t\t\t\t\t    b13 = be[6];\n\t\t\t\t\t\t\t\t\tvar b21 = be[1],\n\t\t\t\t\t\t\t\t\t    b22 = be[4],\n\t\t\t\t\t\t\t\t\t    b23 = be[7];\n\t\t\t\t\t\t\t\t\tvar b31 = be[2],\n\t\t\t\t\t\t\t\t\t    b32 = be[5],\n\t\t\t\t\t\t\t\t\t    b33 = be[8];\n\n\t\t\t\t\t\t\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\t\t\t\t\t\t\t\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\t\t\t\t\t\t\t\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\t\t\t\t\t\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\t\t\t\t\t\t\t\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\t\t\t\t\t\t\t\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\t\t\t\t\t\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\t\t\t\t\t\t\t\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\t\t\t\t\t\t\t\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyScalar: function multiplyScalar(s) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tte[0] *= s;te[3] *= s;te[6] *= s;\n\t\t\t\t\t\t\t\t\tte[1] *= s;te[4] *= s;te[7] *= s;\n\t\t\t\t\t\t\t\t\tte[2] *= s;te[5] *= s;te[8] *= s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdeterminant: function determinant() {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tvar a = te[0],\n\t\t\t\t\t\t\t\t\t    b = te[1],\n\t\t\t\t\t\t\t\t\t    c = te[2],\n\t\t\t\t\t\t\t\t\t    d = te[3],\n\t\t\t\t\t\t\t\t\t    e = te[4],\n\t\t\t\t\t\t\t\t\t    f = te[5],\n\t\t\t\t\t\t\t\t\t    g = te[6],\n\t\t\t\t\t\t\t\t\t    h = te[7],\n\t\t\t\t\t\t\t\t\t    i = te[8];\n\n\t\t\t\t\t\t\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetInverse: function getInverse(matrix, throwOnDegenerate) {\n\n\t\t\t\t\t\t\t\t\tif (matrix && matrix.isMatrix4) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error(\"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\");\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar me = matrix.elements,\n\t\t\t\t\t\t\t\t\t    te = this.elements,\n\t\t\t\t\t\t\t\t\t    n11 = me[0],\n\t\t\t\t\t\t\t\t\t    n21 = me[1],\n\t\t\t\t\t\t\t\t\t    n31 = me[2],\n\t\t\t\t\t\t\t\t\t    n12 = me[3],\n\t\t\t\t\t\t\t\t\t    n22 = me[4],\n\t\t\t\t\t\t\t\t\t    n32 = me[5],\n\t\t\t\t\t\t\t\t\t    n13 = me[6],\n\t\t\t\t\t\t\t\t\t    n23 = me[7],\n\t\t\t\t\t\t\t\t\t    n33 = me[8],\n\t\t\t\t\t\t\t\t\t    t11 = n33 * n22 - n32 * n23,\n\t\t\t\t\t\t\t\t\t    t12 = n32 * n13 - n33 * n12,\n\t\t\t\t\t\t\t\t\t    t13 = n23 * n12 - n22 * n13,\n\t\t\t\t\t\t\t\t\t    det = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\t\t\t\t\t\t\t\tif (det === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar msg = \"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\";\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (throwOnDegenerate === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn(msg);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.identity();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar detInv = 1 / det;\n\n\t\t\t\t\t\t\t\t\tte[0] = t11 * detInv;\n\t\t\t\t\t\t\t\t\tte[1] = (n31 * n23 - n33 * n21) * detInv;\n\t\t\t\t\t\t\t\t\tte[2] = (n32 * n21 - n31 * n22) * detInv;\n\n\t\t\t\t\t\t\t\t\tte[3] = t12 * detInv;\n\t\t\t\t\t\t\t\t\tte[4] = (n33 * n11 - n31 * n13) * detInv;\n\t\t\t\t\t\t\t\t\tte[5] = (n31 * n12 - n32 * n11) * detInv;\n\n\t\t\t\t\t\t\t\t\tte[6] = t13 * detInv;\n\t\t\t\t\t\t\t\t\tte[7] = (n21 * n13 - n23 * n11) * detInv;\n\t\t\t\t\t\t\t\t\tte[8] = (n22 * n11 - n21 * n12) * detInv;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttranspose: function transpose() {\n\n\t\t\t\t\t\t\t\t\tvar tmp,\n\t\t\t\t\t\t\t\t\t    m = this.elements;\n\n\t\t\t\t\t\t\t\t\ttmp = m[1];m[1] = m[3];m[3] = tmp;\n\t\t\t\t\t\t\t\t\ttmp = m[2];m[2] = m[6];m[6] = tmp;\n\t\t\t\t\t\t\t\t\ttmp = m[5];m[5] = m[7];m[7] = tmp;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetNormalMatrix: function getNormalMatrix(matrix4) {\n\n\t\t\t\t\t\t\t\t\treturn this.setFromMatrix4(matrix4).getInverse(this).transpose();\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttransposeIntoArray: function transposeIntoArray(r) {\n\n\t\t\t\t\t\t\t\t\tvar m = this.elements;\n\n\t\t\t\t\t\t\t\t\tr[0] = m[0];\n\t\t\t\t\t\t\t\t\tr[1] = m[3];\n\t\t\t\t\t\t\t\t\tr[2] = m[6];\n\t\t\t\t\t\t\t\t\tr[3] = m[1];\n\t\t\t\t\t\t\t\t\tr[4] = m[4];\n\t\t\t\t\t\t\t\t\tr[5] = m[7];\n\t\t\t\t\t\t\t\t\tr[6] = m[2];\n\t\t\t\t\t\t\t\t\tr[7] = m[5];\n\t\t\t\t\t\t\t\t\tr[8] = m[8];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetUvTransform: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n\n\t\t\t\t\t\t\t\t\tvar c = Math.cos(rotation);\n\t\t\t\t\t\t\t\t\tvar s = Math.sin(rotation);\n\n\t\t\t\t\t\t\t\t\tthis.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tscale: function scale(sx, sy) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tte[0] *= sx;te[3] *= sx;te[6] *= sx;\n\t\t\t\t\t\t\t\t\tte[1] *= sy;te[4] *= sy;te[7] *= sy;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\trotate: function rotate(theta) {\n\n\t\t\t\t\t\t\t\t\tvar c = Math.cos(theta);\n\t\t\t\t\t\t\t\t\tvar s = Math.sin(theta);\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tvar a11 = te[0],\n\t\t\t\t\t\t\t\t\t    a12 = te[3],\n\t\t\t\t\t\t\t\t\t    a13 = te[6];\n\t\t\t\t\t\t\t\t\tvar a21 = te[1],\n\t\t\t\t\t\t\t\t\t    a22 = te[4],\n\t\t\t\t\t\t\t\t\t    a23 = te[7];\n\n\t\t\t\t\t\t\t\t\tte[0] = c * a11 + s * a21;\n\t\t\t\t\t\t\t\t\tte[3] = c * a12 + s * a22;\n\t\t\t\t\t\t\t\t\tte[6] = c * a13 + s * a23;\n\n\t\t\t\t\t\t\t\t\tte[1] = -s * a11 + c * a21;\n\t\t\t\t\t\t\t\t\tte[4] = -s * a12 + c * a22;\n\t\t\t\t\t\t\t\t\tte[7] = -s * a13 + c * a23;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttranslate: function translate(tx, ty) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tte[0] += tx * te[2];te[3] += tx * te[5];te[6] += tx * te[8];\n\t\t\t\t\t\t\t\t\tte[1] += ty * te[2];te[4] += ty * te[5];te[7] += ty * te[8];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tequals: function equals(matrix) {\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\t\t\t\t\t\t\t\t\tvar me = matrix.elements;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < 9; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (te[i] !== me[i]) return false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromArray: function fromArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < 9; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.elements[i] = array[i + offset];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoArray: function toArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (array === undefined) array = [];\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tvar te = this.elements;\n\n\t\t\t\t\t\t\t\t\tarray[offset] = te[0];\n\t\t\t\t\t\t\t\t\tarray[offset + 1] = te[1];\n\t\t\t\t\t\t\t\t\tarray[offset + 2] = te[2];\n\n\t\t\t\t\t\t\t\t\tarray[offset + 3] = te[3];\n\t\t\t\t\t\t\t\t\tarray[offset + 4] = te[4];\n\t\t\t\t\t\t\t\t\tarray[offset + 5] = te[5];\n\n\t\t\t\t\t\t\t\t\tarray[offset + 6] = te[6];\n\t\t\t\t\t\t\t\t\tarray[offset + 7] = te[7];\n\t\t\t\t\t\t\t\t\tarray[offset + 8] = te[8];\n\n\t\t\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author bhouston / http://clara.io\r\n    * @author WestLangley / http://github.com/WestLangley\r\n    */\n\n\t\t\tfunction Box3(min, max) {\n\n\t\t\t\t\t\tthis.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);\n\t\t\t\t\t\tthis.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);\n\t\t\t}\n\n\t\t\tObject.assign(Box3.prototype, {\n\n\t\t\t\t\t\tisBox3: true,\n\n\t\t\t\t\t\tset: function set(min, max) {\n\n\t\t\t\t\t\t\t\t\tthis.min.copy(min);\n\t\t\t\t\t\t\t\t\tthis.max.copy(max);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromArray: function setFromArray(array) {\n\n\t\t\t\t\t\t\t\t\tvar minX = +Infinity;\n\t\t\t\t\t\t\t\t\tvar minY = +Infinity;\n\t\t\t\t\t\t\t\t\tvar minZ = +Infinity;\n\n\t\t\t\t\t\t\t\t\tvar maxX = -Infinity;\n\t\t\t\t\t\t\t\t\tvar maxY = -Infinity;\n\t\t\t\t\t\t\t\t\tvar maxZ = -Infinity;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = array.length; i < l; i += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = array[i];\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = array[i + 1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar z = array[i + 2];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (x < minX) minX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tif (y < minY) minY = y;\n\t\t\t\t\t\t\t\t\t\t\t\tif (z < minZ) minZ = z;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\t\t\t\t\t\t\t\t\tif (z > maxZ) maxZ = z;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.min.set(minX, minY, minZ);\n\t\t\t\t\t\t\t\t\tthis.max.set(maxX, maxY, maxZ);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromBufferAttribute: function setFromBufferAttribute(attribute) {\n\n\t\t\t\t\t\t\t\t\tvar minX = +Infinity;\n\t\t\t\t\t\t\t\t\tvar minY = +Infinity;\n\t\t\t\t\t\t\t\t\tvar minZ = +Infinity;\n\n\t\t\t\t\t\t\t\t\tvar maxX = -Infinity;\n\t\t\t\t\t\t\t\t\tvar maxY = -Infinity;\n\t\t\t\t\t\t\t\t\tvar maxZ = -Infinity;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = attribute.count; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = attribute.getX(i);\n\t\t\t\t\t\t\t\t\t\t\t\tvar y = attribute.getY(i);\n\t\t\t\t\t\t\t\t\t\t\t\tvar z = attribute.getZ(i);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (x < minX) minX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tif (y < minY) minY = y;\n\t\t\t\t\t\t\t\t\t\t\t\tif (z < minZ) minZ = z;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\t\t\t\t\t\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\t\t\t\t\t\t\t\t\tif (z > maxZ) maxZ = z;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.min.set(minX, minY, minZ);\n\t\t\t\t\t\t\t\t\tthis.max.set(maxX, maxY, maxZ);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromPoints: function setFromPoints(points) {\n\n\t\t\t\t\t\t\t\t\tthis.makeEmpty();\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, il = points.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.expandByPoint(points[i]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromCenterAndSize: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function setFromCenterAndSize(center, size) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar halfSize = v1.copy(size).multiplyScalar(0.5);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.min.copy(center).sub(halfSize);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.max.copy(center).add(halfSize);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tsetFromObject: function setFromObject(object) {\n\n\t\t\t\t\t\t\t\t\tthis.makeEmpty();\n\n\t\t\t\t\t\t\t\t\treturn this.expandByObject(object);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor().copy(this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(box) {\n\n\t\t\t\t\t\t\t\t\tthis.min.copy(box.min);\n\t\t\t\t\t\t\t\t\tthis.max.copy(box.max);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmakeEmpty: function makeEmpty() {\n\n\t\t\t\t\t\t\t\t\tthis.min.x = this.min.y = this.min.z = +Infinity;\n\t\t\t\t\t\t\t\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tisEmpty: function isEmpty() {\n\n\t\t\t\t\t\t\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\t\t\t\t\t\t\t\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetCenter: function getCenter(target) {\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Box3: .getCenter() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetSize: function getSize(target) {\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Box3: .getSize() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\texpandByPoint: function expandByPoint(point) {\n\n\t\t\t\t\t\t\t\t\tthis.min.min(point);\n\t\t\t\t\t\t\t\t\tthis.max.max(point);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\texpandByVector: function expandByVector(vector) {\n\n\t\t\t\t\t\t\t\t\tthis.min.sub(vector);\n\t\t\t\t\t\t\t\t\tthis.max.add(vector);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\texpandByScalar: function expandByScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\tthis.min.addScalar(-scalar);\n\t\t\t\t\t\t\t\t\tthis.max.addScalar(scalar);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\texpandByObject: function () {\n\n\t\t\t\t\t\t\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t\t\t\t\t\t\t// accounting for both the object's, and children's, world transforms\n\n\t\t\t\t\t\t\t\t\tvar scope, i, l;\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\tfunction traverse(node) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometry !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.isGeometry) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, l = vertices.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.copy(vertices[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.applyMatrix4(node.matrixWorld);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscope.expandByPoint(v1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (geometry.isBufferGeometry) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (attribute !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, l = attribute.count; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscope.expandByPoint(v1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn function expandByObject(object) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tscope = this;\n\n\t\t\t\t\t\t\t\t\t\t\t\tobject.updateMatrixWorld(true);\n\n\t\t\t\t\t\t\t\t\t\t\t\tobject.traverse(traverse);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tcontainsPoint: function containsPoint(point) {\n\n\t\t\t\t\t\t\t\t\treturn point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcontainsBox: function containsBox(box) {\n\n\t\t\t\t\t\t\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetParameter: function getParameter(point, target) {\n\n\t\t\t\t\t\t\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t\t\t\t\t\t\t// has a size dimension of 0.\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Box3: .getParameter() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBox: function intersectsBox(box) {\n\n\t\t\t\t\t\t\t\t\t// using 6 splitting planes to rule out intersections.\n\t\t\t\t\t\t\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsSphere: function () {\n\n\t\t\t\t\t\t\t\t\tvar closestPoint = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function intersectsSphere(sphere) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\t\t\t\t\t\t\t\t\tthis.clampPoint(sphere.center, closestPoint);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\t\t\t\t\t\t\t\t\treturn closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tintersectsPlane: function intersectsPlane(plane) {\n\n\t\t\t\t\t\t\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t\t\t\t\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\t\t\t\t\t\t\t\tvar min, max;\n\n\t\t\t\t\t\t\t\t\tif (plane.normal.x > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\t\t\t\t\t\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\t\t\t\t\t\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (plane.normal.y > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\t\t\t\t\t\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\t\t\t\t\t\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (plane.normal.z > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\t\t\t\t\t\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\t\t\t\t\t\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn min <= -plane.constant && max >= -plane.constant;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsTriangle: function () {\n\n\t\t\t\t\t\t\t\t\t// triangle centered vertices\n\t\t\t\t\t\t\t\t\tvar v0 = new Vector3();\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\t\t\t\t\t\t\t\t\tvar v2 = new Vector3();\n\n\t\t\t\t\t\t\t\t\t// triangle edge vectors\n\t\t\t\t\t\t\t\t\tvar f0 = new Vector3();\n\t\t\t\t\t\t\t\t\tvar f1 = new Vector3();\n\t\t\t\t\t\t\t\t\tvar f2 = new Vector3();\n\n\t\t\t\t\t\t\t\t\tvar testAxis = new Vector3();\n\n\t\t\t\t\t\t\t\t\tvar center = new Vector3();\n\t\t\t\t\t\t\t\t\tvar extents = new Vector3();\n\n\t\t\t\t\t\t\t\t\tvar triangleNormal = new Vector3();\n\n\t\t\t\t\t\t\t\t\tfunction satForAxes(axes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar i, j;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, j = axes.length - 3; i <= j; i += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttestAxis.fromArray(axes, i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// project the aabb onto the seperating axis\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// project all 3 vertices of the triangle onto the seperating axis\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar p0 = v0.dot(testAxis);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar p1 = v1.dot(testAxis);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar p2 = v2.dot(testAxis);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the axis is seperating and we can exit\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn function intersectsTriangle(triangle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.isEmpty()) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// compute box center and extents\n\t\t\t\t\t\t\t\t\t\t\t\tthis.getCenter(center);\n\t\t\t\t\t\t\t\t\t\t\t\textents.subVectors(this.max, center);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// translate triangle to aabb origin\n\t\t\t\t\t\t\t\t\t\t\t\tv0.subVectors(triangle.a, center);\n\t\t\t\t\t\t\t\t\t\t\t\tv1.subVectors(triangle.b, center);\n\t\t\t\t\t\t\t\t\t\t\t\tv2.subVectors(triangle.c, center);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// compute edge vectors for triangle\n\t\t\t\t\t\t\t\t\t\t\t\tf0.subVectors(v1, v0);\n\t\t\t\t\t\t\t\t\t\t\t\tf1.subVectors(v2, v1);\n\t\t\t\t\t\t\t\t\t\t\t\tf2.subVectors(v0, v2);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t\t\t\t\t\t\t\t\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t\t\t\t\t\t\t\t\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\t\t\t\t\t\t\t\t\t\t\tvar axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];\n\t\t\t\t\t\t\t\t\t\t\t\tif (!satForAxes(axes)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// test 3 face normals from the aabb\n\t\t\t\t\t\t\t\t\t\t\t\taxes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\t\t\t\t\t\t\t\t\t\t\t\tif (!satForAxes(axes)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// finally testing the face normal of the triangle\n\t\t\t\t\t\t\t\t\t\t\t\t// use already existing triangle edge vectors here\n\t\t\t\t\t\t\t\t\t\t\t\ttriangleNormal.crossVectors(f0, f1);\n\t\t\t\t\t\t\t\t\t\t\t\taxes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];\n\t\t\t\t\t\t\t\t\t\t\t\treturn satForAxes(axes);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tclampPoint: function clampPoint(point, target) {\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Box3: .clampPoint() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn target.copy(point).clamp(this.min, this.max);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdistanceToPoint: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function distanceToPoint(point) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar clampedPoint = v1.copy(point).clamp(this.min, this.max);\n\t\t\t\t\t\t\t\t\t\t\t\treturn clampedPoint.sub(point).length();\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tgetBoundingSphere: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function getBoundingSphere(target) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Box3: .getBoundingSphere() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Sphere();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.getCenter(target.center);\n\n\t\t\t\t\t\t\t\t\t\t\t\ttarget.radius = this.getSize(v1).length() * 0.5;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tintersect: function intersect(box) {\n\n\t\t\t\t\t\t\t\t\tthis.min.max(box.min);\n\t\t\t\t\t\t\t\t\tthis.max.min(box.max);\n\n\t\t\t\t\t\t\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\t\t\t\t\t\t\tif (this.isEmpty()) this.makeEmpty();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tunion: function union(box) {\n\n\t\t\t\t\t\t\t\t\tthis.min.min(box.min);\n\t\t\t\t\t\t\t\t\tthis.max.max(box.max);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyMatrix4: function () {\n\n\t\t\t\t\t\t\t\t\tvar points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n\n\t\t\t\t\t\t\t\t\treturn function applyMatrix4(matrix) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.isEmpty()) return this;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\t\t\t\t\t\t\t\t\tpoints[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n\t\t\t\t\t\t\t\t\t\t\t\tpoints[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n\t\t\t\t\t\t\t\t\t\t\t\tpoints[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n\t\t\t\t\t\t\t\t\t\t\t\tpoints[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n\t\t\t\t\t\t\t\t\t\t\t\tpoints[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n\t\t\t\t\t\t\t\t\t\t\t\tpoints[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n\t\t\t\t\t\t\t\t\t\t\t\tpoints[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n\t\t\t\t\t\t\t\t\t\t\t\tpoints[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setFromPoints(points);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttranslate: function translate(offset) {\n\n\t\t\t\t\t\t\t\t\tthis.min.add(offset);\n\t\t\t\t\t\t\t\t\tthis.max.add(offset);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tequals: function equals(box) {\n\n\t\t\t\t\t\t\t\t\treturn box.min.equals(this.min) && box.max.equals(this.max);\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author bhouston / http://clara.io\r\n    * @author mrdoob / http://mrdoob.com/\r\n    */\n\n\t\t\tfunction Sphere(center, radius) {\n\n\t\t\t\t\t\tthis.center = center !== undefined ? center : new Vector3();\n\t\t\t\t\t\tthis.radius = radius !== undefined ? radius : 0;\n\t\t\t}\n\n\t\t\tObject.assign(Sphere.prototype, {\n\n\t\t\t\t\t\tset: function set(center, radius) {\n\n\t\t\t\t\t\t\t\t\tthis.center.copy(center);\n\t\t\t\t\t\t\t\t\tthis.radius = radius;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromPoints: function () {\n\n\t\t\t\t\t\t\t\t\tvar box = new Box3();\n\n\t\t\t\t\t\t\t\t\treturn function setFromPoints(points, optionalCenter) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar center = this.center;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (optionalCenter !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter.copy(optionalCenter);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbox.setFromPoints(points).getCenter(center);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, il = points.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.radius = Math.sqrt(maxRadiusSq);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor().copy(this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(sphere) {\n\n\t\t\t\t\t\t\t\t\tthis.center.copy(sphere.center);\n\t\t\t\t\t\t\t\t\tthis.radius = sphere.radius;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tempty: function empty() {\n\n\t\t\t\t\t\t\t\t\treturn this.radius <= 0;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcontainsPoint: function containsPoint(point) {\n\n\t\t\t\t\t\t\t\t\treturn point.distanceToSquared(this.center) <= this.radius * this.radius;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdistanceToPoint: function distanceToPoint(point) {\n\n\t\t\t\t\t\t\t\t\treturn point.distanceTo(this.center) - this.radius;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsSphere: function intersectsSphere(sphere) {\n\n\t\t\t\t\t\t\t\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\t\t\t\t\t\t\t\treturn sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBox: function intersectsBox(box) {\n\n\t\t\t\t\t\t\t\t\treturn box.intersectsSphere(this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsPlane: function intersectsPlane(plane) {\n\n\t\t\t\t\t\t\t\t\treturn Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclampPoint: function clampPoint(point, target) {\n\n\t\t\t\t\t\t\t\t\tvar deltaLengthSq = this.center.distanceToSquared(point);\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Sphere: .clampPoint() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttarget.copy(point);\n\n\t\t\t\t\t\t\t\t\tif (deltaLengthSq > this.radius * this.radius) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttarget.sub(this.center).normalize();\n\t\t\t\t\t\t\t\t\t\t\t\ttarget.multiplyScalar(this.radius).add(this.center);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetBoundingBox: function getBoundingBox(target) {\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Sphere: .getBoundingBox() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Box3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttarget.set(this.center, this.center);\n\t\t\t\t\t\t\t\t\ttarget.expandByScalar(this.radius);\n\n\t\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyMatrix4: function applyMatrix4(matrix) {\n\n\t\t\t\t\t\t\t\t\tthis.center.applyMatrix4(matrix);\n\t\t\t\t\t\t\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttranslate: function translate(offset) {\n\n\t\t\t\t\t\t\t\t\tthis.center.add(offset);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tequals: function equals(sphere) {\n\n\t\t\t\t\t\t\t\t\treturn sphere.center.equals(this.center) && sphere.radius === this.radius;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    * @author philogb / http://blog.thejit.org/\r\n    * @author egraether / http://egraether.com/\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    */\n\n\t\t\tfunction Vector2(x, y) {\n\n\t\t\t\t\t\tthis.x = x || 0;\n\t\t\t\t\t\tthis.y = y || 0;\n\t\t\t}\n\n\t\t\tObject.defineProperties(Vector2.prototype, {\n\n\t\t\t\t\t\t\"width\": {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.x;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.x = value;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\"height\": {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.y;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.y = value;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tObject.assign(Vector2.prototype, {\n\n\t\t\t\t\t\tisVector2: true,\n\n\t\t\t\t\t\tset: function set(x, y) {\n\n\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\tthis.y = y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetScalar: function setScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\tthis.x = scalar;\n\t\t\t\t\t\t\t\t\tthis.y = scalar;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetX: function setX(x) {\n\n\t\t\t\t\t\t\t\t\tthis.x = x;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetY: function setY(y) {\n\n\t\t\t\t\t\t\t\t\tthis.y = y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetComponent: function setComponent(index, value) {\n\n\t\t\t\t\t\t\t\t\tswitch (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetComponent: function getComponent(index) {\n\n\t\t\t\t\t\t\t\t\tswitch (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.x;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.y;\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor(this.x, this.y);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = v.x;\n\t\t\t\t\t\t\t\t\tthis.y = v.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tadd: function add(v, w) {\n\n\t\t\t\t\t\t\t\t\tif (w !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.addVectors(v, w);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x += v.x;\n\t\t\t\t\t\t\t\t\tthis.y += v.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddScalar: function addScalar(s) {\n\n\t\t\t\t\t\t\t\t\tthis.x += s;\n\t\t\t\t\t\t\t\t\tthis.y += s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddVectors: function addVectors(a, b) {\n\n\t\t\t\t\t\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\t\t\t\t\t\tthis.y = a.y + b.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddScaledVector: function addScaledVector(v, s) {\n\n\t\t\t\t\t\t\t\t\tthis.x += v.x * s;\n\t\t\t\t\t\t\t\t\tthis.y += v.y * s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsub: function sub(v, w) {\n\n\t\t\t\t\t\t\t\t\tif (w !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.subVectors(v, w);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x -= v.x;\n\t\t\t\t\t\t\t\t\tthis.y -= v.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsubScalar: function subScalar(s) {\n\n\t\t\t\t\t\t\t\t\tthis.x -= s;\n\t\t\t\t\t\t\t\t\tthis.y -= s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsubVectors: function subVectors(a, b) {\n\n\t\t\t\t\t\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\t\t\t\t\t\tthis.y = a.y - b.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiply: function multiply(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x *= v.x;\n\t\t\t\t\t\t\t\t\tthis.y *= v.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyScalar: function multiplyScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\t\t\t\t\tthis.y *= scalar;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdivide: function divide(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x /= v.x;\n\t\t\t\t\t\t\t\t\tthis.y /= v.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdivideScalar: function divideScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyMatrix3: function applyMatrix3(m) {\n\n\t\t\t\t\t\t\t\t\tvar x = this.x,\n\t\t\t\t\t\t\t\t\t    y = this.y;\n\t\t\t\t\t\t\t\t\tvar e = m.elements;\n\n\t\t\t\t\t\t\t\t\tthis.x = e[0] * x + e[3] * y + e[6];\n\t\t\t\t\t\t\t\t\tthis.y = e[1] * x + e[4] * y + e[7];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmin: function min(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.min(this.y, v.y);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmax: function max(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.max(this.y, v.y);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclamp: function clamp(min, max) {\n\n\t\t\t\t\t\t\t\t\t// assumes min < max, componentwise\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\t\t\t\t\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclampScalar: function () {\n\n\t\t\t\t\t\t\t\t\tvar min = new Vector2();\n\t\t\t\t\t\t\t\t\tvar max = new Vector2();\n\n\t\t\t\t\t\t\t\t\treturn function clampScalar(minVal, maxVal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin.set(minVal, minVal);\n\t\t\t\t\t\t\t\t\t\t\t\tmax.set(maxVal, maxVal);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.clamp(min, max);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tclampLength: function clampLength(min, max) {\n\n\t\t\t\t\t\t\t\t\tvar length = this.length();\n\n\t\t\t\t\t\t\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfloor: function floor() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.floor(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.floor(this.y);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tceil: function ceil() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.ceil(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.ceil(this.y);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tround: function round() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.round(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.round(this.y);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\troundToZero: function roundToZero() {\n\n\t\t\t\t\t\t\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnegate: function negate() {\n\n\t\t\t\t\t\t\t\t\tthis.x = -this.x;\n\t\t\t\t\t\t\t\t\tthis.y = -this.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdot: function dot(v) {\n\n\t\t\t\t\t\t\t\t\treturn this.x * v.x + this.y * v.y;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcross: function cross(v) {\n\n\t\t\t\t\t\t\t\t\treturn this.x * v.y - this.y * v.x;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlengthSq: function lengthSq() {\n\n\t\t\t\t\t\t\t\t\treturn this.x * this.x + this.y * this.y;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlength: function length() {\n\n\t\t\t\t\t\t\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmanhattanLength: function manhattanLength() {\n\n\t\t\t\t\t\t\t\t\treturn Math.abs(this.x) + Math.abs(this.y);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnormalize: function normalize() {\n\n\t\t\t\t\t\t\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tangle: function angle() {\n\n\t\t\t\t\t\t\t\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\t\t\t\t\t\t\t\tvar angle = Math.atan2(this.y, this.x);\n\n\t\t\t\t\t\t\t\t\tif (angle < 0) angle += 2 * Math.PI;\n\n\t\t\t\t\t\t\t\t\treturn angle;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdistanceTo: function distanceTo(v) {\n\n\t\t\t\t\t\t\t\t\treturn Math.sqrt(this.distanceToSquared(v));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdistanceToSquared: function distanceToSquared(v) {\n\n\t\t\t\t\t\t\t\t\tvar dx = this.x - v.x,\n\t\t\t\t\t\t\t\t\t    dy = this.y - v.y;\n\t\t\t\t\t\t\t\t\treturn dx * dx + dy * dy;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmanhattanDistanceTo: function manhattanDistanceTo(v) {\n\n\t\t\t\t\t\t\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetLength: function setLength(length) {\n\n\t\t\t\t\t\t\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlerp: function lerp(v, alpha) {\n\n\t\t\t\t\t\t\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\t\t\t\t\t\t\tthis.y += (v.y - this.y) * alpha;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlerpVectors: function lerpVectors(v1, v2, alpha) {\n\n\t\t\t\t\t\t\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tequals: function equals(v) {\n\n\t\t\t\t\t\t\t\t\treturn v.x === this.x && v.y === this.y;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromArray: function fromArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tthis.x = array[offset];\n\t\t\t\t\t\t\t\t\tthis.y = array[offset + 1];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoArray: function toArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (array === undefined) array = [];\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tarray[offset] = this.x;\n\t\t\t\t\t\t\t\t\tarray[offset + 1] = this.y;\n\n\t\t\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x = attribute.getX(index);\n\t\t\t\t\t\t\t\t\tthis.y = attribute.getY(index);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\trotateAround: function rotateAround(center, angle) {\n\n\t\t\t\t\t\t\t\t\tvar c = Math.cos(angle),\n\t\t\t\t\t\t\t\t\t    s = Math.sin(angle);\n\n\t\t\t\t\t\t\t\t\tvar x = this.x - center.x;\n\t\t\t\t\t\t\t\t\tvar y = this.y - center.y;\n\n\t\t\t\t\t\t\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\t\t\t\t\t\t\tthis.y = x * s + y * c + center.y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    * @author WestLangley / http://github.com/WestLangley\r\n    * @author bhouston / http://clara.io\r\n    */\n\n\t\t\tfunction Euler(x, y, z, order) {\n\n\t\t\t\t\t\tthis._x = x || 0;\n\t\t\t\t\t\tthis._y = y || 0;\n\t\t\t\t\t\tthis._z = z || 0;\n\t\t\t\t\t\tthis._order = order || Euler.DefaultOrder;\n\t\t\t}\n\n\t\t\tEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\n\n\t\t\tEuler.DefaultOrder = 'XYZ';\n\n\t\t\tObject.defineProperties(Euler.prototype, {\n\n\t\t\t\t\t\tx: {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this._x;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = value;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ty: {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this._y;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = value;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tz: {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this._z;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = value;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\torder: {\n\n\t\t\t\t\t\t\t\t\tget: function get() {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this._order;\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._order = value;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tObject.assign(Euler.prototype, {\n\n\t\t\t\t\t\tisEuler: true,\n\n\t\t\t\t\t\tset: function set(x, y, z, order) {\n\n\t\t\t\t\t\t\t\t\tthis._x = x;\n\t\t\t\t\t\t\t\t\tthis._y = y;\n\t\t\t\t\t\t\t\t\tthis._z = z;\n\t\t\t\t\t\t\t\t\tthis._order = order || this._order;\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor(this._x, this._y, this._z, this._order);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(euler) {\n\n\t\t\t\t\t\t\t\t\tthis._x = euler._x;\n\t\t\t\t\t\t\t\t\tthis._y = euler._y;\n\t\t\t\t\t\t\t\t\tthis._z = euler._z;\n\t\t\t\t\t\t\t\t\tthis._order = euler._order;\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromRotationMatrix: function setFromRotationMatrix(m, order, update) {\n\n\t\t\t\t\t\t\t\t\tvar clamp = _Math.clamp;\n\n\t\t\t\t\t\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\t\t\t\t\t\t\tvar te = m.elements;\n\t\t\t\t\t\t\t\t\tvar m11 = te[0],\n\t\t\t\t\t\t\t\t\t    m12 = te[4],\n\t\t\t\t\t\t\t\t\t    m13 = te[8];\n\t\t\t\t\t\t\t\t\tvar m21 = te[1],\n\t\t\t\t\t\t\t\t\t    m22 = te[5],\n\t\t\t\t\t\t\t\t\t    m23 = te[9];\n\t\t\t\t\t\t\t\t\tvar m31 = te[2],\n\t\t\t\t\t\t\t\t\t    m32 = te[6],\n\t\t\t\t\t\t\t\t\t    m33 = te[10];\n\n\t\t\t\t\t\t\t\t\torder = order || this._order;\n\n\t\t\t\t\t\t\t\t\tif (order === 'XYZ') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = Math.asin(clamp(m13, -1, 1));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(m13) < 0.99999) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._x = Math.atan2(-m23, m33);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._z = Math.atan2(-m12, m11);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._x = Math.atan2(m32, m22);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (order === 'YXZ') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = Math.asin(-clamp(m23, -1, 1));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(m23) < 0.99999) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._y = Math.atan2(m13, m33);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._z = Math.atan2(m21, m22);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._y = Math.atan2(-m31, m11);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (order === 'ZXY') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._x = Math.asin(clamp(m32, -1, 1));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(m32) < 0.99999) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._y = Math.atan2(-m31, m33);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._z = Math.atan2(-m12, m22);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._z = Math.atan2(m21, m11);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (order === 'ZYX') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._y = Math.asin(-clamp(m31, -1, 1));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(m31) < 0.99999) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._x = Math.atan2(m32, m33);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._z = Math.atan2(m21, m11);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._z = Math.atan2(-m12, m22);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (order === 'YZX') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = Math.asin(clamp(m21, -1, 1));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(m21) < 0.99999) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._x = Math.atan2(-m23, m22);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._y = Math.atan2(-m31, m11);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._y = Math.atan2(m13, m33);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (order === 'XZY') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis._z = Math.asin(-clamp(m12, -1, 1));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(m12) < 0.99999) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._x = Math.atan2(m32, m22);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._y = Math.atan2(m13, m11);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._x = Math.atan2(-m23, m33);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis._order = order;\n\n\t\t\t\t\t\t\t\t\tif (update !== false) this.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromQuaternion: function () {\n\n\t\t\t\t\t\t\t\t\tvar matrix = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function setFromQuaternion(q, order, update) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.makeRotationFromQuaternion(q);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.setFromRotationMatrix(matrix, order, update);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tsetFromVector3: function setFromVector3(v, order) {\n\n\t\t\t\t\t\t\t\t\treturn this.set(v.x, v.y, v.z, order || this._order);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\treorder: function () {\n\n\t\t\t\t\t\t\t\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t\t\t\t\t\t\t\tvar q = new Quaternion();\n\n\t\t\t\t\t\t\t\t\treturn function reorder(newOrder) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tq.setFromEuler(this);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.setFromQuaternion(q, newOrder);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tequals: function equals(euler) {\n\n\t\t\t\t\t\t\t\t\treturn euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromArray: function fromArray(array) {\n\n\t\t\t\t\t\t\t\t\tthis._x = array[0];\n\t\t\t\t\t\t\t\t\tthis._y = array[1];\n\t\t\t\t\t\t\t\t\tthis._z = array[2];\n\t\t\t\t\t\t\t\t\tif (array[3] !== undefined) this._order = array[3];\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback();\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoArray: function toArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (array === undefined) array = [];\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tarray[offset] = this._x;\n\t\t\t\t\t\t\t\t\tarray[offset + 1] = this._y;\n\t\t\t\t\t\t\t\t\tarray[offset + 2] = this._z;\n\t\t\t\t\t\t\t\t\tarray[offset + 3] = this._order;\n\n\t\t\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoVector3: function toVector3(optionalResult) {\n\n\t\t\t\t\t\t\t\t\tif (optionalResult) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn optionalResult.set(this._x, this._y, this._z);\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn new Vector3(this._x, this._y, this._z);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tonChange: function onChange(callback) {\n\n\t\t\t\t\t\t\t\t\tthis.onChangeCallback = callback;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tonChangeCallback: function onChangeCallback() {}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    */\n\n\t\t\tfunction Layers() {\n\n\t\t\t\t\t\tthis.mask = 1 | 0;\n\t\t\t}\n\n\t\t\tObject.assign(Layers.prototype, {\n\n\t\t\t\t\t\tset: function set(channel) {\n\n\t\t\t\t\t\t\t\t\tthis.mask = 1 << channel | 0;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tenable: function enable(channel) {\n\n\t\t\t\t\t\t\t\t\tthis.mask |= 1 << channel | 0;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoggle: function toggle(channel) {\n\n\t\t\t\t\t\t\t\t\tthis.mask ^= 1 << channel | 0;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdisable: function disable(channel) {\n\n\t\t\t\t\t\t\t\t\tthis.mask &= ~(1 << channel | 0);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttest: function test(layers) {\n\n\t\t\t\t\t\t\t\t\treturn (this.mask & layers.mask) !== 0;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tvar TrianglesDrawMode = 0;\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    * @author mikael emtinger / http://gomo.se/\r\n    * @author alteredq / http://alteredqualia.com/\r\n    * @author WestLangley / http://github.com/WestLangley\r\n    * @author elephantatwork / www.elephantatwork.ch\r\n    */\n\n\t\t\tvar object3DId = 0;\n\n\t\t\tfunction Object3D() {\n\n\t\t\t\t\t\tObject.defineProperty(this, 'id', { value: object3DId++ });\n\n\t\t\t\t\t\tthis.uuid = _Math.generateUUID();\n\n\t\t\t\t\t\tthis.name = '';\n\t\t\t\t\t\tthis.type = 'Object3D';\n\n\t\t\t\t\t\tthis.parent = null;\n\t\t\t\t\t\tthis.children = [];\n\n\t\t\t\t\t\tthis.up = Object3D.DefaultUp.clone();\n\n\t\t\t\t\t\tvar position = new Vector3();\n\t\t\t\t\t\tvar rotation = new Euler();\n\t\t\t\t\t\tvar quaternion = new Quaternion();\n\t\t\t\t\t\tvar scale = new Vector3(1, 1, 1);\n\n\t\t\t\t\t\tfunction onRotationChange() {\n\n\t\t\t\t\t\t\t\t\tquaternion.setFromEuler(rotation, false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction onQuaternionChange() {\n\n\t\t\t\t\t\t\t\t\trotation.setFromQuaternion(quaternion, undefined, false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trotation.onChange(onRotationChange);\n\t\t\t\t\t\tquaternion.onChange(onQuaternionChange);\n\n\t\t\t\t\t\tObject.defineProperties(this, {\n\t\t\t\t\t\t\t\t\tposition: {\n\t\t\t\t\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: position\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trotation: {\n\t\t\t\t\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: rotation\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tquaternion: {\n\t\t\t\t\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: quaternion\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tscale: {\n\t\t\t\t\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: scale\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnormalMatrix: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis.matrix = new Matrix4();\n\t\t\t\t\t\tthis.matrixWorld = new Matrix4();\n\n\t\t\t\t\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\t\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\t\t\tthis.layers = new Layers();\n\t\t\t\t\t\tthis.visible = true;\n\n\t\t\t\t\t\tthis.castShadow = false;\n\t\t\t\t\t\tthis.receiveShadow = false;\n\n\t\t\t\t\t\tthis.frustumCulled = true;\n\t\t\t\t\t\tthis.renderOrder = 0;\n\n\t\t\t\t\t\tthis.userData = {};\n\t\t\t}\n\n\t\t\tObject3D.DefaultUp = new Vector3(0, 1, 0);\n\t\t\tObject3D.DefaultMatrixAutoUpdate = true;\n\n\t\t\tObject3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n\n\t\t\t\t\t\tconstructor: Object3D,\n\n\t\t\t\t\t\tisObject3D: true,\n\n\t\t\t\t\t\tonBeforeRender: function onBeforeRender() {},\n\t\t\t\t\t\tonAfterRender: function onAfterRender() {},\n\n\t\t\t\t\t\tapplyMatrix: function applyMatrix(matrix) {\n\n\t\t\t\t\t\t\t\t\tthis.matrix.multiplyMatrices(matrix, this.matrix);\n\n\t\t\t\t\t\t\t\t\tthis.matrix.decompose(this.position, this.quaternion, this.scale);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyQuaternion: function applyQuaternion(q) {\n\n\t\t\t\t\t\t\t\t\tthis.quaternion.premultiply(q);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {\n\n\t\t\t\t\t\t\t\t\t// assumes axis is normalized\n\n\t\t\t\t\t\t\t\t\tthis.quaternion.setFromAxisAngle(axis, angle);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetRotationFromEuler: function setRotationFromEuler(euler) {\n\n\t\t\t\t\t\t\t\t\tthis.quaternion.setFromEuler(euler, true);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetRotationFromMatrix: function setRotationFromMatrix(m) {\n\n\t\t\t\t\t\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\t\t\t\t\t\t\tthis.quaternion.setFromRotationMatrix(m);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetRotationFromQuaternion: function setRotationFromQuaternion(q) {\n\n\t\t\t\t\t\t\t\t\t// assumes q is normalized\n\n\t\t\t\t\t\t\t\t\tthis.quaternion.copy(q);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\trotateOnAxis: function () {\n\n\t\t\t\t\t\t\t\t\t// rotate object on axis in object space\n\t\t\t\t\t\t\t\t\t// axis is assumed to be normalized\n\n\t\t\t\t\t\t\t\t\tvar q1 = new Quaternion();\n\n\t\t\t\t\t\t\t\t\treturn function rotateOnAxis(axis, angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tq1.setFromAxisAngle(axis, angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.quaternion.multiply(q1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\trotateOnWorldAxis: function () {\n\n\t\t\t\t\t\t\t\t\t// rotate object on axis in world space\n\t\t\t\t\t\t\t\t\t// axis is assumed to be normalized\n\t\t\t\t\t\t\t\t\t// method assumes no rotated parent\n\n\t\t\t\t\t\t\t\t\tvar q1 = new Quaternion();\n\n\t\t\t\t\t\t\t\t\treturn function rotateOnWorldAxis(axis, angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tq1.setFromAxisAngle(axis, angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.quaternion.premultiply(q1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\trotateX: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3(1, 0, 0);\n\n\t\t\t\t\t\t\t\t\treturn function rotateX(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.rotateOnAxis(v1, angle);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\trotateY: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3(0, 1, 0);\n\n\t\t\t\t\t\t\t\t\treturn function rotateY(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.rotateOnAxis(v1, angle);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\trotateZ: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3(0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn function rotateZ(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.rotateOnAxis(v1, angle);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttranslateOnAxis: function () {\n\n\t\t\t\t\t\t\t\t\t// translate object by distance along axis in object space\n\t\t\t\t\t\t\t\t\t// axis is assumed to be normalized\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function translateOnAxis(axis, distance) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tv1.copy(axis).applyQuaternion(this.quaternion);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.position.add(v1.multiplyScalar(distance));\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttranslateX: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3(1, 0, 0);\n\n\t\t\t\t\t\t\t\t\treturn function translateX(distance) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.translateOnAxis(v1, distance);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttranslateY: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3(0, 1, 0);\n\n\t\t\t\t\t\t\t\t\treturn function translateY(distance) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.translateOnAxis(v1, distance);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttranslateZ: function () {\n\n\t\t\t\t\t\t\t\t\tvar v1 = new Vector3(0, 0, 1);\n\n\t\t\t\t\t\t\t\t\treturn function translateZ(distance) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.translateOnAxis(v1, distance);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tlocalToWorld: function localToWorld(vector) {\n\n\t\t\t\t\t\t\t\t\treturn vector.applyMatrix4(this.matrixWorld);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tworldToLocal: function () {\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function worldToLocal(vector) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn vector.applyMatrix4(m1.getInverse(this.matrixWorld));\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tlookAt: function () {\n\n\t\t\t\t\t\t\t\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\t\t\t\t\t\t\t\tvar q1 = new Quaternion();\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\t\t\t\t\t\t\t\t\tvar target = new Vector3();\n\t\t\t\t\t\t\t\t\tvar position = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function lookAt(x, y, z) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (x.isVector3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget.copy(x);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget.set(x, y, z);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar parent = this.parent;\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.updateWorldMatrix(true, false);\n\n\t\t\t\t\t\t\t\t\t\t\t\tposition.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.isCamera || this.isLight) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm1.lookAt(position, target, this.up);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm1.lookAt(target, position, this.up);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.quaternion.setFromRotationMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (parent) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm1.extractRotation(parent.matrixWorld);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tq1.setFromRotationMatrix(m1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.quaternion.premultiply(q1.inverse());\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tadd: function add(object) {\n\n\t\t\t\t\t\t\t\t\tif (arguments.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.add(arguments[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (object === this) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (object && object.isObject3D) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (object.parent !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tobject.parent.remove(object);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tobject.parent = this;\n\t\t\t\t\t\t\t\t\t\t\t\tobject.dispatchEvent({ type: 'added' });\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.children.push(object);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.dispatchEvent({ type: 'addedChild', object: object });\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tremove: function remove(object) {\n\n\t\t\t\t\t\t\t\t\tif (arguments.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.remove(arguments[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar index = this.children.indexOf(object);\n\n\t\t\t\t\t\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tobject.parent = null;\n\n\t\t\t\t\t\t\t\t\t\t\t\tobject.dispatchEvent({ type: 'removed' });\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.children.splice(index, 1);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetObjectById: function getObjectById(id) {\n\n\t\t\t\t\t\t\t\t\treturn this.getObjectByProperty('id', id);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetObjectByName: function getObjectByName(name) {\n\n\t\t\t\t\t\t\t\t\treturn this.getObjectByProperty('name', name);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetObjectByProperty: function getObjectByProperty(name, value) {\n\n\t\t\t\t\t\t\t\t\tif (this[name] === value) return this;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = this.children.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar child = this.children[i];\n\t\t\t\t\t\t\t\t\t\t\t\tvar object = child.getObjectByProperty(name, value);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (object !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn object;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetWorldPosition: function getWorldPosition(target) {\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Object3D: .getWorldPosition() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.updateMatrixWorld(true);\n\n\t\t\t\t\t\t\t\t\treturn target.setFromMatrixPosition(this.matrixWorld);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetWorldQuaternion: function () {\n\n\t\t\t\t\t\t\t\t\tvar position = new Vector3();\n\t\t\t\t\t\t\t\t\tvar scale = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function getWorldQuaternion(target) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Object3D: .getWorldQuaternion() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Quaternion();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.updateMatrixWorld(true);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.matrixWorld.decompose(position, target, scale);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tgetWorldScale: function () {\n\n\t\t\t\t\t\t\t\t\tvar position = new Vector3();\n\t\t\t\t\t\t\t\t\tvar quaternion = new Quaternion();\n\n\t\t\t\t\t\t\t\t\treturn function getWorldScale(target) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Object3D: .getWorldScale() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Vector3();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.updateMatrixWorld(true);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.matrixWorld.decompose(position, quaternion, target);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tgetWorldDirection: function getWorldDirection(target) {\n\n\t\t\t\t\t\t\t\t\tif (target === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Object3D: .getWorldDirection() target is now required');\n\t\t\t\t\t\t\t\t\t\t\t\ttarget = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.updateMatrixWorld(true);\n\n\t\t\t\t\t\t\t\t\tvar e = this.matrixWorld.elements;\n\n\t\t\t\t\t\t\t\t\treturn target.set(e[8], e[9], e[10]).normalize();\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\traycast: function raycast() {},\n\n\t\t\t\t\t\ttraverse: function traverse(callback) {\n\n\t\t\t\t\t\t\t\t\tcallback(this);\n\n\t\t\t\t\t\t\t\t\tvar children = this.children;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tchildren[i].traverse(callback);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttraverseVisible: function traverseVisible(callback) {\n\n\t\t\t\t\t\t\t\t\tif (this.visible === false) return;\n\n\t\t\t\t\t\t\t\t\tcallback(this);\n\n\t\t\t\t\t\t\t\t\tvar children = this.children;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tchildren[i].traverseVisible(callback);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttraverseAncestors: function traverseAncestors(callback) {\n\n\t\t\t\t\t\t\t\t\tvar parent = this.parent;\n\n\t\t\t\t\t\t\t\t\tif (parent !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(parent);\n\n\t\t\t\t\t\t\t\t\t\t\t\tparent.traverseAncestors(callback);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tupdateMatrix: function updateMatrix() {\n\n\t\t\t\t\t\t\t\t\tthis.matrix.compose(this.position, this.quaternion, this.scale);\n\n\t\t\t\t\t\t\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tupdateMatrixWorld: function updateMatrixWorld(force) {\n\n\t\t\t\t\t\t\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\n\t\t\t\t\t\t\t\t\tif (this.matrixWorldNeedsUpdate || force) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.parent === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\t\t\t\t\t\t\t\t\tforce = true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// update children\n\n\t\t\t\t\t\t\t\t\tvar children = this.children;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tchildren[i].updateMatrixWorld(force);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tupdateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {\n\n\t\t\t\t\t\t\t\t\tvar parent = this.parent;\n\n\t\t\t\t\t\t\t\t\tif (updateParents === true && parent !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tparent.updateWorldMatrix(true, false);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\n\t\t\t\t\t\t\t\t\tif (this.parent === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// update children\n\n\t\t\t\t\t\t\t\t\tif (updateChildren === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar children = this.children;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildren[i].updateWorldMatrix(false, true);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoJSON: function toJSON(meta) {\n\n\t\t\t\t\t\t\t\t\t// meta is a string when called from JSON.stringify\n\t\t\t\t\t\t\t\t\tvar isRootObject = meta === undefined || typeof meta === 'string';\n\n\t\t\t\t\t\t\t\t\tvar output = {};\n\n\t\t\t\t\t\t\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t\t\t\t\t\t\t// not providing it implies that this is the root object\n\t\t\t\t\t\t\t\t\t// being serialized.\n\t\t\t\t\t\t\t\t\tif (isRootObject) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// initialize meta obj\n\t\t\t\t\t\t\t\t\t\t\t\tmeta = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeometries: {},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterials: {},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttextures: {},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timages: {},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshapes: {}\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\toutput.metadata = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'Object',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// standard Object3D serialization\n\n\t\t\t\t\t\t\t\t\tvar object = {};\n\n\t\t\t\t\t\t\t\t\tobject.uuid = this.uuid;\n\t\t\t\t\t\t\t\t\tobject.type = this.type;\n\n\t\t\t\t\t\t\t\t\tif (this.name !== '') object.name = this.name;\n\t\t\t\t\t\t\t\t\tif (this.castShadow === true) object.castShadow = true;\n\t\t\t\t\t\t\t\t\tif (this.receiveShadow === true) object.receiveShadow = true;\n\t\t\t\t\t\t\t\t\tif (this.visible === false) object.visible = false;\n\t\t\t\t\t\t\t\t\tif (this.frustumCulled === false) object.frustumCulled = false;\n\t\t\t\t\t\t\t\t\tif (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n\t\t\t\t\t\t\t\t\tif (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;\n\n\t\t\t\t\t\t\t\t\tobject.layers = this.layers.mask;\n\t\t\t\t\t\t\t\t\tobject.matrix = this.matrix.toArray();\n\n\t\t\t\t\t\t\t\t\tif (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n\n\t\t\t\t\t\t\t\t\t// object specific properties\n\n\t\t\t\t\t\t\t\t\tif (this.isMesh && this.drawMode !== TrianglesDrawMode) object.drawMode = this.drawMode;\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tfunction serialize(library, element) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (library[element.uuid] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlibrary[element.uuid] = element.toJSON(meta);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn element.uuid;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.isMesh || this.isLine || this.isPoints) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tobject.geometry = serialize(meta.geometries, this.geometry);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar parameters = this.geometry.parameters;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (parameters !== undefined && parameters.shapes !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar shapes = parameters.shapes;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(shapes)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = shapes.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar shape = shapes[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tserialize(meta.shapes, shape);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tserialize(meta.shapes, shapes);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.material !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(this.material)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar uuids = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = this.material.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuuids.push(serialize(meta.materials, this.material[i]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tobject.material = uuids;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tobject.material = serialize(meta.materials, this.material);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tif (this.children.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tobject.children = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tobject.children.push(this.children[i].toJSON(meta).object);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (isRootObject) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar geometries = extractFromCache(meta.geometries);\n\t\t\t\t\t\t\t\t\t\t\t\tvar materials = extractFromCache(meta.materials);\n\t\t\t\t\t\t\t\t\t\t\t\tvar textures = extractFromCache(meta.textures);\n\t\t\t\t\t\t\t\t\t\t\t\tvar images = extractFromCache(meta.images);\n\t\t\t\t\t\t\t\t\t\t\t\tvar shapes = extractFromCache(meta.shapes);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometries.length > 0) output.geometries = geometries;\n\t\t\t\t\t\t\t\t\t\t\t\tif (materials.length > 0) output.materials = materials;\n\t\t\t\t\t\t\t\t\t\t\t\tif (textures.length > 0) output.textures = textures;\n\t\t\t\t\t\t\t\t\t\t\t\tif (images.length > 0) output.images = images;\n\t\t\t\t\t\t\t\t\t\t\t\tif (shapes.length > 0) output.shapes = shapes;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\toutput.object = object;\n\n\t\t\t\t\t\t\t\t\treturn output;\n\n\t\t\t\t\t\t\t\t\t// extract data from the cache hash\n\t\t\t\t\t\t\t\t\t// remove metadata on each item\n\t\t\t\t\t\t\t\t\t// and return as array\n\t\t\t\t\t\t\t\t\tfunction extractFromCache(cache) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar values = [];\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var key in cache) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar data = cache[key];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues.push(data);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn values;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone(recursive) {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor().copy(this, recursive);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source, recursive) {\n\n\t\t\t\t\t\t\t\t\tif (recursive === undefined) recursive = true;\n\n\t\t\t\t\t\t\t\t\tthis.name = source.name;\n\n\t\t\t\t\t\t\t\t\tthis.up.copy(source.up);\n\n\t\t\t\t\t\t\t\t\tthis.position.copy(source.position);\n\t\t\t\t\t\t\t\t\tthis.quaternion.copy(source.quaternion);\n\t\t\t\t\t\t\t\t\tthis.scale.copy(source.scale);\n\n\t\t\t\t\t\t\t\t\tthis.matrix.copy(source.matrix);\n\t\t\t\t\t\t\t\t\tthis.matrixWorld.copy(source.matrixWorld);\n\n\t\t\t\t\t\t\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\t\t\t\t\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\t\t\t\t\t\t\t\tthis.layers.mask = source.layers.mask;\n\t\t\t\t\t\t\t\t\tthis.visible = source.visible;\n\n\t\t\t\t\t\t\t\t\tthis.castShadow = source.castShadow;\n\t\t\t\t\t\t\t\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\t\t\t\t\t\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\t\t\t\t\t\t\tthis.renderOrder = source.renderOrder;\n\n\t\t\t\t\t\t\t\t\tthis.userData = JSON.parse(JSON.stringify(source.userData));\n\n\t\t\t\t\t\t\t\t\tif (recursive === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < source.children.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar child = source.children[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.add(child.clone());\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    * @author kile / http://kile.stravaganza.org/\r\n    * @author alteredq / http://alteredqualia.com/\r\n    * @author mikael emtinger / http://gomo.se/\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    * @author bhouston / http://clara.io\r\n    */\n\n\t\t\tvar geometryId = 0; // Geometry uses even numbers as Id\n\n\t\t\tfunction Geometry() {\n\n\t\t\t\t\t\tObject.defineProperty(this, 'id', { value: geometryId += 2 });\n\n\t\t\t\t\t\tthis.uuid = _Math.generateUUID();\n\n\t\t\t\t\t\tthis.name = '';\n\t\t\t\t\t\tthis.type = 'Geometry';\n\n\t\t\t\t\t\tthis.vertices = [];\n\t\t\t\t\t\tthis.colors = [];\n\t\t\t\t\t\tthis.faces = [];\n\t\t\t\t\t\tthis.faceVertexUvs = [[]];\n\n\t\t\t\t\t\tthis.morphTargets = [];\n\t\t\t\t\t\tthis.morphNormals = [];\n\n\t\t\t\t\t\tthis.skinWeights = [];\n\t\t\t\t\t\tthis.skinIndices = [];\n\n\t\t\t\t\t\tthis.lineDistances = [];\n\n\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t\tthis.boundingSphere = null;\n\n\t\t\t\t\t\t// update flags\n\n\t\t\t\t\t\tthis.elementsNeedUpdate = false;\n\t\t\t\t\t\tthis.verticesNeedUpdate = false;\n\t\t\t\t\t\tthis.uvsNeedUpdate = false;\n\t\t\t\t\t\tthis.normalsNeedUpdate = false;\n\t\t\t\t\t\tthis.colorsNeedUpdate = false;\n\t\t\t\t\t\tthis.lineDistancesNeedUpdate = false;\n\t\t\t\t\t\tthis.groupsNeedUpdate = false;\n\t\t\t}\n\n\t\t\tGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n\n\t\t\t\t\t\tconstructor: Geometry,\n\n\t\t\t\t\t\tisGeometry: true,\n\n\t\t\t\t\t\tapplyMatrix: function applyMatrix(matrix) {\n\n\t\t\t\t\t\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, il = this.vertices.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertex = this.vertices[i];\n\t\t\t\t\t\t\t\t\t\t\t\tvertex.applyMatrix4(matrix);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, il = this.faces.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar face = this.faces[i];\n\t\t\t\t\t\t\t\t\t\t\t\tface.normal.applyMatrix3(normalMatrix).normalize();\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.boundingBox !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.computeBoundingBox();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.boundingSphere !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.computeBoundingSphere();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.verticesNeedUpdate = true;\n\t\t\t\t\t\t\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\trotateX: function () {\n\n\t\t\t\t\t\t\t\t\t// rotate geometry around world x-axis\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function rotateX(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeRotationX(angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\trotateY: function () {\n\n\t\t\t\t\t\t\t\t\t// rotate geometry around world y-axis\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function rotateY(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeRotationY(angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\trotateZ: function () {\n\n\t\t\t\t\t\t\t\t\t// rotate geometry around world z-axis\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function rotateZ(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeRotationZ(angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttranslate: function () {\n\n\t\t\t\t\t\t\t\t\t// translate geometry\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function translate(x, y, z) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeTranslation(x, y, z);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tscale: function () {\n\n\t\t\t\t\t\t\t\t\t// scale geometry\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function scale(x, y, z) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeScale(x, y, z);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tlookAt: function () {\n\n\t\t\t\t\t\t\t\t\tvar obj = new Object3D();\n\n\t\t\t\t\t\t\t\t\treturn function lookAt(vector) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tobj.lookAt(vector);\n\n\t\t\t\t\t\t\t\t\t\t\t\tobj.updateMatrix();\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(obj.matrix);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tfromBufferGeometry: function fromBufferGeometry(geometry) {\n\n\t\t\t\t\t\t\t\t\tvar scope = this;\n\n\t\t\t\t\t\t\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\t\t\t\t\t\t\tvar attributes = geometry.attributes;\n\n\t\t\t\t\t\t\t\t\tvar positions = attributes.position.array;\n\t\t\t\t\t\t\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\t\t\t\t\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\t\t\t\t\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\t\t\t\t\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\t\t\t\t\t\t\t\tif (uvs2 !== undefined) this.faceVertexUvs[1] = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tscope.vertices.push(new Vector3().fromArray(positions, i));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (colors !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscope.colors.push(new Color().fromArray(colors, i));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction addFace(a, b, c, materialIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertexNormals = normals === undefined ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n\n\t\t\t\t\t\t\t\t\t\t\t\tscope.faces.push(face);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvs !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvs2 !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\n\t\t\t\t\t\t\t\t\tif (groups.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < groups.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar group = groups[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = start, jl = start + count; j < jl; j += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (indices !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddFace(j, j + 1, j + 2, group.materialIndex);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (indices !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < indices.length; i += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddFace(indices[i], indices[i + 1], indices[i + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < positions.length / 3; i += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\taddFace(i, i + 1, i + 2);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\t\t\t\t\t\tif (geometry.boundingBox !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.boundingSphere !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcenter: function () {\n\n\t\t\t\t\t\t\t\t\tvar offset = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function center() {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox.getCenter(offset).negate();\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.translate(offset.x, offset.y, offset.z);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tnormalize: function normalize() {\n\n\t\t\t\t\t\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t\t\t\t\t\t\tvar center = this.boundingSphere.center;\n\t\t\t\t\t\t\t\t\tvar radius = this.boundingSphere.radius;\n\n\t\t\t\t\t\t\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\t\t\t\t\t\t\t\tvar matrix = new Matrix4();\n\t\t\t\t\t\t\t\t\tmatrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n\n\t\t\t\t\t\t\t\t\tthis.applyMatrix(matrix);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeFaceNormals: function computeFaceNormals() {\n\n\t\t\t\t\t\t\t\t\tvar cb = new Vector3(),\n\t\t\t\t\t\t\t\t\t    ab = new Vector3();\n\n\t\t\t\t\t\t\t\t\tfor (var f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar face = this.faces[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vA = this.vertices[face.a];\n\t\t\t\t\t\t\t\t\t\t\t\tvar vB = this.vertices[face.b];\n\t\t\t\t\t\t\t\t\t\t\t\tvar vC = this.vertices[face.c];\n\n\t\t\t\t\t\t\t\t\t\t\t\tcb.subVectors(vC, vB);\n\t\t\t\t\t\t\t\t\t\t\t\tab.subVectors(vA, vB);\n\t\t\t\t\t\t\t\t\t\t\t\tcb.cross(ab);\n\n\t\t\t\t\t\t\t\t\t\t\t\tcb.normalize();\n\n\t\t\t\t\t\t\t\t\t\t\t\tface.normal.copy(cb);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeVertexNormals: function computeVertexNormals(areaWeighted) {\n\n\t\t\t\t\t\t\t\t\tif (areaWeighted === undefined) areaWeighted = true;\n\n\t\t\t\t\t\t\t\t\tvar v, vl, f, fl, face, vertices;\n\n\t\t\t\t\t\t\t\t\tvertices = new Array(this.vertices.length);\n\n\t\t\t\t\t\t\t\t\tfor (v = 0, vl = this.vertices.length; v < vl; v++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertices[v] = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (areaWeighted) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t\t\t\t\t\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vA, vB, vC;\n\t\t\t\t\t\t\t\t\t\t\t\tvar cb = new Vector3(),\n\t\t\t\t\t\t\t\t\t\t\t\t    ab = new Vector3();\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface = this.faces[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvA = this.vertices[face.a];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvB = this.vertices[face.b];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvC = this.vertices[face.c];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb.subVectors(vC, vB);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tab.subVectors(vA, vB);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb.cross(ab);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertices[face.a].add(cb);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertices[face.b].add(cb);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertices[face.c].add(cb);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface = this.faces[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertices[face.a].add(face.normal);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertices[face.b].add(face.normal);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertices[face.c].add(face.normal);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor (v = 0, vl = this.vertices.length; v < vl; v++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertices[v].normalize();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tface = this.faces[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (vertexNormals.length === 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[0].copy(vertices[face.a]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[1].copy(vertices[face.b]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[2].copy(vertices[face.c]);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[0] = vertices[face.a].clone();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[1] = vertices[face.b].clone();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[2] = vertices[face.c].clone();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.faces.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeFlatVertexNormals: function computeFlatVertexNormals() {\n\n\t\t\t\t\t\t\t\t\tvar f, fl, face;\n\n\t\t\t\t\t\t\t\t\tthis.computeFaceNormals();\n\n\t\t\t\t\t\t\t\t\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tface = this.faces[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (vertexNormals.length === 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[0].copy(face.normal);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[1].copy(face.normal);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[2].copy(face.normal);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[0] = face.normal.clone();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[1] = face.normal.clone();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals[2] = face.normal.clone();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.faces.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.normalsNeedUpdate = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeMorphNormals: function computeMorphNormals() {\n\n\t\t\t\t\t\t\t\t\tvar i, il, f, fl, face;\n\n\t\t\t\t\t\t\t\t\t// save original normals\n\t\t\t\t\t\t\t\t\t// - create temp variables on first access\n\t\t\t\t\t\t\t\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\t\t\t\t\t\t\t\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tface = this.faces[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!face.__originalFaceNormal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface.__originalFaceNormal.copy(face.normal);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, il = face.vertexNormals.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!face.__originalVertexNormals[i]) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\t\t\t\t\t\t\t\tvar tmpGeo = new Geometry();\n\t\t\t\t\t\t\t\t\ttmpGeo.faces = this.faces;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = this.morphTargets.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// create on first access\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!this.morphNormals[i]) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.morphNormals[i] = {};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.morphNormals[i].faceNormals = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.morphNormals[i].vertexNormals = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dstNormalsFace = this.morphNormals[i].faceNormals;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceNormal = new Vector3();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdstNormalsFace.push(faceNormal);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdstNormalsVertex.push(vertexNormals);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphNormals = this.morphNormals[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t// set vertices to morph target\n\n\t\t\t\t\t\t\t\t\t\t\t\ttmpGeo.vertices = this.morphTargets[i].vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// compute morph normals\n\n\t\t\t\t\t\t\t\t\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\t\t\t\t\t\t\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// store morph normals\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface = this.faces[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceNormal = morphNormals.faceNormals[f];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceNormal.copy(face.normal);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals.a.copy(face.vertexNormals[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals.b.copy(face.vertexNormals[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexNormals.c.copy(face.vertexNormals[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// restore original normals\n\n\t\t\t\t\t\t\t\t\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tface = this.faces[f];\n\n\t\t\t\t\t\t\t\t\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\t\t\t\t\t\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeBoundingBox: function computeBoundingBox() {\n\n\t\t\t\t\t\t\t\t\tif (this.boundingBox === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox = new Box3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.boundingBox.setFromPoints(this.vertices);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeBoundingSphere: function computeBoundingSphere() {\n\n\t\t\t\t\t\t\t\t\tif (this.boundingSphere === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.boundingSphere.setFromPoints(this.vertices);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmerge: function merge(geometry, matrix, materialIndexOffset) {\n\n\t\t\t\t\t\t\t\t\tif (!(geometry && geometry.isGeometry)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar normalMatrix,\n\t\t\t\t\t\t\t\t\t    vertexOffset = this.vertices.length,\n\t\t\t\t\t\t\t\t\t    vertices1 = this.vertices,\n\t\t\t\t\t\t\t\t\t    vertices2 = geometry.vertices,\n\t\t\t\t\t\t\t\t\t    faces1 = this.faces,\n\t\t\t\t\t\t\t\t\t    faces2 = geometry.faces,\n\t\t\t\t\t\t\t\t\t    uvs1 = this.faceVertexUvs[0],\n\t\t\t\t\t\t\t\t\t    uvs2 = geometry.faceVertexUvs[0],\n\t\t\t\t\t\t\t\t\t    colors1 = this.colors,\n\t\t\t\t\t\t\t\t\t    colors2 = geometry.colors;\n\n\t\t\t\t\t\t\t\t\tif (materialIndexOffset === undefined) materialIndexOffset = 0;\n\n\t\t\t\t\t\t\t\t\tif (matrix !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnormalMatrix = new Matrix3().getNormalMatrix(matrix);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// vertices\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, il = vertices2.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertex = vertices2[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertices1.push(vertexCopy);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// colors\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, il = colors2.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcolors1.push(colors2[i].clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// faces\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = faces2.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar face = faces2[i],\n\t\t\t\t\t\t\t\t\t\t\t\t    faceCopy,\n\t\t\t\t\t\t\t\t\t\t\t\t    normal,\n\t\t\t\t\t\t\t\t\t\t\t\t    color,\n\t\t\t\t\t\t\t\t\t\t\t\t    faceVertexNormals = face.vertexNormals,\n\t\t\t\t\t\t\t\t\t\t\t\t    faceVertexColors = face.vertexColors;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n\t\t\t\t\t\t\t\t\t\t\t\tfaceCopy.normal.copy(face.normal);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (normalMatrix !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceCopy.normal.applyMatrix3(normalMatrix).normalize();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormal = faceVertexNormals[j].clone();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (normalMatrix !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormal.applyMatrix3(normalMatrix).normalize();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceCopy.vertexNormals.push(normal);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaceCopy.color.copy(face.color);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor = faceVertexColors[j];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceCopy.vertexColors.push(color.clone());\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaces1.push(faceCopy);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// uvs\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = uvs2.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar uv = uvs2[i],\n\t\t\t\t\t\t\t\t\t\t\t\t    uvCopy = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uv === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0, jl = uv.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvCopy.push(uv[j].clone());\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tuvs1.push(uvCopy);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmergeMesh: function mergeMesh(mesh) {\n\n\t\t\t\t\t\t\t\t\tif (!(mesh && mesh.isMesh)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (mesh.matrixAutoUpdate) mesh.updateMatrix();\n\n\t\t\t\t\t\t\t\t\tthis.merge(mesh.geometry, mesh.matrix);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/*\r\n       * Checks for duplicate vertices with hashmap.\r\n       * Duplicated vertices are removed\r\n       * and faces' vertices are updated.\r\n       */\n\n\t\t\t\t\t\tmergeVertices: function mergeVertices() {\n\n\t\t\t\t\t\t\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\t\t\t\t\t\t\tvar unique = [],\n\t\t\t\t\t\t\t\t\t    changes = [];\n\n\t\t\t\t\t\t\t\t\tvar v, key;\n\t\t\t\t\t\t\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\t\t\t\t\t\t\tvar precision = Math.pow(10, precisionPoints);\n\t\t\t\t\t\t\t\t\tvar i, il, face;\n\t\t\t\t\t\t\t\t\tvar indices, j, jl;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = this.vertices.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tv = this.vertices[i];\n\t\t\t\t\t\t\t\t\t\t\t\tkey = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (verticesMap[key] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tverticesMap[key] = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tunique.push(this.vertices[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchanges[i] = unique.length - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchanges[i] = changes[verticesMap[key]];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t\t\t\t\t\t\t// have to remove them from the geometry.\n\t\t\t\t\t\t\t\t\tvar faceIndicesToRemove = [];\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = this.faces.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tface = this.faces[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tface.a = changes[face.a];\n\t\t\t\t\t\t\t\t\t\t\t\tface.b = changes[face.b];\n\t\t\t\t\t\t\t\t\t\t\t\tface.c = changes[face.c];\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices = [face.a, face.b, face.c];\n\n\t\t\t\t\t\t\t\t\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t\t\t\t\t\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var n = 0; n < 3; n++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (indices[n] === indices[(n + 1) % 3]) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceIndicesToRemove.push(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor (i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar idx = faceIndicesToRemove[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.faces.splice(idx, 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.faceVertexUvs[j].splice(idx, 1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Use unique set of vertices\n\n\t\t\t\t\t\t\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\t\t\t\t\t\t\tthis.vertices = unique;\n\t\t\t\t\t\t\t\t\treturn diff;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromPoints: function setFromPoints(points) {\n\n\t\t\t\t\t\t\t\t\tthis.vertices = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar point = points[i];\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsortFacesByMaterialIndex: function sortFacesByMaterialIndex() {\n\n\t\t\t\t\t\t\t\t\tvar faces = this.faces;\n\t\t\t\t\t\t\t\t\tvar length = faces.length;\n\n\t\t\t\t\t\t\t\t\t// tag faces\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaces[i]._id = i;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// sort faces\n\n\t\t\t\t\t\t\t\t\tfunction materialIndexSort(a, b) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfaces.sort(materialIndexSort);\n\n\t\t\t\t\t\t\t\t\t// sort uvs\n\n\t\t\t\t\t\t\t\t\tvar uvs1 = this.faceVertexUvs[0];\n\t\t\t\t\t\t\t\t\tvar uvs2 = this.faceVertexUvs[1];\n\n\t\t\t\t\t\t\t\t\tvar newUvs1, newUvs2;\n\n\t\t\t\t\t\t\t\t\tif (uvs1 && uvs1.length === length) newUvs1 = [];\n\t\t\t\t\t\t\t\t\tif (uvs2 && uvs2.length === length) newUvs2 = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar id = faces[i]._id;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (newUvs1) newUvs1.push(uvs1[id]);\n\t\t\t\t\t\t\t\t\t\t\t\tif (newUvs2) newUvs2.push(uvs2[id]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (newUvs1) this.faceVertexUvs[0] = newUvs1;\n\t\t\t\t\t\t\t\t\tif (newUvs2) this.faceVertexUvs[1] = newUvs2;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoJSON: function toJSON() {\n\n\t\t\t\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t// standard Geometry serialization\n\n\t\t\t\t\t\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\t\t\t\t\t\tdata.type = this.type;\n\t\t\t\t\t\t\t\t\tif (this.name !== '') data.name = this.name;\n\n\t\t\t\t\t\t\t\t\tif (this.parameters !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var key in parameters) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (parameters[key] !== undefined) data[key] = parameters[key];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar vertices = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < this.vertices.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertex = this.vertices[i];\n\t\t\t\t\t\t\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar faces = [];\n\t\t\t\t\t\t\t\t\tvar normals = [];\n\t\t\t\t\t\t\t\t\tvar normalsHash = {};\n\t\t\t\t\t\t\t\t\tvar colors = [];\n\t\t\t\t\t\t\t\t\tvar colorsHash = {};\n\t\t\t\t\t\t\t\t\tvar uvs = [];\n\t\t\t\t\t\t\t\t\tvar uvsHash = {};\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < this.faces.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar face = this.faces[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar hasMaterial = true;\n\t\t\t\t\t\t\t\t\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\t\t\t\t\t\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\t\t\t\t\t\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar faceType = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaceType = setBit(faceType, 0, 0); // isQuad\n\t\t\t\t\t\t\t\t\t\t\t\tfaceType = setBit(faceType, 1, hasMaterial);\n\t\t\t\t\t\t\t\t\t\t\t\tfaceType = setBit(faceType, 2, hasFaceUv);\n\t\t\t\t\t\t\t\t\t\t\t\tfaceType = setBit(faceType, 3, hasFaceVertexUv);\n\t\t\t\t\t\t\t\t\t\t\t\tfaceType = setBit(faceType, 4, hasFaceNormal);\n\t\t\t\t\t\t\t\t\t\t\t\tfaceType = setBit(faceType, 5, hasFaceVertexNormal);\n\t\t\t\t\t\t\t\t\t\t\t\tfaceType = setBit(faceType, 6, hasFaceColor);\n\t\t\t\t\t\t\t\t\t\t\t\tfaceType = setBit(faceType, 7, hasFaceVertexColor);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(faceType);\n\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(face.a, face.b, face.c);\n\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(face.materialIndex);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasFaceVertexUv) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[0][i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasFaceNormal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(getNormalIndex(face.normal));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasFaceVertexNormal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasFaceColor) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(getColorIndex(face.color));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasFaceVertexColor) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction setBit(value, position, enabled) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn enabled ? value | 1 << position : value & ~(1 << position);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction getNormalIndex(normal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (normalsHash[hash] !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn normalsHash[hash];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tnormalsHash[hash] = normals.length / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn normalsHash[hash];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction getColorIndex(color) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (colorsHash[hash] !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn colorsHash[hash];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsHash[hash] = colors.length;\n\t\t\t\t\t\t\t\t\t\t\t\tcolors.push(color.getHex());\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn colorsHash[hash];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction getUvIndex(uv) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvsHash[hash] !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn uvsHash[hash];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tuvsHash[hash] = uvs.length / 2;\n\t\t\t\t\t\t\t\t\t\t\t\tuvs.push(uv.x, uv.y);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn uvsHash[hash];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdata.data = {};\n\n\t\t\t\t\t\t\t\t\tdata.data.vertices = vertices;\n\t\t\t\t\t\t\t\t\tdata.data.normals = normals;\n\t\t\t\t\t\t\t\t\tif (colors.length > 0) data.data.colors = colors;\n\t\t\t\t\t\t\t\t\tif (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\t\t\t\t\t\t\t\t\tdata.data.faces = faces;\n\n\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\t/*\r\n          // Handle primitives\r\n         \t\t var parameters = this.parameters;\r\n         \t\t if ( parameters !== undefined ) {\r\n         \t\t var values = [];\r\n         \t\t for ( var key in parameters ) {\r\n         \t\t values.push( parameters[ key ] );\r\n         \t\t }\r\n         \t\t var geometry = Object.create( this.constructor.prototype );\r\n          this.constructor.apply( geometry, values );\r\n          return geometry;\r\n         \t\t }\r\n         \t\t return new this.constructor().copy( this );\r\n          */\n\n\t\t\t\t\t\t\t\t\treturn new Geometry().copy(this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source) {\n\n\t\t\t\t\t\t\t\t\tvar i, il, j, jl, k, kl;\n\n\t\t\t\t\t\t\t\t\t// reset\n\n\t\t\t\t\t\t\t\t\tthis.vertices = [];\n\t\t\t\t\t\t\t\t\tthis.colors = [];\n\t\t\t\t\t\t\t\t\tthis.faces = [];\n\t\t\t\t\t\t\t\t\tthis.faceVertexUvs = [[]];\n\t\t\t\t\t\t\t\t\tthis.morphTargets = [];\n\t\t\t\t\t\t\t\t\tthis.morphNormals = [];\n\t\t\t\t\t\t\t\t\tthis.skinWeights = [];\n\t\t\t\t\t\t\t\t\tthis.skinIndices = [];\n\t\t\t\t\t\t\t\t\tthis.lineDistances = [];\n\t\t\t\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t\t\t\t\tthis.boundingSphere = null;\n\n\t\t\t\t\t\t\t\t\t// name\n\n\t\t\t\t\t\t\t\t\tthis.name = source.name;\n\n\t\t\t\t\t\t\t\t\t// vertices\n\n\t\t\t\t\t\t\t\t\tvar vertices = source.vertices;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = vertices.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vertices.push(vertices[i].clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// colors\n\n\t\t\t\t\t\t\t\t\tvar colors = source.colors;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = colors.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.colors.push(colors[i].clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// faces\n\n\t\t\t\t\t\t\t\t\tvar faces = source.faces;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = faces.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.faces.push(faces[i].clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// face vertex uvs\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.faceVertexUvs[i] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.faceVertexUvs[i] = [];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar uvs = faceVertexUvs[j],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    uvsCopy = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (k = 0, kl = uvs.length; k < kl; k++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar uv = uvs[k];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvsCopy.push(uv.clone());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.faceVertexUvs[i].push(uvsCopy);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// morph targets\n\n\t\t\t\t\t\t\t\t\tvar morphTargets = source.morphTargets;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = morphTargets.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphTarget = {};\n\t\t\t\t\t\t\t\t\t\t\t\tmorphTarget.name = morphTargets[i].name;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// vertices\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (morphTargets[i].vertices !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// normals\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (morphTargets[i].normals !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTarget.normals.push(morphTargets[i].normals[j].clone());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.morphTargets.push(morphTarget);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// morph normals\n\n\t\t\t\t\t\t\t\t\tvar morphNormals = source.morphNormals;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = morphNormals.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphNormal = {};\n\n\t\t\t\t\t\t\t\t\t\t\t\t// vertex normals\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (morphNormals[i].vertexNormals !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar srcVertexNormal = morphNormals[i].vertexNormals[j];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar destVertexNormal = {};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphNormal.vertexNormals.push(destVertexNormal);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// face normals\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (morphNormals[i].faceNormals !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.morphNormals.push(morphNormal);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// skin weights\n\n\t\t\t\t\t\t\t\t\tvar skinWeights = source.skinWeights;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = skinWeights.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.skinWeights.push(skinWeights[i].clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// skin indices\n\n\t\t\t\t\t\t\t\t\tvar skinIndices = source.skinIndices;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = skinIndices.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.skinIndices.push(skinIndices[i].clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// line distances\n\n\t\t\t\t\t\t\t\t\tvar lineDistances = source.lineDistances;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, il = lineDistances.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.lineDistances.push(lineDistances[i]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// bounding box\n\n\t\t\t\t\t\t\t\t\tvar boundingBox = source.boundingBox;\n\n\t\t\t\t\t\t\t\t\tif (boundingBox !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox = boundingBox.clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// bounding sphere\n\n\t\t\t\t\t\t\t\t\tvar boundingSphere = source.boundingSphere;\n\n\t\t\t\t\t\t\t\t\tif (boundingSphere !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// update flags\n\n\t\t\t\t\t\t\t\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdispose: function dispose() {\n\n\t\t\t\t\t\t\t\t\tthis.dispatchEvent({ type: 'dispose' });\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author supereggbert / http://www.paulbrunt.co.uk/\r\n    * @author philogb / http://blog.thejit.org/\r\n    * @author mikael emtinger / http://gomo.se/\r\n    * @author egraether / http://egraether.com/\r\n    * @author WestLangley / http://github.com/WestLangley\r\n    */\n\n\t\t\tfunction Vector4(x, y, z, w) {\n\n\t\t\t\t\t\tthis.x = x || 0;\n\t\t\t\t\t\tthis.y = y || 0;\n\t\t\t\t\t\tthis.z = z || 0;\n\t\t\t\t\t\tthis.w = w !== undefined ? w : 1;\n\t\t\t}\n\n\t\t\tObject.assign(Vector4.prototype, {\n\n\t\t\t\t\t\tisVector4: true,\n\n\t\t\t\t\t\tset: function set(x, y, z, w) {\n\n\t\t\t\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\t\t\t\tthis.y = y;\n\t\t\t\t\t\t\t\t\tthis.z = z;\n\t\t\t\t\t\t\t\t\tthis.w = w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetScalar: function setScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\tthis.x = scalar;\n\t\t\t\t\t\t\t\t\tthis.y = scalar;\n\t\t\t\t\t\t\t\t\tthis.z = scalar;\n\t\t\t\t\t\t\t\t\tthis.w = scalar;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetX: function setX(x) {\n\n\t\t\t\t\t\t\t\t\tthis.x = x;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetY: function setY(y) {\n\n\t\t\t\t\t\t\t\t\tthis.y = y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetZ: function setZ(z) {\n\n\t\t\t\t\t\t\t\t\tthis.z = z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetW: function setW(w) {\n\n\t\t\t\t\t\t\t\t\tthis.w = w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetComponent: function setComponent(index, value) {\n\n\t\t\t\t\t\t\t\t\tswitch (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.x = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.y = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.z = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.w = value;break;\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetComponent: function getComponent(index) {\n\n\t\t\t\t\t\t\t\t\tswitch (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.x;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.y;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.z;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.w;\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = v.x;\n\t\t\t\t\t\t\t\t\tthis.y = v.y;\n\t\t\t\t\t\t\t\t\tthis.z = v.z;\n\t\t\t\t\t\t\t\t\tthis.w = v.w !== undefined ? v.w : 1;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tadd: function add(v, w) {\n\n\t\t\t\t\t\t\t\t\tif (w !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.addVectors(v, w);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x += v.x;\n\t\t\t\t\t\t\t\t\tthis.y += v.y;\n\t\t\t\t\t\t\t\t\tthis.z += v.z;\n\t\t\t\t\t\t\t\t\tthis.w += v.w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddScalar: function addScalar(s) {\n\n\t\t\t\t\t\t\t\t\tthis.x += s;\n\t\t\t\t\t\t\t\t\tthis.y += s;\n\t\t\t\t\t\t\t\t\tthis.z += s;\n\t\t\t\t\t\t\t\t\tthis.w += s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddVectors: function addVectors(a, b) {\n\n\t\t\t\t\t\t\t\t\tthis.x = a.x + b.x;\n\t\t\t\t\t\t\t\t\tthis.y = a.y + b.y;\n\t\t\t\t\t\t\t\t\tthis.z = a.z + b.z;\n\t\t\t\t\t\t\t\t\tthis.w = a.w + b.w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddScaledVector: function addScaledVector(v, s) {\n\n\t\t\t\t\t\t\t\t\tthis.x += v.x * s;\n\t\t\t\t\t\t\t\t\tthis.y += v.y * s;\n\t\t\t\t\t\t\t\t\tthis.z += v.z * s;\n\t\t\t\t\t\t\t\t\tthis.w += v.w * s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsub: function sub(v, w) {\n\n\t\t\t\t\t\t\t\t\tif (w !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.subVectors(v, w);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x -= v.x;\n\t\t\t\t\t\t\t\t\tthis.y -= v.y;\n\t\t\t\t\t\t\t\t\tthis.z -= v.z;\n\t\t\t\t\t\t\t\t\tthis.w -= v.w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsubScalar: function subScalar(s) {\n\n\t\t\t\t\t\t\t\t\tthis.x -= s;\n\t\t\t\t\t\t\t\t\tthis.y -= s;\n\t\t\t\t\t\t\t\t\tthis.z -= s;\n\t\t\t\t\t\t\t\t\tthis.w -= s;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsubVectors: function subVectors(a, b) {\n\n\t\t\t\t\t\t\t\t\tthis.x = a.x - b.x;\n\t\t\t\t\t\t\t\t\tthis.y = a.y - b.y;\n\t\t\t\t\t\t\t\t\tthis.z = a.z - b.z;\n\t\t\t\t\t\t\t\t\tthis.w = a.w - b.w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiplyScalar: function multiplyScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\tthis.x *= scalar;\n\t\t\t\t\t\t\t\t\tthis.y *= scalar;\n\t\t\t\t\t\t\t\t\tthis.z *= scalar;\n\t\t\t\t\t\t\t\t\tthis.w *= scalar;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyMatrix4: function applyMatrix4(m) {\n\n\t\t\t\t\t\t\t\t\tvar x = this.x,\n\t\t\t\t\t\t\t\t\t    y = this.y,\n\t\t\t\t\t\t\t\t\t    z = this.z,\n\t\t\t\t\t\t\t\t\t    w = this.w;\n\t\t\t\t\t\t\t\t\tvar e = m.elements;\n\n\t\t\t\t\t\t\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n\t\t\t\t\t\t\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n\t\t\t\t\t\t\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n\t\t\t\t\t\t\t\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdivideScalar: function divideScalar(scalar) {\n\n\t\t\t\t\t\t\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(q) {\n\n\t\t\t\t\t\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t\t\t\t\t\t\t\t// q is assumed to be normalized\n\n\t\t\t\t\t\t\t\t\tthis.w = 2 * Math.acos(q.w);\n\n\t\t\t\t\t\t\t\t\tvar s = Math.sqrt(1 - q.w * q.w);\n\n\t\t\t\t\t\t\t\t\tif (s < 0.0001) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.x = 1;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.y = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.z = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.x = q.x / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.y = q.y / s;\n\t\t\t\t\t\t\t\t\t\t\t\tthis.z = q.z / s;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(m) {\n\n\t\t\t\t\t\t\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t\t\t\t\t\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\t\t\t\t\t\t\tvar angle,\n\t\t\t\t\t\t\t\t\t    x,\n\t\t\t\t\t\t\t\t\t    y,\n\t\t\t\t\t\t\t\t\t    z,\n\t\t\t\t\t\t\t\t\t    // variables for result\n\t\t\t\t\t\t\t\t\tepsilon = 0.01,\n\t\t\t\t\t\t\t\t\t    // margin to allow for rounding errors\n\t\t\t\t\t\t\t\t\tepsilon2 = 0.1,\n\t\t\t\t\t\t\t\t\t    // margin to distinguish between 0 and 180 degrees\n\n\t\t\t\t\t\t\t\t\tte = m.elements,\n\t\t\t\t\t\t\t\t\t    m11 = te[0],\n\t\t\t\t\t\t\t\t\t    m12 = te[4],\n\t\t\t\t\t\t\t\t\t    m13 = te[8],\n\t\t\t\t\t\t\t\t\t    m21 = te[1],\n\t\t\t\t\t\t\t\t\t    m22 = te[5],\n\t\t\t\t\t\t\t\t\t    m23 = te[9],\n\t\t\t\t\t\t\t\t\t    m31 = te[2],\n\t\t\t\t\t\t\t\t\t    m32 = te[6],\n\t\t\t\t\t\t\t\t\t    m33 = te[10];\n\n\t\t\t\t\t\t\t\t\tif (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// singularity found\n\t\t\t\t\t\t\t\t\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t\t\t\t\t\t\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.set(1, 0, 0, 0);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\t\t\t\t\t\t\t\t\t\tangle = Math.PI;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar xx = (m11 + 1) / 2;\n\t\t\t\t\t\t\t\t\t\t\t\tvar yy = (m22 + 1) / 2;\n\t\t\t\t\t\t\t\t\t\t\t\tvar zz = (m33 + 1) / 2;\n\t\t\t\t\t\t\t\t\t\t\t\tvar xy = (m12 + m21) / 4;\n\t\t\t\t\t\t\t\t\t\t\t\tvar xz = (m13 + m31) / 4;\n\t\t\t\t\t\t\t\t\t\t\t\tvar yz = (m23 + m32) / 4;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (xx > yy && xx > zz) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (xx < epsilon) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz = 0.707106781;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx = Math.sqrt(xx);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz = xz / x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (yy > zz) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (yy < epsilon) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz = 0.707106781;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty = Math.sqrt(yy);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz = yz / y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (zz < epsilon) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz = Math.sqrt(zz);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty = yz / z;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.set(x, y, z, angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this; // return 180 deg rotation\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\t\t\t\t\t\t\t\tvar s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n\t\t\t\t\t\t\t\t\tif (Math.abs(s) < 0.001) s = 1;\n\n\t\t\t\t\t\t\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t\t\t\t\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\t\t\t\t\t\t\tthis.x = (m32 - m23) / s;\n\t\t\t\t\t\t\t\t\tthis.y = (m13 - m31) / s;\n\t\t\t\t\t\t\t\t\tthis.z = (m21 - m12) / s;\n\t\t\t\t\t\t\t\t\tthis.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmin: function min(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.min(this.z, v.z);\n\t\t\t\t\t\t\t\t\tthis.w = Math.min(this.w, v.w);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmax: function max(v) {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.max(this.z, v.z);\n\t\t\t\t\t\t\t\t\tthis.w = Math.max(this.w, v.w);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclamp: function clamp(min, max) {\n\n\t\t\t\t\t\t\t\t\t// assumes min < max, componentwise\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\t\t\t\t\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\t\t\t\t\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\n\t\t\t\t\t\t\t\t\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclampScalar: function () {\n\n\t\t\t\t\t\t\t\t\tvar min, max;\n\n\t\t\t\t\t\t\t\t\treturn function clampScalar(minVal, maxVal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (min === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmin = new Vector4();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmax = new Vector4();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin.set(minVal, minVal, minVal, minVal);\n\t\t\t\t\t\t\t\t\t\t\t\tmax.set(maxVal, maxVal, maxVal, maxVal);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.clamp(min, max);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tclampLength: function clampLength(min, max) {\n\n\t\t\t\t\t\t\t\t\tvar length = this.length();\n\n\t\t\t\t\t\t\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfloor: function floor() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.floor(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.floor(this.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.floor(this.z);\n\t\t\t\t\t\t\t\t\tthis.w = Math.floor(this.w);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tceil: function ceil() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.ceil(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.ceil(this.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.ceil(this.z);\n\t\t\t\t\t\t\t\t\tthis.w = Math.ceil(this.w);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tround: function round() {\n\n\t\t\t\t\t\t\t\t\tthis.x = Math.round(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = Math.round(this.y);\n\t\t\t\t\t\t\t\t\tthis.z = Math.round(this.z);\n\t\t\t\t\t\t\t\t\tthis.w = Math.round(this.w);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\troundToZero: function roundToZero() {\n\n\t\t\t\t\t\t\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\t\t\t\t\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\t\t\t\t\t\t\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\t\t\t\t\t\t\t\t\tthis.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnegate: function negate() {\n\n\t\t\t\t\t\t\t\t\tthis.x = -this.x;\n\t\t\t\t\t\t\t\t\tthis.y = -this.y;\n\t\t\t\t\t\t\t\t\tthis.z = -this.z;\n\t\t\t\t\t\t\t\t\tthis.w = -this.w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdot: function dot(v) {\n\n\t\t\t\t\t\t\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlengthSq: function lengthSq() {\n\n\t\t\t\t\t\t\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlength: function length() {\n\n\t\t\t\t\t\t\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmanhattanLength: function manhattanLength() {\n\n\t\t\t\t\t\t\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnormalize: function normalize() {\n\n\t\t\t\t\t\t\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetLength: function setLength(length) {\n\n\t\t\t\t\t\t\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlerp: function lerp(v, alpha) {\n\n\t\t\t\t\t\t\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\t\t\t\t\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\t\t\t\t\t\t\tthis.z += (v.z - this.z) * alpha;\n\t\t\t\t\t\t\t\t\tthis.w += (v.w - this.w) * alpha;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlerpVectors: function lerpVectors(v1, v2, alpha) {\n\n\t\t\t\t\t\t\t\t\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tequals: function equals(v) {\n\n\t\t\t\t\t\t\t\t\treturn v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromArray: function fromArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tthis.x = array[offset];\n\t\t\t\t\t\t\t\t\tthis.y = array[offset + 1];\n\t\t\t\t\t\t\t\t\tthis.z = array[offset + 2];\n\t\t\t\t\t\t\t\t\tthis.w = array[offset + 3];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoArray: function toArray(array, offset) {\n\n\t\t\t\t\t\t\t\t\tif (array === undefined) array = [];\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tarray[offset] = this.x;\n\t\t\t\t\t\t\t\t\tarray[offset + 1] = this.y;\n\t\t\t\t\t\t\t\t\tarray[offset + 2] = this.z;\n\t\t\t\t\t\t\t\t\tarray[offset + 3] = this.w;\n\n\t\t\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.x = attribute.getX(index);\n\t\t\t\t\t\t\t\t\tthis.y = attribute.getY(index);\n\t\t\t\t\t\t\t\t\tthis.z = attribute.getZ(index);\n\t\t\t\t\t\t\t\t\tthis.w = attribute.getW(index);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    */\n\n\t\t\tfunction BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tif (Array.isArray(array)) {\n\n\t\t\t\t\t\t\t\t\tthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.name = '';\n\n\t\t\t\t\t\tthis.array = array;\n\t\t\t\t\t\tthis.itemSize = itemSize;\n\t\t\t\t\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\t\t\t\t\tthis.normalized = normalized === true;\n\n\t\t\t\t\t\tthis.dynamic = false;\n\t\t\t\t\t\tthis.updateRange = { offset: 0, count: -1 };\n\n\t\t\t\t\t\tthis.version = 0;\n\t\t\t}\n\n\t\t\tObject.defineProperty(BufferAttribute.prototype, 'needsUpdate', {\n\n\t\t\t\t\t\tset: function set(value) {\n\n\t\t\t\t\t\t\t\t\tif (value === true) this.version++;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tObject.assign(BufferAttribute.prototype, {\n\n\t\t\t\t\t\tisBufferAttribute: true,\n\n\t\t\t\t\t\tonUploadCallback: function onUploadCallback() {},\n\n\t\t\t\t\t\tsetArray: function setArray(array) {\n\n\t\t\t\t\t\t\t\t\tif (Array.isArray(array)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\n\t\t\t\t\t\t\t\t\tthis.array = array;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetDynamic: function setDynamic(value) {\n\n\t\t\t\t\t\t\t\t\tthis.dynamic = value;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source) {\n\n\t\t\t\t\t\t\t\t\tthis.name = source.name;\n\t\t\t\t\t\t\t\t\tthis.array = new source.array.constructor(source.array);\n\t\t\t\t\t\t\t\t\tthis.itemSize = source.itemSize;\n\t\t\t\t\t\t\t\t\tthis.count = source.count;\n\t\t\t\t\t\t\t\t\tthis.normalized = source.normalized;\n\n\t\t\t\t\t\t\t\t\tthis.dynamic = source.dynamic;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyAt: function copyAt(index1, attribute, index2) {\n\n\t\t\t\t\t\t\t\t\tindex1 *= this.itemSize;\n\t\t\t\t\t\t\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = this.itemSize; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.array[index1 + i] = attribute.array[index2 + i];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyArray: function copyArray(array) {\n\n\t\t\t\t\t\t\t\t\tthis.array.set(array);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyColorsArray: function copyColorsArray(colors) {\n\n\t\t\t\t\t\t\t\t\tvar array = this.array,\n\t\t\t\t\t\t\t\t\t    offset = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = colors.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar color = colors[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (color === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor = new Color();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = color.r;\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = color.g;\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = color.b;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyVector2sArray: function copyVector2sArray(vectors) {\n\n\t\t\t\t\t\t\t\t\tvar array = this.array,\n\t\t\t\t\t\t\t\t\t    offset = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = vectors.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vector = vectors[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (vector === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector = new Vector2();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyVector3sArray: function copyVector3sArray(vectors) {\n\n\t\t\t\t\t\t\t\t\tvar array = this.array,\n\t\t\t\t\t\t\t\t\t    offset = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = vectors.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vector = vectors[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (vector === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector = new Vector3();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.z;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopyVector4sArray: function copyVector4sArray(vectors) {\n\n\t\t\t\t\t\t\t\t\tvar array = this.array,\n\t\t\t\t\t\t\t\t\t    offset = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = vectors.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vector = vectors[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (vector === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector = new Vector4();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.z;\n\t\t\t\t\t\t\t\t\t\t\t\tarray[offset++] = vector.w;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tset: function set(value, offset) {\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) offset = 0;\n\n\t\t\t\t\t\t\t\t\tthis.array.set(value, offset);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetX: function getX(index) {\n\n\t\t\t\t\t\t\t\t\treturn this.array[index * this.itemSize];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetX: function setX(index, x) {\n\n\t\t\t\t\t\t\t\t\tthis.array[index * this.itemSize] = x;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetY: function getY(index) {\n\n\t\t\t\t\t\t\t\t\treturn this.array[index * this.itemSize + 1];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetY: function setY(index, y) {\n\n\t\t\t\t\t\t\t\t\tthis.array[index * this.itemSize + 1] = y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetZ: function getZ(index) {\n\n\t\t\t\t\t\t\t\t\treturn this.array[index * this.itemSize + 2];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetZ: function setZ(index, z) {\n\n\t\t\t\t\t\t\t\t\tthis.array[index * this.itemSize + 2] = z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetW: function getW(index) {\n\n\t\t\t\t\t\t\t\t\treturn this.array[index * this.itemSize + 3];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetW: function setW(index, w) {\n\n\t\t\t\t\t\t\t\t\tthis.array[index * this.itemSize + 3] = w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetXY: function setXY(index, x, y) {\n\n\t\t\t\t\t\t\t\t\tindex *= this.itemSize;\n\n\t\t\t\t\t\t\t\t\tthis.array[index + 0] = x;\n\t\t\t\t\t\t\t\t\tthis.array[index + 1] = y;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetXYZ: function setXYZ(index, x, y, z) {\n\n\t\t\t\t\t\t\t\t\tindex *= this.itemSize;\n\n\t\t\t\t\t\t\t\t\tthis.array[index + 0] = x;\n\t\t\t\t\t\t\t\t\tthis.array[index + 1] = y;\n\t\t\t\t\t\t\t\t\tthis.array[index + 2] = z;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetXYZW: function setXYZW(index, x, y, z, w) {\n\n\t\t\t\t\t\t\t\t\tindex *= this.itemSize;\n\n\t\t\t\t\t\t\t\t\tthis.array[index + 0] = x;\n\t\t\t\t\t\t\t\t\tthis.array[index + 1] = y;\n\t\t\t\t\t\t\t\t\tthis.array[index + 2] = z;\n\t\t\t\t\t\t\t\t\tthis.array[index + 3] = w;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tonUpload: function onUpload(callback) {\n\n\t\t\t\t\t\t\t\t\tthis.onUploadCallback = callback;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor(this.array, this.itemSize).copy(this);\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t//\n\n\t\t\tfunction Int8BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Int8Array(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tInt8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\n\n\t\t\tfunction Uint8BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tUint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\n\n\t\t\tfunction Uint8ClampedBufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tUint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\n\n\t\t\tfunction Int16BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Int16Array(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tInt16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\n\n\t\t\tfunction Uint16BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tUint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\n\n\t\t\tfunction Int32BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Int32Array(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tInt32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\n\n\t\t\tfunction Uint32BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tUint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\n\n\t\t\tfunction Float32BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Float32Array(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tFloat32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\n\n\t\t\tfunction Float64BufferAttribute(array, itemSize, normalized) {\n\n\t\t\t\t\t\tBufferAttribute.call(this, new Float64Array(array), itemSize, normalized);\n\t\t\t}\n\n\t\t\tFloat64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\n\t\t\tFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    */\n\n\t\t\tfunction DirectGeometry() {\n\n\t\t\t\t\t\tthis.vertices = [];\n\t\t\t\t\t\tthis.normals = [];\n\t\t\t\t\t\tthis.colors = [];\n\t\t\t\t\t\tthis.uvs = [];\n\t\t\t\t\t\tthis.uvs2 = [];\n\n\t\t\t\t\t\tthis.groups = [];\n\n\t\t\t\t\t\tthis.morphTargets = {};\n\n\t\t\t\t\t\tthis.skinWeights = [];\n\t\t\t\t\t\tthis.skinIndices = [];\n\n\t\t\t\t\t\t// this.lineDistances = [];\n\n\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t\tthis.boundingSphere = null;\n\n\t\t\t\t\t\t// update flags\n\n\t\t\t\t\t\tthis.verticesNeedUpdate = false;\n\t\t\t\t\t\tthis.normalsNeedUpdate = false;\n\t\t\t\t\t\tthis.colorsNeedUpdate = false;\n\t\t\t\t\t\tthis.uvsNeedUpdate = false;\n\t\t\t\t\t\tthis.groupsNeedUpdate = false;\n\t\t\t}\n\n\t\t\tObject.assign(DirectGeometry.prototype, {\n\n\t\t\t\t\t\tcomputeGroups: function computeGroups(geometry) {\n\n\t\t\t\t\t\t\t\t\tvar group;\n\t\t\t\t\t\t\t\t\tvar groups = [];\n\t\t\t\t\t\t\t\t\tvar materialIndex = undefined;\n\n\t\t\t\t\t\t\t\t\tvar faces = geometry.faces;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < faces.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar face = faces[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t// materials\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (face.materialIndex !== materialIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (group !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroup.count = i * 3 - group.start;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroups.push(group);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroup = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (group !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgroup.count = i * 3 - group.start;\n\t\t\t\t\t\t\t\t\t\t\t\tgroups.push(group);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.groups = groups;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromGeometry: function fromGeometry(geometry) {\n\n\t\t\t\t\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\t\t\t\t\t\t\tvar hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n\t\t\t\t\t\t\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n\n\t\t\t\t\t\t\t\t\t// morphs\n\n\t\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\t\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\t\t\t\t\t\t\t\tvar morphTargetsPosition;\n\n\t\t\t\t\t\t\t\t\tif (morphTargetsLength > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmorphTargetsPosition = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < morphTargetsLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTargetsPosition[i] = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: morphTargets[i].name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata: []\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\t\t\t\t\t\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\t\t\t\t\t\t\t\tvar morphTargetsNormal;\n\n\t\t\t\t\t\t\t\t\tif (morphNormalsLength > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmorphTargetsNormal = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < morphNormalsLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTargetsNormal[i] = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: morphNormals[i].name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata: []\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// skins\n\n\t\t\t\t\t\t\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\t\t\t\t\t\t\tvar skinWeights = geometry.skinWeights;\n\n\t\t\t\t\t\t\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\t\t\t\t\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tif (vertices.length > 0 && faces.length === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < faces.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar face = faces[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (vertexNormals.length === 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar normal = face.normal;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.normals.push(normal, normal, normal);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (vertexColors.length === 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar color = face.color;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.colors.push(color, color, color);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasFaceVertexUv === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[0][i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (vertexUvs !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.uvs.push(new Vector2(), new Vector2(), new Vector2());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasFaceVertexUv2 === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[1][i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (vertexUvs !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// morphs\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0; j < morphTargetsLength; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar morphTarget = morphTargets[j].vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0; j < morphNormalsLength; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar morphNormal = morphNormals[j].vertexNormals[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// skins\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasSkinIndices) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (hasSkinWeights) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.computeGroups(geometry);\n\n\t\t\t\t\t\t\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\t\t\t\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author mrdoob / http://mrdoob.com/\r\n    */\n\n\t\t\tfunction arrayMax(array) {\n\n\t\t\t\t\t\tif (array.length === 0) return -Infinity;\n\n\t\t\t\t\t\tvar max = array[0];\n\n\t\t\t\t\t\tfor (var i = 1, l = array.length; i < l; ++i) {\n\n\t\t\t\t\t\t\t\t\tif (array[i] > max) max = array[i];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn max;\n\t\t\t}\n\n\t\t\t/**\r\n    * @author alteredq / http://alteredqualia.com/\r\n    * @author mrdoob / http://mrdoob.com/\r\n    */\n\n\t\t\tvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\n\t\t\tfunction BufferGeometry() {\n\n\t\t\t\t\t\tObject.defineProperty(this, 'id', { value: bufferGeometryId += 2 });\n\n\t\t\t\t\t\tthis.uuid = _Math.generateUUID();\n\n\t\t\t\t\t\tthis.name = '';\n\t\t\t\t\t\tthis.type = 'BufferGeometry';\n\n\t\t\t\t\t\tthis.index = null;\n\t\t\t\t\t\tthis.attributes = {};\n\n\t\t\t\t\t\tthis.morphAttributes = {};\n\n\t\t\t\t\t\tthis.groups = [];\n\n\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t\tthis.boundingSphere = null;\n\n\t\t\t\t\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\t\t\t\t\tthis.userData = {};\n\t\t\t}\n\n\t\t\tBufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n\n\t\t\t\t\t\tconstructor: BufferGeometry,\n\n\t\t\t\t\t\tisBufferGeometry: true,\n\n\t\t\t\t\t\tgetIndex: function getIndex() {\n\n\t\t\t\t\t\t\t\t\treturn this.index;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetIndex: function setIndex(index) {\n\n\t\t\t\t\t\t\t\t\tif (Array.isArray(index)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.index = index;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddAttribute: function addAttribute(name, attribute) {\n\n\t\t\t\t\t\t\t\t\tif (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (name === 'index') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setIndex(attribute);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.attributes[name] = attribute;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetAttribute: function getAttribute(name) {\n\n\t\t\t\t\t\t\t\t\treturn this.attributes[name];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tremoveAttribute: function removeAttribute(name) {\n\n\t\t\t\t\t\t\t\t\tdelete this.attributes[name];\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddGroup: function addGroup(start, count, materialIndex) {\n\n\t\t\t\t\t\t\t\t\tthis.groups.push({\n\n\t\t\t\t\t\t\t\t\t\t\t\tstart: start,\n\t\t\t\t\t\t\t\t\t\t\t\tcount: count,\n\t\t\t\t\t\t\t\t\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclearGroups: function clearGroups() {\n\n\t\t\t\t\t\t\t\t\tthis.groups = [];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetDrawRange: function setDrawRange(start, count) {\n\n\t\t\t\t\t\t\t\t\tthis.drawRange.start = start;\n\t\t\t\t\t\t\t\t\tthis.drawRange.count = count;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tapplyMatrix: function applyMatrix(matrix) {\n\n\t\t\t\t\t\t\t\t\tvar position = this.attributes.position;\n\n\t\t\t\t\t\t\t\t\tif (position !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.applyToBufferAttribute(position);\n\t\t\t\t\t\t\t\t\t\t\t\tposition.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar normal = this.attributes.normal;\n\n\t\t\t\t\t\t\t\t\tif (normal !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n\t\t\t\t\t\t\t\t\t\t\t\tnormalMatrix.applyToBufferAttribute(normal);\n\t\t\t\t\t\t\t\t\t\t\t\tnormal.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.boundingBox !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.computeBoundingBox();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.boundingSphere !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.computeBoundingSphere();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\trotateX: function () {\n\n\t\t\t\t\t\t\t\t\t// rotate geometry around world x-axis\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function rotateX(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeRotationX(angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\trotateY: function () {\n\n\t\t\t\t\t\t\t\t\t// rotate geometry around world y-axis\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function rotateY(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeRotationY(angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\trotateZ: function () {\n\n\t\t\t\t\t\t\t\t\t// rotate geometry around world z-axis\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function rotateZ(angle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeRotationZ(angle);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttranslate: function () {\n\n\t\t\t\t\t\t\t\t\t// translate geometry\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function translate(x, y, z) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeTranslation(x, y, z);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tscale: function () {\n\n\t\t\t\t\t\t\t\t\t// scale geometry\n\n\t\t\t\t\t\t\t\t\tvar m1 = new Matrix4();\n\n\t\t\t\t\t\t\t\t\treturn function scale(x, y, z) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tm1.makeScale(x, y, z);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(m1);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tlookAt: function () {\n\n\t\t\t\t\t\t\t\t\tvar obj = new Object3D();\n\n\t\t\t\t\t\t\t\t\treturn function lookAt(vector) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tobj.lookAt(vector);\n\n\t\t\t\t\t\t\t\t\t\t\t\tobj.updateMatrix();\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.applyMatrix(obj.matrix);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tcenter: function () {\n\n\t\t\t\t\t\t\t\t\tvar offset = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function center() {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox.getCenter(offset).negate();\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.translate(offset.x, offset.y, offset.z);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tsetFromObject: function setFromObject(object) {\n\n\t\t\t\t\t\t\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\t\t\t\t\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\t\t\t\t\t\tif (object.isPoints || object.isLine) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n\t\t\t\t\t\t\t\t\t\t\t\tvar colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('position', positions.copyVector3sArray(geometry.vertices));\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('color', colors.copyColorsArray(geometry.colors));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.boundingSphere !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.boundingBox !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (object.isMesh) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometry && geometry.isGeometry) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.fromGeometry(geometry);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetFromPoints: function setFromPoints(points) {\n\n\t\t\t\t\t\t\t\t\tvar position = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar point = points[i];\n\t\t\t\t\t\t\t\t\t\t\t\tposition.push(point.x, point.y, point.z || 0);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.addAttribute('position', new Float32BufferAttribute(position, 3));\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tupdateFromObject: function updateFromObject(object) {\n\n\t\t\t\t\t\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\t\t\t\t\t\tif (object.isMesh) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.elementsNeedUpdate === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirect = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (direct === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.fromGeometry(geometry);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\t\t\t\t\t\t\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\t\t\t\t\t\t\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\t\t\t\t\t\t\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\t\t\t\t\t\t\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry = direct;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar attribute;\n\n\t\t\t\t\t\t\t\t\tif (geometry.verticesNeedUpdate === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tattribute = this.attributes.position;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (attribute !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.copyVector3sArray(geometry.vertices);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.normalsNeedUpdate === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tattribute = this.attributes.normal;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (attribute !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.copyVector3sArray(geometry.normals);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.colorsNeedUpdate === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tattribute = this.attributes.color;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (attribute !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.copyColorsArray(geometry.colors);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.uvsNeedUpdate) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tattribute = this.attributes.uv;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (attribute !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.copyVector2sArray(geometry.uvs);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.lineDistancesNeedUpdate) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (attribute !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.copyArray(geometry.lineDistances);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.groupsNeedUpdate) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.computeGroups(object.geometry);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.groups = geometry.groups;\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromGeometry: function fromGeometry(geometry) {\n\n\t\t\t\t\t\t\t\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);\n\n\t\t\t\t\t\t\t\t\treturn this.fromDirectGeometry(geometry.__directGeometry);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromDirectGeometry: function fromDirectGeometry(geometry) {\n\n\t\t\t\t\t\t\t\t\tvar positions = new Float32Array(geometry.vertices.length * 3);\n\t\t\t\t\t\t\t\t\tthis.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n\t\t\t\t\t\t\t\t\tif (geometry.normals.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar normals = new Float32Array(geometry.normals.length * 3);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.colors.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar colors = new Float32Array(geometry.colors.length * 3);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.uvs.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar uvs = new Float32Array(geometry.uvs.length * 2);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.uvs2.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar uvs2 = new Float32Array(geometry.uvs2.length * 2);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// groups\n\n\t\t\t\t\t\t\t\t\tthis.groups = geometry.groups;\n\n\t\t\t\t\t\t\t\t\t// morphs\n\n\t\t\t\t\t\t\t\t\tfor (var name in geometry.morphTargets) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array = [];\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets[name];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = morphTargets.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar morphTarget = morphTargets[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tarray.push(attribute.copyVector3sArray(morphTarget.data));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.morphAttributes[name] = array;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// skinning\n\n\t\t\t\t\t\t\t\t\tif (geometry.skinIndices.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.skinWeights.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tif (geometry.boundingSphere !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.boundingBox !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeBoundingBox: function computeBoundingBox() {\n\n\t\t\t\t\t\t\t\t\tif (this.boundingBox === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox = new Box3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar position = this.attributes.position;\n\n\t\t\t\t\t\t\t\t\tif (position !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox.setFromBufferAttribute(position);\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox.makeEmpty();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeBoundingSphere: function () {\n\n\t\t\t\t\t\t\t\t\tvar box = new Box3();\n\t\t\t\t\t\t\t\t\tvar vector = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function computeBoundingSphere() {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.boundingSphere === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingSphere = new Sphere();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar position = this.attributes.position;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (position) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbox.setFromBufferAttribute(position);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbox.getCenter(center);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, il = position.count; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector.x = position.getX(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector.y = position.getY(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector.z = position.getZ(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isNaN(this.boundingSphere.radius)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\tcomputeFaceNormals: function computeFaceNormals() {\n\n\t\t\t\t\t\t\t\t\t// backwards compatibility\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeVertexNormals: function computeVertexNormals() {\n\n\t\t\t\t\t\t\t\t\tvar index = this.index;\n\t\t\t\t\t\t\t\t\tvar attributes = this.attributes;\n\n\t\t\t\t\t\t\t\t\tif (attributes.position) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (attributes.normal === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// reset existing normals to zero\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, il = array.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tarray[i] = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vA, vB, vC;\n\t\t\t\t\t\t\t\t\t\t\t\tvar pA = new Vector3(),\n\t\t\t\t\t\t\t\t\t\t\t\t    pB = new Vector3(),\n\t\t\t\t\t\t\t\t\t\t\t\t    pC = new Vector3();\n\t\t\t\t\t\t\t\t\t\t\t\tvar cb = new Vector3(),\n\t\t\t\t\t\t\t\t\t\t\t\t    ab = new Vector3();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// indexed elements\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, il = index.count; i < il; i += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvA = indices[i + 0] * 3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvB = indices[i + 1] * 3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvC = indices[i + 2] * 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpA.fromArray(positions, vA);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpB.fromArray(positions, vB);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpC.fromArray(positions, vC);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb.subVectors(pC, pB);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tab.subVectors(pA, pB);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb.cross(ab);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vA] += cb.x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vA + 1] += cb.y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vA + 2] += cb.z;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vB] += cb.x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vB + 1] += cb.y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vB + 2] += cb.z;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vC] += cb.x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vC + 1] += cb.y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[vC + 2] += cb.z;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, il = positions.length; i < il; i += 9) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpA.fromArray(positions, i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpB.fromArray(positions, i + 3);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpC.fromArray(positions, i + 6);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb.subVectors(pC, pB);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tab.subVectors(pA, pB);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb.cross(ab);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i] = cb.x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i + 1] = cb.y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i + 2] = cb.z;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i + 3] = cb.x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i + 4] = cb.y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i + 5] = cb.z;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i + 6] = cb.x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i + 7] = cb.y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i + 8] = cb.z;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.normalizeNormals();\n\n\t\t\t\t\t\t\t\t\t\t\t\tattributes.normal.needsUpdate = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmerge: function merge(geometry, offset) {\n\n\t\t\t\t\t\t\t\t\tif (!(geometry && geometry.isBufferGeometry)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (offset === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\toffset = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar attributes = this.attributes;\n\n\t\t\t\t\t\t\t\t\tfor (var key in attributes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.attributes[key] === undefined) continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar attribute1 = attributes[key];\n\t\t\t\t\t\t\t\t\t\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar attribute2 = geometry.attributes[key];\n\t\t\t\t\t\t\t\t\t\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattributeArray1[j] = attributeArray2[i];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnormalizeNormals: function () {\n\n\t\t\t\t\t\t\t\t\tvar vector = new Vector3();\n\n\t\t\t\t\t\t\t\t\treturn function normalizeNormals() {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar normals = this.attributes.normal;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, il = normals.count; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector.x = normals.getX(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector.y = normals.getY(i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector.z = normals.getZ(i);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvector.normalize();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals.setXYZ(i, vector.x, vector.y, vector.z);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}(),\n\n\t\t\t\t\t\ttoNonIndexed: function toNonIndexed() {\n\n\t\t\t\t\t\t\t\t\tfunction convertBufferAttribute(attribute, indices) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\t\t\t\t\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array2 = new array.constructor(indices.length * itemSize);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar index = 0,\n\t\t\t\t\t\t\t\t\t\t\t\t    index2 = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = indices.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex = indices[i] * itemSize;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0; j < itemSize; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tarray2[index2++] = array[index++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn new BufferAttribute(array2, itemSize);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tif (this.index === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar geometry2 = new BufferGeometry();\n\n\t\t\t\t\t\t\t\t\tvar indices = this.index.array;\n\t\t\t\t\t\t\t\t\tvar attributes = this.attributes;\n\n\t\t\t\t\t\t\t\t\t// attributes\n\n\t\t\t\t\t\t\t\t\tfor (var name in attributes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar attribute = attributes[name];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar newAttribute = convertBufferAttribute(attribute, indices);\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry2.addAttribute(name, newAttribute);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// morph attributes\n\n\t\t\t\t\t\t\t\t\tvar morphAttributes = this.morphAttributes;\n\n\t\t\t\t\t\t\t\t\tfor (name in morphAttributes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphArray = [];\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, il = morphAttribute.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar attribute = morphAttribute[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar newAttribute = convertBufferAttribute(attribute, indices);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphArray.push(newAttribute);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry2.morphAttributes[name] = morphArray;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// groups\n\n\t\t\t\t\t\t\t\t\tvar groups = this.groups;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = groups.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar group = groups[i];\n\t\t\t\t\t\t\t\t\t\t\t\tgeometry2.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn geometry2;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoJSON: function toJSON() {\n\n\t\t\t\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t// standard BufferGeometry serialization\n\n\t\t\t\t\t\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\t\t\t\t\t\tdata.type = this.type;\n\t\t\t\t\t\t\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\t\t\t\t\t\t\tif (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n\t\t\t\t\t\t\t\t\tif (this.parameters !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar parameters = this.parameters;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var key in parameters) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (parameters[key] !== undefined) data[key] = parameters[key];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tdata.data = { attributes: {} };\n\n\t\t\t\t\t\t\t\t\tvar index = this.index;\n\n\t\t\t\t\t\t\t\t\tif (index !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array = Array.prototype.slice.call(index.array);\n\n\t\t\t\t\t\t\t\t\t\t\t\tdata.data.index = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tarray: array\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar attributes = this.attributes;\n\n\t\t\t\t\t\t\t\t\tfor (var key in attributes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar attribute = attributes[key];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array = Array.prototype.slice.call(attribute.array);\n\n\t\t\t\t\t\t\t\t\t\t\t\tdata.data.attributes[key] = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tarray: array,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar groups = this.groups;\n\n\t\t\t\t\t\t\t\t\tif (groups.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tdata.data.groups = JSON.parse(JSON.stringify(groups));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar boundingSphere = this.boundingSphere;\n\n\t\t\t\t\t\t\t\t\tif (boundingSphere !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\t/*\r\n          // Handle primitives\r\n         \t\t var parameters = this.parameters;\r\n         \t\t if ( parameters !== undefined ) {\r\n         \t\t var values = [];\r\n         \t\t for ( var key in parameters ) {\r\n         \t\t values.push( parameters[ key ] );\r\n         \t\t }\r\n         \t\t var geometry = Object.create( this.constructor.prototype );\r\n          this.constructor.apply( geometry, values );\r\n          return geometry;\r\n         \t\t }\r\n         \t\t return new this.constructor().copy( this );\r\n          */\n\n\t\t\t\t\t\t\t\t\treturn new BufferGeometry().copy(this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source) {\n\n\t\t\t\t\t\t\t\t\tvar name, i, l;\n\n\t\t\t\t\t\t\t\t\t// reset\n\n\t\t\t\t\t\t\t\t\tthis.index = null;\n\t\t\t\t\t\t\t\t\tthis.attributes = {};\n\t\t\t\t\t\t\t\t\tthis.morphAttributes = {};\n\t\t\t\t\t\t\t\t\tthis.groups = [];\n\t\t\t\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t\t\t\t\tthis.boundingSphere = null;\n\n\t\t\t\t\t\t\t\t\t// name\n\n\t\t\t\t\t\t\t\t\tthis.name = source.name;\n\n\t\t\t\t\t\t\t\t\t// index\n\n\t\t\t\t\t\t\t\t\tvar index = source.index;\n\n\t\t\t\t\t\t\t\t\tif (index !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.setIndex(index.clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// attributes\n\n\t\t\t\t\t\t\t\t\tvar attributes = source.attributes;\n\n\t\t\t\t\t\t\t\t\tfor (name in attributes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar attribute = attributes[name];\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addAttribute(name, attribute.clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// morph attributes\n\n\t\t\t\t\t\t\t\t\tvar morphAttributes = source.morphAttributes;\n\n\t\t\t\t\t\t\t\t\tfor (name in morphAttributes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array = [];\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, l = morphAttribute.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tarray.push(morphAttribute[i].clone());\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.morphAttributes[name] = array;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// groups\n\n\t\t\t\t\t\t\t\t\tvar groups = source.groups;\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, l = groups.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar group = groups[i];\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// bounding box\n\n\t\t\t\t\t\t\t\t\tvar boundingBox = source.boundingBox;\n\n\t\t\t\t\t\t\t\t\tif (boundingBox !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingBox = boundingBox.clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// bounding sphere\n\n\t\t\t\t\t\t\t\t\tvar boundingSphere = source.boundingSphere;\n\n\t\t\t\t\t\t\t\t\tif (boundingSphere !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// draw range\n\n\t\t\t\t\t\t\t\t\tthis.drawRange.start = source.drawRange.start;\n\t\t\t\t\t\t\t\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t\t\t\t\t\t\t\t// user data\n\n\t\t\t\t\t\t\t\t\tthis.userData = source.userData;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdispose: function dispose() {\n\n\t\t\t\t\t\t\t\t\tthis.dispatchEvent({ type: 'dispose' });\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author Mugen87 / https://github.com/Mugen87\r\n    * Port from https://github.com/mapbox/earcut (v2.1.2)\r\n    */\n\n\t\t\tvar Earcut = {\n\n\t\t\t\t\t\ttriangulate: function triangulate(data, holeIndices, dim) {\n\n\t\t\t\t\t\t\t\t\tdim = dim || 2;\n\n\t\t\t\t\t\t\t\t\tvar hasHoles = holeIndices && holeIndices.length,\n\t\t\t\t\t\t\t\t\t    outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n\t\t\t\t\t\t\t\t\t    outerNode = linkedList(data, 0, outerLen, dim, true),\n\t\t\t\t\t\t\t\t\t    triangles = [];\n\n\t\t\t\t\t\t\t\t\tif (!outerNode) return triangles;\n\n\t\t\t\t\t\t\t\t\tvar minX, minY, maxX, maxY, x, y, invSize;\n\n\t\t\t\t\t\t\t\t\tif (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n\t\t\t\t\t\t\t\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\n\t\t\t\t\t\t\t\t\tif (data.length > 80 * dim) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tminX = maxX = data[0];\n\t\t\t\t\t\t\t\t\t\t\t\tminY = maxY = data[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = dim; i < outerLen; i += dim) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx = data[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty = data[i + 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (x < minX) minX = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (y < minY) minY = y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\t\t\t\t\t\t\t\t\t\t\t\tinvSize = Math.max(maxX - minX, maxY - minY);\n\t\t\t\t\t\t\t\t\t\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tearcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n\t\t\t\t\t\t\t\t\treturn triangles;\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t// create a circular doubly linked list from polygon points in the specified winding order\n\n\t\t\tfunction linkedList(data, start, end, dim, clockwise) {\n\n\t\t\t\t\t\tvar i, last;\n\n\t\t\t\t\t\tif (clockwise === signedArea(data, start, end, dim) > 0) {\n\n\t\t\t\t\t\t\t\t\tfor (i = start; i < end; i += dim) {\n\t\t\t\t\t\t\t\t\t\t\t\tlast = insertNode(i, data[i], data[i + 1], last);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tfor (i = end - dim; i >= start; i -= dim) {\n\t\t\t\t\t\t\t\t\t\t\t\tlast = insertNode(i, data[i], data[i + 1], last);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (last && equals(last, last.next)) {\n\n\t\t\t\t\t\t\t\t\tremoveNode(last);\n\t\t\t\t\t\t\t\t\tlast = last.next;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn last;\n\t\t\t}\n\n\t\t\t// eliminate colinear or duplicate points\n\n\t\t\tfunction filterPoints(start, end) {\n\n\t\t\t\t\t\tif (!start) return start;\n\t\t\t\t\t\tif (!end) end = start;\n\n\t\t\t\t\t\tvar p = start,\n\t\t\t\t\t\t    again;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tagain = false;\n\n\t\t\t\t\t\t\t\t\tif (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tremoveNode(p);\n\t\t\t\t\t\t\t\t\t\t\t\tp = end = p.prev;\n\t\t\t\t\t\t\t\t\t\t\t\tif (p === p.next) break;\n\t\t\t\t\t\t\t\t\t\t\t\tagain = true;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (again || p !== end);\n\n\t\t\t\t\t\treturn end;\n\t\t\t}\n\n\t\t\t// main ear slicing loop which triangulates a polygon (given as a linked list)\n\n\t\t\tfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n\n\t\t\t\t\t\tif (!ear) return;\n\n\t\t\t\t\t\t// interlink polygon nodes in z-order\n\n\t\t\t\t\t\tif (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n\t\t\t\t\t\tvar stop = ear,\n\t\t\t\t\t\t    prev,\n\t\t\t\t\t\t    next;\n\n\t\t\t\t\t\t// iterate through ears, slicing them one by one\n\n\t\t\t\t\t\twhile (ear.prev !== ear.next) {\n\n\t\t\t\t\t\t\t\t\tprev = ear.prev;\n\t\t\t\t\t\t\t\t\tnext = ear.next;\n\n\t\t\t\t\t\t\t\t\tif (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// cut off the triangle\n\t\t\t\t\t\t\t\t\t\t\t\ttriangles.push(prev.i / dim);\n\t\t\t\t\t\t\t\t\t\t\t\ttriangles.push(ear.i / dim);\n\t\t\t\t\t\t\t\t\t\t\t\ttriangles.push(next.i / dim);\n\n\t\t\t\t\t\t\t\t\t\t\t\tremoveNode(ear);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// skipping the next vertice leads to less sliver triangles\n\t\t\t\t\t\t\t\t\t\t\t\tear = next.next;\n\t\t\t\t\t\t\t\t\t\t\t\tstop = next.next;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tear = next;\n\n\t\t\t\t\t\t\t\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\n\t\t\t\t\t\t\t\t\tif (ear === stop) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// try filtering points and slicing again\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!pass) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tearcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (pass === 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tear = cureLocalIntersections(ear, triangles, dim);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tearcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (pass === 2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsplitEarcut(ear, triangles, dim, minX, minY, invSize);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check whether a polygon node forms a valid ear with adjacent nodes\n\n\t\t\tfunction isEar(ear) {\n\n\t\t\t\t\t\tvar a = ear.prev,\n\t\t\t\t\t\t    b = ear,\n\t\t\t\t\t\t    c = ear.next;\n\n\t\t\t\t\t\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n\t\t\t\t\t\t// now make sure we don't have other points inside the potential ear\n\t\t\t\t\t\tvar p = ear.next.next;\n\n\t\t\t\t\t\twhile (p !== ear.prev) {\n\n\t\t\t\t\t\t\t\t\tif (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction isEarHashed(ear, minX, minY, invSize) {\n\n\t\t\t\t\t\tvar a = ear.prev,\n\t\t\t\t\t\t    b = ear,\n\t\t\t\t\t\t    c = ear.next;\n\n\t\t\t\t\t\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n\t\t\t\t\t\t// triangle bbox; min & max are calculated like this for speed\n\n\t\t\t\t\t\tvar minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n\t\t\t\t\t\t    minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n\t\t\t\t\t\t    maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n\t\t\t\t\t\t    maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n\n\t\t\t\t\t\t// z-order range for the current triangle bbox;\n\n\t\t\t\t\t\tvar minZ = zOrder(minTX, minTY, minX, minY, invSize),\n\t\t\t\t\t\t    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n\t\t\t\t\t\t// first look for points inside the triangle in increasing z-order\n\n\t\t\t\t\t\tvar p = ear.nextZ;\n\n\t\t\t\t\t\twhile (p && p.z <= maxZ) {\n\n\t\t\t\t\t\t\t\t\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\t\t\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// then look for points in decreasing z-order\n\n\t\t\t\t\t\tp = ear.prevZ;\n\n\t\t\t\t\t\twhile (p && p.z >= minZ) {\n\n\t\t\t\t\t\t\t\t\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\n\t\t\t\t\t\t\t\t\tp = p.prevZ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// go through all polygon nodes and cure small local self-intersections\n\n\t\t\tfunction cureLocalIntersections(start, triangles, dim) {\n\n\t\t\t\t\t\tvar p = start;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tvar a = p.prev,\n\t\t\t\t\t\t\t\t\t    b = p.next.next;\n\n\t\t\t\t\t\t\t\t\tif (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttriangles.push(a.i / dim);\n\t\t\t\t\t\t\t\t\t\t\t\ttriangles.push(p.i / dim);\n\t\t\t\t\t\t\t\t\t\t\t\ttriangles.push(b.i / dim);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// remove two nodes involved\n\n\t\t\t\t\t\t\t\t\t\t\t\tremoveNode(p);\n\t\t\t\t\t\t\t\t\t\t\t\tremoveNode(p.next);\n\n\t\t\t\t\t\t\t\t\t\t\t\tp = start = b;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t} while (p !== start);\n\n\t\t\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\t// try splitting polygon into two and triangulate them independently\n\n\t\t\tfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n\n\t\t\t\t\t\t// look for a valid diagonal that divides the polygon into two\n\n\t\t\t\t\t\tvar a = start;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tvar b = a.next.next;\n\n\t\t\t\t\t\t\t\t\twhile (b !== a.prev) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (a.i !== b.i && isValidDiagonal(a, b)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// split the polygon in two by the diagonal\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar c = splitPolygon(a, b);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// filter colinear points around the cuts\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ta = filterPoints(a, a.next);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = filterPoints(c, c.next);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// run earcut on each half\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tearcutLinked(a, triangles, dim, minX, minY, invSize);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tearcutLinked(c, triangles, dim, minX, minY, invSize);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tb = b.next;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ta = a.next;\n\t\t\t\t\t\t} while (a !== start);\n\t\t\t}\n\n\t\t\t// link every hole into the outer loop, producing a single-ring polygon without holes\n\n\t\t\tfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n\n\t\t\t\t\t\tvar queue = [],\n\t\t\t\t\t\t    i,\n\t\t\t\t\t\t    len,\n\t\t\t\t\t\t    start,\n\t\t\t\t\t\t    end,\n\t\t\t\t\t\t    list;\n\n\t\t\t\t\t\tfor (i = 0, len = holeIndices.length; i < len; i++) {\n\n\t\t\t\t\t\t\t\t\tstart = holeIndices[i] * dim;\n\t\t\t\t\t\t\t\t\tend = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n\t\t\t\t\t\t\t\t\tlist = linkedList(data, start, end, dim, false);\n\t\t\t\t\t\t\t\t\tif (list === list.next) list.steiner = true;\n\t\t\t\t\t\t\t\t\tqueue.push(getLeftmost(list));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tqueue.sort(compareX);\n\n\t\t\t\t\t\t// process holes from left to right\n\n\t\t\t\t\t\tfor (i = 0; i < queue.length; i++) {\n\n\t\t\t\t\t\t\t\t\teliminateHole(queue[i], outerNode);\n\t\t\t\t\t\t\t\t\touterNode = filterPoints(outerNode, outerNode.next);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn outerNode;\n\t\t\t}\n\n\t\t\tfunction compareX(a, b) {\n\n\t\t\t\t\t\treturn a.x - b.x;\n\t\t\t}\n\n\t\t\t// find a bridge between vertices that connects hole with an outer ring and and link it\n\n\t\t\tfunction eliminateHole(hole, outerNode) {\n\n\t\t\t\t\t\touterNode = findHoleBridge(hole, outerNode);\n\n\t\t\t\t\t\tif (outerNode) {\n\n\t\t\t\t\t\t\t\t\tvar b = splitPolygon(outerNode, hole);\n\n\t\t\t\t\t\t\t\t\tfilterPoints(b, b.next);\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t// David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n\t\t\tfunction findHoleBridge(hole, outerNode) {\n\n\t\t\t\t\t\tvar p = outerNode,\n\t\t\t\t\t\t    hx = hole.x,\n\t\t\t\t\t\t    hy = hole.y,\n\t\t\t\t\t\t    qx = -Infinity,\n\t\t\t\t\t\t    m;\n\n\t\t\t\t\t\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t\t\t\t\t\t// segment's endpoint with lesser x will be potential connection point\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tif (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (x <= hx && x > qx) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tqx = x;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (x === hx) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (hy === p.y) return p;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (hy === p.next.y) return p.next;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t} while (p !== outerNode);\n\n\t\t\t\t\t\tif (!m) return null;\n\n\t\t\t\t\t\tif (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n\t\t\t\t\t\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t\t\t\t\t\t// if there are no points found, we have a valid connection;\n\t\t\t\t\t\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\t\t\t\t\t\tvar stop = m,\n\t\t\t\t\t\t    mx = m.x,\n\t\t\t\t\t\t    my = m.y,\n\t\t\t\t\t\t    tanMin = Infinity,\n\t\t\t\t\t\t    tan;\n\n\t\t\t\t\t\tp = m.next;\n\n\t\t\t\t\t\twhile (p !== stop) {\n\n\t\t\t\t\t\t\t\t\tif (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tm = p;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttanMin = tan;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn m;\n\t\t\t}\n\n\t\t\t// interlink polygon nodes in z-order\n\n\t\t\tfunction indexCurve(start, minX, minY, invSize) {\n\n\t\t\t\t\t\tvar p = start;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tif (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n\t\t\t\t\t\t\t\t\tp.prevZ = p.prev;\n\t\t\t\t\t\t\t\t\tp.nextZ = p.next;\n\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t} while (p !== start);\n\n\t\t\t\t\t\tp.prevZ.nextZ = null;\n\t\t\t\t\t\tp.prevZ = null;\n\n\t\t\t\t\t\tsortLinked(p);\n\t\t\t}\n\n\t\t\t// Simon Tatham's linked list merge sort algorithm\n\t\t\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n\t\t\tfunction sortLinked(list) {\n\n\t\t\t\t\t\tvar i,\n\t\t\t\t\t\t    p,\n\t\t\t\t\t\t    q,\n\t\t\t\t\t\t    e,\n\t\t\t\t\t\t    tail,\n\t\t\t\t\t\t    numMerges,\n\t\t\t\t\t\t    pSize,\n\t\t\t\t\t\t    qSize,\n\t\t\t\t\t\t    inSize = 1;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tp = list;\n\t\t\t\t\t\t\t\t\tlist = null;\n\t\t\t\t\t\t\t\t\ttail = null;\n\t\t\t\t\t\t\t\t\tnumMerges = 0;\n\n\t\t\t\t\t\t\t\t\twhile (p) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnumMerges++;\n\t\t\t\t\t\t\t\t\t\t\t\tq = p;\n\t\t\t\t\t\t\t\t\t\t\t\tpSize = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < inSize; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpSize++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!q) break;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tqSize = inSize;\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (pSize > 0 || qSize > 0 && q) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\te = p;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpSize--;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\te = q;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tqSize--;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (tail) tail.nextZ = e;else list = e;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\te.prevZ = tail;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttail = e;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tp = q;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttail.nextZ = null;\n\t\t\t\t\t\t\t\t\tinSize *= 2;\n\t\t\t\t\t\t} while (numMerges > 1);\n\n\t\t\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\t// z-order of a point given coords and inverse of the longer side of data bbox\n\n\t\t\tfunction zOrder(x, y, minX, minY, invSize) {\n\n\t\t\t\t\t\t// coords are transformed into non-negative 15-bit integer range\n\n\t\t\t\t\t\tx = 32767 * (x - minX) * invSize;\n\t\t\t\t\t\ty = 32767 * (y - minY) * invSize;\n\n\t\t\t\t\t\tx = (x | x << 8) & 0x00FF00FF;\n\t\t\t\t\t\tx = (x | x << 4) & 0x0F0F0F0F;\n\t\t\t\t\t\tx = (x | x << 2) & 0x33333333;\n\t\t\t\t\t\tx = (x | x << 1) & 0x55555555;\n\n\t\t\t\t\t\ty = (y | y << 8) & 0x00FF00FF;\n\t\t\t\t\t\ty = (y | y << 4) & 0x0F0F0F0F;\n\t\t\t\t\t\ty = (y | y << 2) & 0x33333333;\n\t\t\t\t\t\ty = (y | y << 1) & 0x55555555;\n\n\t\t\t\t\t\treturn x | y << 1;\n\t\t\t}\n\n\t\t\t// find the leftmost node of a polygon ring\n\n\t\t\tfunction getLeftmost(start) {\n\n\t\t\t\t\t\tvar p = start,\n\t\t\t\t\t\t    leftmost = start;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tif (p.x < leftmost.x) leftmost = p;\n\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t} while (p !== start);\n\n\t\t\t\t\t\treturn leftmost;\n\t\t\t}\n\n\t\t\t// check if a point lies within a convex triangle\n\n\t\t\tfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n\n\t\t\t\t\t\treturn (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n\t\t\t}\n\n\t\t\t// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n\t\t\tfunction isValidDiagonal(a, b) {\n\n\t\t\t\t\t\treturn a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n\t\t\t}\n\n\t\t\t// signed area of a triangle\n\n\t\t\tfunction area(p, q, r) {\n\n\t\t\t\t\t\treturn (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n\t\t\t}\n\n\t\t\t// check if two points are equal\n\n\t\t\tfunction equals(p1, p2) {\n\n\t\t\t\t\t\treturn p1.x === p2.x && p1.y === p2.y;\n\t\t\t}\n\n\t\t\t// check if two segments intersect\n\n\t\t\tfunction intersects(p1, q1, p2, q2) {\n\n\t\t\t\t\t\tif (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;\n\n\t\t\t\t\t\treturn area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n\t\t\t}\n\n\t\t\t// check if a polygon diagonal intersects any polygon segments\n\n\t\t\tfunction intersectsPolygon(a, b) {\n\n\t\t\t\t\t\tvar p = a;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tif (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t} while (p !== a);\n\n\t\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// check if a polygon diagonal is locally inside the polygon\n\n\t\t\tfunction locallyInside(a, b) {\n\n\t\t\t\t\t\treturn area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n\t\t\t}\n\n\t\t\t// check if the middle point of a polygon diagonal is inside the polygon\n\n\t\t\tfunction middleInside(a, b) {\n\n\t\t\t\t\t\tvar p = a,\n\t\t\t\t\t\t    inside = false,\n\t\t\t\t\t\t    px = (a.x + b.x) / 2,\n\t\t\t\t\t\t    py = (a.y + b.y) / 2;\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\t\t\tif (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tinside = !inside;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\t} while (p !== a);\n\n\t\t\t\t\t\treturn inside;\n\t\t\t}\n\n\t\t\t// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n\t\t\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n\t\t\tfunction splitPolygon(a, b) {\n\n\t\t\t\t\t\tvar a2 = new Node(a.i, a.x, a.y),\n\t\t\t\t\t\t    b2 = new Node(b.i, b.x, b.y),\n\t\t\t\t\t\t    an = a.next,\n\t\t\t\t\t\t    bp = b.prev;\n\n\t\t\t\t\t\ta.next = b;\n\t\t\t\t\t\tb.prev = a;\n\n\t\t\t\t\t\ta2.next = an;\n\t\t\t\t\t\tan.prev = a2;\n\n\t\t\t\t\t\tb2.next = a2;\n\t\t\t\t\t\ta2.prev = b2;\n\n\t\t\t\t\t\tbp.next = b2;\n\t\t\t\t\t\tb2.prev = bp;\n\n\t\t\t\t\t\treturn b2;\n\t\t\t}\n\n\t\t\t// create a node and optionally link it with previous one (in a circular doubly linked list)\n\n\t\t\tfunction insertNode(i, x, y, last) {\n\n\t\t\t\t\t\tvar p = new Node(i, x, y);\n\n\t\t\t\t\t\tif (!last) {\n\n\t\t\t\t\t\t\t\t\tp.prev = p;\n\t\t\t\t\t\t\t\t\tp.next = p;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tp.next = last.next;\n\t\t\t\t\t\t\t\t\tp.prev = last;\n\t\t\t\t\t\t\t\t\tlast.next.prev = p;\n\t\t\t\t\t\t\t\t\tlast.next = p;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\tfunction removeNode(p) {\n\n\t\t\t\t\t\tp.next.prev = p.prev;\n\t\t\t\t\t\tp.prev.next = p.next;\n\n\t\t\t\t\t\tif (p.prevZ) p.prevZ.nextZ = p.nextZ;\n\t\t\t\t\t\tif (p.nextZ) p.nextZ.prevZ = p.prevZ;\n\t\t\t}\n\n\t\t\tfunction Node(i, x, y) {\n\n\t\t\t\t\t\t// vertice index in coordinates array\n\t\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t\t// vertex coordinates\n\t\t\t\t\t\tthis.x = x;\n\t\t\t\t\t\tthis.y = y;\n\n\t\t\t\t\t\t// previous and next vertice nodes in a polygon ring\n\t\t\t\t\t\tthis.prev = null;\n\t\t\t\t\t\tthis.next = null;\n\n\t\t\t\t\t\t// z-order curve value\n\t\t\t\t\t\tthis.z = null;\n\n\t\t\t\t\t\t// previous and next nodes in z-order\n\t\t\t\t\t\tthis.prevZ = null;\n\t\t\t\t\t\tthis.nextZ = null;\n\n\t\t\t\t\t\t// indicates whether this is a steiner point\n\t\t\t\t\t\tthis.steiner = false;\n\t\t\t}\n\n\t\t\tfunction signedArea(data, start, end, dim) {\n\n\t\t\t\t\t\tvar sum = 0;\n\n\t\t\t\t\t\tfor (var i = start, j = end - dim; i < end; i += dim) {\n\n\t\t\t\t\t\t\t\t\tsum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n\t\t\t\t\t\t\t\t\tj = i;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn sum;\n\t\t\t}\n\n\t\t\t/**\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    */\n\n\t\t\tvar ShapeUtils = {\n\n\t\t\t\t\t\t// calculate area of the contour polygon\n\n\t\t\t\t\t\tarea: function area(contour) {\n\n\t\t\t\t\t\t\t\t\tvar n = contour.length;\n\t\t\t\t\t\t\t\t\tvar a = 0.0;\n\n\t\t\t\t\t\t\t\t\tfor (var p = n - 1, q = 0; q < n; p = q++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ta += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn a * 0.5;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tisClockWise: function isClockWise(pts) {\n\n\t\t\t\t\t\t\t\t\treturn ShapeUtils.area(pts) < 0;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttriangulateShape: function triangulateShape(contour, holes) {\n\n\t\t\t\t\t\t\t\t\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\t\t\t\t\t\t\t\tvar holeIndices = []; // array of hole indices\n\t\t\t\t\t\t\t\t\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\t\t\t\t\t\t\t\tremoveDupEndPts(contour);\n\t\t\t\t\t\t\t\t\taddContour(vertices, contour);\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tvar holeIndex = contour.length;\n\n\t\t\t\t\t\t\t\t\tholes.forEach(removeDupEndPts);\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < holes.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tholeIndices.push(holeIndex);\n\t\t\t\t\t\t\t\t\t\t\t\tholeIndex += holes[i].length;\n\t\t\t\t\t\t\t\t\t\t\t\taddContour(vertices, holes[i]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tvar triangles = Earcut.triangulate(vertices, holeIndices);\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < triangles.length; i += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaces.push(triangles.slice(i, i + 3));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn faces;\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tfunction removeDupEndPts(points) {\n\n\t\t\t\t\t\tvar l = points.length;\n\n\t\t\t\t\t\tif (l > 2 && points[l - 1].equals(points[0])) {\n\n\t\t\t\t\t\t\t\t\tpoints.pop();\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction addContour(vertices, contour) {\n\n\t\t\t\t\t\tfor (var i = 0; i < contour.length; i++) {\n\n\t\t\t\t\t\t\t\t\tvertices.push(contour[i].x);\n\t\t\t\t\t\t\t\t\tvertices.push(contour[i].y);\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\r\n    * @author jonobr1 / http://jonobr1.com\r\n    * @author Mugen87 / https://github.com/Mugen87\r\n    */\n\n\t\t\t// ShapeGeometry\n\n\t\t\tfunction ShapeGeometry(shapes, curveSegments) {\n\n\t\t\t\t\t\tGeometry.call(this);\n\n\t\t\t\t\t\tthis.type = 'ShapeGeometry';\n\n\t\t\t\t\t\tif ((typeof curveSegments === 'undefined' ? 'undefined' : _typeof(curveSegments)) === 'object') {\n\n\t\t\t\t\t\t\t\t\tconsole.warn('THREE.ShapeGeometry: Options parameter has been removed.');\n\n\t\t\t\t\t\t\t\t\tcurveSegments = curveSegments.curveSegments;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.parameters = {\n\t\t\t\t\t\t\t\t\tshapes: shapes,\n\t\t\t\t\t\t\t\t\tcurveSegments: curveSegments\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));\n\t\t\t\t\t\tthis.mergeVertices();\n\t\t\t}\n\n\t\t\tShapeGeometry.prototype = Object.create(Geometry.prototype);\n\t\t\tShapeGeometry.prototype.constructor = ShapeGeometry;\n\n\t\t\tShapeGeometry.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Geometry.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tvar shapes = this.parameters.shapes;\n\n\t\t\t\t\t\treturn toJSON(shapes, data);\n\t\t\t};\n\n\t\t\t// ShapeBufferGeometry\n\n\t\t\tfunction ShapeBufferGeometry(shapes, curveSegments) {\n\n\t\t\t\t\t\tBufferGeometry.call(this);\n\n\t\t\t\t\t\tthis.type = 'ShapeBufferGeometry';\n\n\t\t\t\t\t\tthis.parameters = {\n\t\t\t\t\t\t\t\t\tshapes: shapes,\n\t\t\t\t\t\t\t\t\tcurveSegments: curveSegments\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tcurveSegments = curveSegments || 12;\n\n\t\t\t\t\t\t// buffers\n\n\t\t\t\t\t\tvar indices = [];\n\t\t\t\t\t\tvar vertices = [];\n\t\t\t\t\t\tvar normals = [];\n\t\t\t\t\t\tvar uvs = [];\n\n\t\t\t\t\t\t// helper variables\n\n\t\t\t\t\t\tvar groupStart = 0;\n\t\t\t\t\t\tvar groupCount = 0;\n\n\t\t\t\t\t\t// allow single and array values for \"shapes\" parameter\n\n\t\t\t\t\t\tif (Array.isArray(shapes) === false) {\n\n\t\t\t\t\t\t\t\t\taddShape(shapes);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < shapes.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\taddShape(shapes[i]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n\t\t\t\t\t\t\t\t\t\t\t\tgroupStart += groupCount;\n\t\t\t\t\t\t\t\t\t\t\t\tgroupCount = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// build geometry\n\n\t\t\t\t\t\tthis.setIndex(indices);\n\t\t\t\t\t\tthis.addAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\t\t\t\tthis.addAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\t\t\t\tthis.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n\t\t\t\t\t\t// helper functions\n\n\t\t\t\t\t\tfunction addShape(shape) {\n\n\t\t\t\t\t\t\t\t\tvar i, l, shapeHole;\n\n\t\t\t\t\t\t\t\t\tvar indexOffset = vertices.length / 3;\n\t\t\t\t\t\t\t\t\tvar points = shape.extractPoints(curveSegments);\n\n\t\t\t\t\t\t\t\t\tvar shapeVertices = points.shape;\n\t\t\t\t\t\t\t\t\tvar shapeHoles = points.holes;\n\n\t\t\t\t\t\t\t\t\t// check direction of vertices\n\n\t\t\t\t\t\t\t\t\tif (ShapeUtils.isClockWise(shapeVertices) === false) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tshapeVertices = shapeVertices.reverse();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, l = shapeHoles.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tshapeHole = shapeHoles[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (ShapeUtils.isClockWise(shapeHole) === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshapeHoles[i] = shapeHole.reverse();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);\n\n\t\t\t\t\t\t\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, l = shapeHoles.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tshapeHole = shapeHoles[i];\n\t\t\t\t\t\t\t\t\t\t\t\tshapeVertices = shapeVertices.concat(shapeHole);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// vertices, normals, uvs\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, l = shapeVertices.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar vertex = shapeVertices[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, 0);\n\t\t\t\t\t\t\t\t\t\t\t\tnormals.push(0, 0, 1);\n\t\t\t\t\t\t\t\t\t\t\t\tuvs.push(vertex.x, vertex.y); // world uvs\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// incides\n\n\t\t\t\t\t\t\t\t\tfor (i = 0, l = faces.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar face = faces[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar a = face[0] + indexOffset;\n\t\t\t\t\t\t\t\t\t\t\t\tvar b = face[1] + indexOffset;\n\t\t\t\t\t\t\t\t\t\t\t\tvar c = face[2] + indexOffset;\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices.push(a, b, c);\n\t\t\t\t\t\t\t\t\t\t\t\tgroupCount += 3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\n\t\t\tShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\n\n\t\t\tShapeBufferGeometry.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = BufferGeometry.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tvar shapes = this.parameters.shapes;\n\n\t\t\t\t\t\treturn toJSON(shapes, data);\n\t\t\t};\n\n\t\t\t//\n\n\t\t\tfunction toJSON(shapes, data) {\n\n\t\t\t\t\t\tdata.shapes = [];\n\n\t\t\t\t\t\tif (Array.isArray(shapes)) {\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = shapes.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar shape = shapes[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tdata.shapes.push(shape.uuid);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tdata.shapes.push(shapes.uuid);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t/**\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    *\r\n    * Creates extruded geometry from a path shape.\r\n    *\r\n    * parameters = {\r\n    *\r\n    *  curveSegments: <int>, // number of points on the curves\r\n    *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n    *  depth: <float>, // Depth to extrude the shape\r\n    *\r\n    *  bevelEnabled: <bool>, // turn on bevel\r\n    *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n    *  bevelSize: <float>, // how far from shape outline is bevel\r\n    *  bevelSegments: <int>, // number of bevel layers\r\n    *\r\n    *  extrudePath: <THREE.Curve> // curve to extrude shape along\r\n    *\r\n    *  UVGenerator: <Object> // object that provides UV generator functions\r\n    *\r\n    * }\r\n    */\n\n\t\t\t// ExtrudeGeometry\n\n\t\t\tfunction ExtrudeGeometry(shapes, options) {\n\n\t\t\t\t\t\tGeometry.call(this);\n\n\t\t\t\t\t\tthis.type = 'ExtrudeGeometry';\n\n\t\t\t\t\t\tthis.parameters = {\n\t\t\t\t\t\t\t\t\tshapes: shapes,\n\t\t\t\t\t\t\t\t\toptions: options\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));\n\t\t\t\t\t\tthis.mergeVertices();\n\t\t\t}\n\n\t\t\tExtrudeGeometry.prototype = Object.create(Geometry.prototype);\n\t\t\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\n\t\t\tExtrudeGeometry.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Geometry.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tvar shapes = this.parameters.shapes;\n\t\t\t\t\t\tvar options = this.parameters.options;\n\n\t\t\t\t\t\treturn toJSON$1(shapes, options, data);\n\t\t\t};\n\n\t\t\t// ExtrudeBufferGeometry\n\n\t\t\tfunction ExtrudeBufferGeometry(shapes, options) {\n\n\t\t\t\t\t\tBufferGeometry.call(this);\n\n\t\t\t\t\t\tthis.type = 'ExtrudeBufferGeometry';\n\n\t\t\t\t\t\tthis.parameters = {\n\t\t\t\t\t\t\t\t\tshapes: shapes,\n\t\t\t\t\t\t\t\t\toptions: options\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tshapes = Array.isArray(shapes) ? shapes : [shapes];\n\n\t\t\t\t\t\tvar scope = this;\n\n\t\t\t\t\t\tvar verticesArray = [];\n\t\t\t\t\t\tvar uvArray = [];\n\n\t\t\t\t\t\tfor (var i = 0, l = shapes.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\tvar shape = shapes[i];\n\t\t\t\t\t\t\t\t\taddShape(shape);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// build geometry\n\n\t\t\t\t\t\tthis.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n\t\t\t\t\t\tthis.addAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n\n\t\t\t\t\t\tthis.computeVertexNormals();\n\n\t\t\t\t\t\t// functions\n\n\t\t\t\t\t\tfunction addShape(shape) {\n\n\t\t\t\t\t\t\t\t\tvar placeholder = [];\n\n\t\t\t\t\t\t\t\t\t// options\n\n\t\t\t\t\t\t\t\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\t\t\t\t\t\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\t\t\t\t\t\t\t\tvar depth = options.depth !== undefined ? options.depth : 100;\n\n\t\t\t\t\t\t\t\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\t\t\t\t\t\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\t\t\t\t\t\t\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\t\t\t\t\t\t\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\t\t\t\t\t\t\tvar extrudePath = options.extrudePath;\n\n\t\t\t\t\t\t\t\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t\t\t\t\t\t\t// deprecated options\n\n\t\t\t\t\t\t\t\t\tif (options.amount !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\n\t\t\t\t\t\t\t\t\t\t\t\tdepth = options.amount;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//\n\n\t\t\t\t\t\t\t\t\tvar extrudePts,\n\t\t\t\t\t\t\t\t\t    extrudeByPath = false;\n\t\t\t\t\t\t\t\t\tvar splineTube, binormal, normal, position2;\n\n\t\t\t\t\t\t\t\t\tif (extrudePath) {\n\n\t\t\t\t\t\t\t\t\t\t\t\textrudePts = extrudePath.getSpacedPoints(steps);\n\n\t\t\t\t\t\t\t\t\t\t\t\textrudeByPath = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t\t\t\t\t\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t\t\t\t\t\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\t\t\t\t\t\t\t\t\tsplineTube = extrudePath.computeFrenetFrames(steps, false);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\t\t\t\t\t\t\t\t\tbinormal = new Vector3();\n\t\t\t\t\t\t\t\t\t\t\t\tnormal = new Vector3();\n\t\t\t\t\t\t\t\t\t\t\t\tposition2 = new Vector3();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\t\t\t\t\t\t\tif (!bevelEnabled) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tbevelSegments = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tbevelThickness = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tbevelSize = 0;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Variables initialization\n\n\t\t\t\t\t\t\t\t\tvar ahole, h, hl; // looping of holes\n\n\t\t\t\t\t\t\t\t\tvar shapePoints = shape.extractPoints(curveSegments);\n\n\t\t\t\t\t\t\t\t\tvar vertices = shapePoints.shape;\n\t\t\t\t\t\t\t\t\tvar holes = shapePoints.holes;\n\n\t\t\t\t\t\t\t\t\tvar reverse = !ShapeUtils.isClockWise(vertices);\n\n\t\t\t\t\t\t\t\t\tif (reverse) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (h = 0, hl = holes.length; h < hl; h++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tahole = holes[h];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (ShapeUtils.isClockWise(ahole)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tholes[h] = ahole.reverse();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar faces = ShapeUtils.triangulateShape(vertices, holes);\n\n\t\t\t\t\t\t\t\t\t/* Vertices */\n\n\t\t\t\t\t\t\t\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\t\t\t\t\t\t\tfor (h = 0, hl = holes.length; h < hl; h++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tahole = holes[h];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertices = vertices.concat(ahole);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction scalePt2(pt, vec, size) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!vec) console.error(\"THREE.ExtrudeGeometry: vec does not exist\");\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn vec.clone().multiplyScalar(size).add(pt);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar b,\n\t\t\t\t\t\t\t\t\t    bs,\n\t\t\t\t\t\t\t\t\t    t,\n\t\t\t\t\t\t\t\t\t    z,\n\t\t\t\t\t\t\t\t\t    vert,\n\t\t\t\t\t\t\t\t\t    vlen = vertices.length,\n\t\t\t\t\t\t\t\t\t    face,\n\t\t\t\t\t\t\t\t\t    flen = faces.length;\n\n\t\t\t\t\t\t\t\t\t// Find directions for point movement\n\n\n\t\t\t\t\t\t\t\t\tfunction getBevelVec(inPt, inPrev, inNext) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t\t\t\t\t\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t\t\t\t\t\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t\t\t\t\t\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t\t\t\t\t\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t\t\t\t\t\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\t\t\t\t\t\t\t\t    v_prev_y = inPt.y - inPrev.y;\n\t\t\t\t\t\t\t\t\t\t\t\tvar v_next_x = inNext.x - inPt.x,\n\t\t\t\t\t\t\t\t\t\t\t\t    v_next_y = inNext.y - inPt.y;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// check for collinear edges\n\t\t\t\t\t\t\t\t\t\t\t\tvar collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Math.abs(collinear0) > Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// not collinear\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v_prev_len = Math.sqrt(v_prev_lensq);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ptNextShift_x = inNext.x - v_next_y / v_next_len;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ptNextShift_y = inNext.y + v_next_x / v_next_len;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (v_trans_lensq <= 2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn new Vector2(v_trans_x, v_trans_y);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_trans_lensq / 2);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar direction_eq = false; // assumes: opposite\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (v_prev_x > Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (v_next_x > Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (v_prev_x < -Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (v_next_x < -Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (direction_eq) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv_trans_x = -v_prev_y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_prev_lensq);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_prev_lensq / 2);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar contourMovements = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (j === il) j = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tif (k === il) k = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\t\t\t\t\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\t\t\t\t\t\t\t\t\tcontourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar holesMovements = [],\n\t\t\t\t\t\t\t\t\t    oneHoleMovements,\n\t\t\t\t\t\t\t\t\t    verticesMovements = contourMovements.concat();\n\n\t\t\t\t\t\t\t\t\tfor (h = 0, hl = holes.length; h < hl; h++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tahole = holes[h];\n\n\t\t\t\t\t\t\t\t\t\t\t\toneHoleMovements = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (j === il) j = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (k === il) k = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tholesMovements.push(oneHoleMovements);\n\t\t\t\t\t\t\t\t\t\t\t\tverticesMovements = verticesMovements.concat(oneHoleMovements);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\t\t\t\t\t\t\tfor (b = 0; b < bevelSegments; b++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tt = b / bevelSegments;\n\t\t\t\t\t\t\t\t\t\t\t\tz = bevelThickness * Math.cos(t * Math.PI / 2);\n\t\t\t\t\t\t\t\t\t\t\t\tbs = bevelSize * Math.sin(t * Math.PI / 2);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// contract shape\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, il = contour.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvert = scalePt2(contour[i], contourMovements[i], bs);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(vert.x, vert.y, -z);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// expand holes\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (h = 0, hl = holes.length; h < hl; h++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tahole = holes[h];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toneHoleMovements = holesMovements[h];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, il = ahole.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(vert.x, vert.y, -z);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbs = bevelSize;\n\n\t\t\t\t\t\t\t\t\t// Back facing vertices\n\n\t\t\t\t\t\t\t\t\tfor (i = 0; i < vlen; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!extrudeByPath) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(vert.x, vert.y, 0);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbinormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tposition2.copy(extrudePts[0]).add(normal).add(binormal);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(position2.x, position2.y, position2.z);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Add stepped vertices...\n\t\t\t\t\t\t\t\t\t// Including front facing vertices\n\n\t\t\t\t\t\t\t\t\tvar s;\n\n\t\t\t\t\t\t\t\t\tfor (s = 1; s <= steps; s++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < vlen; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!extrudeByPath) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(vert.x, vert.y, depth / steps * s);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbinormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tposition2.copy(extrudePts[s]).add(normal).add(binormal);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(position2.x, position2.y, position2.z);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Add bevel segments planes\n\n\t\t\t\t\t\t\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\t\t\t\t\t\t\tfor (b = bevelSegments - 1; b >= 0; b--) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tt = b / bevelSegments;\n\t\t\t\t\t\t\t\t\t\t\t\tz = bevelThickness * Math.cos(t * Math.PI / 2);\n\t\t\t\t\t\t\t\t\t\t\t\tbs = bevelSize * Math.sin(t * Math.PI / 2);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// contract shape\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, il = contour.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvert = scalePt2(contour[i], contourMovements[i], bs);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(vert.x, vert.y, depth + z);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// expand holes\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (h = 0, hl = holes.length; h < hl; h++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tahole = holes[h];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toneHoleMovements = holesMovements[h];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0, il = ahole.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!extrudeByPath) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(vert.x, vert.y, depth + z);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t/* Faces */\n\n\t\t\t\t\t\t\t\t\t// Top and bottom faces\n\n\t\t\t\t\t\t\t\t\tbuildLidFaces();\n\n\t\t\t\t\t\t\t\t\t// Sides faces\n\n\t\t\t\t\t\t\t\t\tbuildSideFaces();\n\n\t\t\t\t\t\t\t\t\t/////  Internal functions\n\n\t\t\t\t\t\t\t\t\tfunction buildLidFaces() {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar start = verticesArray.length / 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (bevelEnabled) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar offset = vlen * layer;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < flen; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface = faces[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf3(face[2] + offset, face[1] + offset, face[0] + offset);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Top faces\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < flen; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface = faces[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf3(face[0] + offset, face[1] + offset, face[2] + offset);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < flen; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface = faces[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf3(face[2], face[1], face[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Top faces\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < flen; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tface = faces[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tscope.addGroup(start, verticesArray.length / 3 - start, 0);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\t\t\t\t\t\t\tfunction buildSideFaces() {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar start = verticesArray.length / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar layeroffset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tsidewalls(contour, layeroffset);\n\t\t\t\t\t\t\t\t\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (h = 0, hl = holes.length; h < hl; h++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tahole = holes[h];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsidewalls(ahole, layeroffset);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//, true\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlayeroffset += ahole.length;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tscope.addGroup(start, verticesArray.length / 3 - start, 1);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction sidewalls(contour, layeroffset) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar j, k;\n\t\t\t\t\t\t\t\t\t\t\t\ti = contour.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (--i >= 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tj = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tk = i - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (k < 0) k = contour.length - 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar s = 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    sl = steps + bevelSegments * 2;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (s = 0; s < sl; s++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar slen2 = vlen * (s + 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    b = layeroffset + k + slen1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    c = layeroffset + k + slen2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    d = layeroffset + j + slen2;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf4(a, b, c, d);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction v(x, y, z) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tplaceholder.push(x);\n\t\t\t\t\t\t\t\t\t\t\t\tplaceholder.push(y);\n\t\t\t\t\t\t\t\t\t\t\t\tplaceholder.push(z);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction f3(a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(a);\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(b);\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(c);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[0]);\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[2]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction f4(a, b, c, d) {\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(a);\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(b);\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(d);\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(b);\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(c);\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex(d);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar nextIndex = verticesArray.length / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tvar uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[0]);\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[2]);\n\t\t\t\t\t\t\t\t\t\t\t\taddUV(uvs[3]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction addVertex(index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 0]);\n\t\t\t\t\t\t\t\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 2]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfunction addUV(vector2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tuvArray.push(vector2.x);\n\t\t\t\t\t\t\t\t\t\t\t\tuvArray.push(vector2.y);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\n\t\t\tExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\n\n\t\t\tExtrudeBufferGeometry.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = BufferGeometry.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tvar shapes = this.parameters.shapes;\n\t\t\t\t\t\tvar options = this.parameters.options;\n\n\t\t\t\t\t\treturn toJSON$1(shapes, options, data);\n\t\t\t};\n\n\t\t\t//\n\n\t\t\tvar WorldUVGenerator = {\n\n\t\t\t\t\t\tgenerateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {\n\n\t\t\t\t\t\t\t\t\tvar a_x = vertices[indexA * 3];\n\t\t\t\t\t\t\t\t\tvar a_y = vertices[indexA * 3 + 1];\n\t\t\t\t\t\t\t\t\tvar b_x = vertices[indexB * 3];\n\t\t\t\t\t\t\t\t\tvar b_y = vertices[indexB * 3 + 1];\n\t\t\t\t\t\t\t\t\tvar c_x = vertices[indexC * 3];\n\t\t\t\t\t\t\t\t\tvar c_y = vertices[indexC * 3 + 1];\n\n\t\t\t\t\t\t\t\t\treturn [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgenerateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {\n\n\t\t\t\t\t\t\t\t\tvar a_x = vertices[indexA * 3];\n\t\t\t\t\t\t\t\t\tvar a_y = vertices[indexA * 3 + 1];\n\t\t\t\t\t\t\t\t\tvar a_z = vertices[indexA * 3 + 2];\n\t\t\t\t\t\t\t\t\tvar b_x = vertices[indexB * 3];\n\t\t\t\t\t\t\t\t\tvar b_y = vertices[indexB * 3 + 1];\n\t\t\t\t\t\t\t\t\tvar b_z = vertices[indexB * 3 + 2];\n\t\t\t\t\t\t\t\t\tvar c_x = vertices[indexC * 3];\n\t\t\t\t\t\t\t\t\tvar c_y = vertices[indexC * 3 + 1];\n\t\t\t\t\t\t\t\t\tvar c_z = vertices[indexC * 3 + 2];\n\t\t\t\t\t\t\t\t\tvar d_x = vertices[indexD * 3];\n\t\t\t\t\t\t\t\t\tvar d_y = vertices[indexD * 3 + 1];\n\t\t\t\t\t\t\t\t\tvar d_z = vertices[indexD * 3 + 2];\n\n\t\t\t\t\t\t\t\t\tif (Math.abs(a_y - b_y) < 0.01) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tfunction toJSON$1(shapes, options, data) {\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tdata.shapes = [];\n\n\t\t\t\t\t\tif (Array.isArray(shapes)) {\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = shapes.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar shape = shapes[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tdata.shapes.push(shape.uuid);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tdata.shapes.push(shapes.uuid);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tif (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n\n\t\t\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t/**\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    * Extensible curve object\r\n    *\r\n    * Some common of curve methods:\r\n    * .getPoint( t, optionalTarget ), .getTangent( t )\r\n    * .getPointAt( u, optionalTarget ), .getTangentAt( u )\r\n    * .getPoints(), .getSpacedPoints()\r\n    * .getLength()\r\n    * .updateArcLengths()\r\n    *\r\n    * This following curves inherit from THREE.Curve:\r\n    *\r\n    * -- 2D curves --\r\n    * THREE.ArcCurve\r\n    * THREE.CubicBezierCurve\r\n    * THREE.EllipseCurve\r\n    * THREE.LineCurve\r\n    * THREE.QuadraticBezierCurve\r\n    * THREE.SplineCurve\r\n    *\r\n    * -- 3D curves --\r\n    * THREE.CatmullRomCurve3\r\n    * THREE.CubicBezierCurve3\r\n    * THREE.LineCurve3\r\n    * THREE.QuadraticBezierCurve3\r\n    *\r\n    * A series of curves can be represented as a THREE.CurvePath.\r\n    *\r\n    **/\n\n\t\t\t/**************************************************************\r\n    *\tAbstract Curve base class\r\n    **************************************************************/\n\n\t\t\tfunction Curve() {\n\n\t\t\t\t\t\tthis.type = 'Curve';\n\n\t\t\t\t\t\tthis.arcLengthDivisions = 200;\n\t\t\t}\n\n\t\t\tObject.assign(Curve.prototype, {\n\n\t\t\t\t\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t\t\t\t\t//\t- t [0 .. 1]\n\n\t\t\t\t\t\tgetPoint: function getPoint() /* t, optionalTarget */{\n\n\t\t\t\t\t\t\t\t\tconsole.warn('THREE.Curve: .getPoint() not implemented.');\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Get point at relative position in curve according to arc length\n\t\t\t\t\t\t// - u [0 .. 1]\n\n\t\t\t\t\t\tgetPointAt: function getPointAt(u, optionalTarget) {\n\n\t\t\t\t\t\t\t\t\tvar t = this.getUtoTmapping(u);\n\t\t\t\t\t\t\t\t\treturn this.getPoint(t, optionalTarget);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Get sequence of points using getPoint( t )\n\n\t\t\t\t\t\tgetPoints: function getPoints(divisions) {\n\n\t\t\t\t\t\t\t\t\tif (divisions === undefined) divisions = 5;\n\n\t\t\t\t\t\t\t\t\tvar points = [];\n\n\t\t\t\t\t\t\t\t\tfor (var d = 0; d <= divisions; d++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoints.push(this.getPoint(d / divisions));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn points;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Get sequence of points using getPointAt( u )\n\n\t\t\t\t\t\tgetSpacedPoints: function getSpacedPoints(divisions) {\n\n\t\t\t\t\t\t\t\t\tif (divisions === undefined) divisions = 5;\n\n\t\t\t\t\t\t\t\t\tvar points = [];\n\n\t\t\t\t\t\t\t\t\tfor (var d = 0; d <= divisions; d++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoints.push(this.getPointAt(d / divisions));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn points;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Get total curve arc length\n\n\t\t\t\t\t\tgetLength: function getLength() {\n\n\t\t\t\t\t\t\t\t\tvar lengths = this.getLengths();\n\t\t\t\t\t\t\t\t\treturn lengths[lengths.length - 1];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Get list of cumulative segment lengths\n\n\t\t\t\t\t\tgetLengths: function getLengths(divisions) {\n\n\t\t\t\t\t\t\t\t\tif (divisions === undefined) divisions = this.arcLengthDivisions;\n\n\t\t\t\t\t\t\t\t\tif (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.cacheArcLengths;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.needsUpdate = false;\n\n\t\t\t\t\t\t\t\t\tvar cache = [];\n\t\t\t\t\t\t\t\t\tvar current,\n\t\t\t\t\t\t\t\t\t    last = this.getPoint(0);\n\t\t\t\t\t\t\t\t\tvar p,\n\t\t\t\t\t\t\t\t\t    sum = 0;\n\n\t\t\t\t\t\t\t\t\tcache.push(0);\n\n\t\t\t\t\t\t\t\t\tfor (p = 1; p <= divisions; p++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrent = this.getPoint(p / divisions);\n\t\t\t\t\t\t\t\t\t\t\t\tsum += current.distanceTo(last);\n\t\t\t\t\t\t\t\t\t\t\t\tcache.push(sum);\n\t\t\t\t\t\t\t\t\t\t\t\tlast = current;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.cacheArcLengths = cache;\n\n\t\t\t\t\t\t\t\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tupdateArcLengths: function updateArcLengths() {\n\n\t\t\t\t\t\t\t\t\tthis.needsUpdate = true;\n\t\t\t\t\t\t\t\t\tthis.getLengths();\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\t\t\t\t\t\tgetUtoTmapping: function getUtoTmapping(u, distance) {\n\n\t\t\t\t\t\t\t\t\tvar arcLengths = this.getLengths();\n\n\t\t\t\t\t\t\t\t\tvar i = 0,\n\t\t\t\t\t\t\t\t\t    il = arcLengths.length;\n\n\t\t\t\t\t\t\t\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\t\t\t\t\t\t\t\tif (distance) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttargetArcLength = distance;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttargetArcLength = u * arcLengths[il - 1];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\t\t\t\t\t\t\t\tvar low = 0,\n\t\t\t\t\t\t\t\t\t    high = il - 1,\n\t\t\t\t\t\t\t\t\t    comparison;\n\n\t\t\t\t\t\t\t\t\twhile (low <= high) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ti = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\t\t\t\t\t\t\t\t\tcomparison = arcLengths[i] - targetArcLength;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (comparison < 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlow = i + 1;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (comparison > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thigh = i - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thigh = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// DONE\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ti = high;\n\n\t\t\t\t\t\t\t\t\tif (arcLengths[i] === targetArcLength) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn i / (il - 1);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\t\t\t\t\t\t\t\tvar lengthBefore = arcLengths[i];\n\t\t\t\t\t\t\t\t\tvar lengthAfter = arcLengths[i + 1];\n\n\t\t\t\t\t\t\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t\t\t\t\t\t\t\t// determine where we are between the 'before' and 'after' points\n\n\t\t\t\t\t\t\t\t\tvar segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\n\n\t\t\t\t\t\t\t\t\t// add that fractional amount to t\n\n\t\t\t\t\t\t\t\t\tvar t = (i + segmentFraction) / (il - 1);\n\n\t\t\t\t\t\t\t\t\treturn t;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Returns a unit vector tangent at t\n\t\t\t\t\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t\t\t\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t\t\t\t\t// which seems to give a reasonable approximation\n\n\t\t\t\t\t\tgetTangent: function getTangent(t) {\n\n\t\t\t\t\t\t\t\t\tvar delta = 0.0001;\n\t\t\t\t\t\t\t\t\tvar t1 = t - delta;\n\t\t\t\t\t\t\t\t\tvar t2 = t + delta;\n\n\t\t\t\t\t\t\t\t\t// Capping in case of danger\n\n\t\t\t\t\t\t\t\t\tif (t1 < 0) t1 = 0;\n\t\t\t\t\t\t\t\t\tif (t2 > 1) t2 = 1;\n\n\t\t\t\t\t\t\t\t\tvar pt1 = this.getPoint(t1);\n\t\t\t\t\t\t\t\t\tvar pt2 = this.getPoint(t2);\n\n\t\t\t\t\t\t\t\t\tvar vec = pt2.clone().sub(pt1);\n\t\t\t\t\t\t\t\t\treturn vec.normalize();\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetTangentAt: function getTangentAt(u) {\n\n\t\t\t\t\t\t\t\t\tvar t = this.getUtoTmapping(u);\n\t\t\t\t\t\t\t\t\treturn this.getTangent(t);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcomputeFrenetFrames: function computeFrenetFrames(segments, closed) {\n\n\t\t\t\t\t\t\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\t\t\t\t\t\t\t\tvar normal = new Vector3();\n\n\t\t\t\t\t\t\t\t\tvar tangents = [];\n\t\t\t\t\t\t\t\t\tvar normals = [];\n\t\t\t\t\t\t\t\t\tvar binormals = [];\n\n\t\t\t\t\t\t\t\t\tvar vec = new Vector3();\n\t\t\t\t\t\t\t\t\tvar mat = new Matrix4();\n\n\t\t\t\t\t\t\t\t\tvar i, u, theta;\n\n\t\t\t\t\t\t\t\t\t// compute the tangent vectors for each segment on the curve\n\n\t\t\t\t\t\t\t\t\tfor (i = 0; i <= segments; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tu = i / segments;\n\n\t\t\t\t\t\t\t\t\t\t\t\ttangents[i] = this.getTangentAt(u);\n\t\t\t\t\t\t\t\t\t\t\t\ttangents[i].normalize();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t\t\t\t\t\t\t// and in the direction of the minimum tangent xyz component\n\n\t\t\t\t\t\t\t\t\tnormals[0] = new Vector3();\n\t\t\t\t\t\t\t\t\tbinormals[0] = new Vector3();\n\t\t\t\t\t\t\t\t\tvar min = Number.MAX_VALUE;\n\t\t\t\t\t\t\t\t\tvar tx = Math.abs(tangents[0].x);\n\t\t\t\t\t\t\t\t\tvar ty = Math.abs(tangents[0].y);\n\t\t\t\t\t\t\t\t\tvar tz = Math.abs(tangents[0].z);\n\n\t\t\t\t\t\t\t\t\tif (tx <= min) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin = tx;\n\t\t\t\t\t\t\t\t\t\t\t\tnormal.set(1, 0, 0);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (ty <= min) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmin = ty;\n\t\t\t\t\t\t\t\t\t\t\t\tnormal.set(0, 1, 0);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (tz <= min) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnormal.set(0, 0, 1);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvec.crossVectors(tangents[0], normal).normalize();\n\n\t\t\t\t\t\t\t\t\tnormals[0].crossVectors(tangents[0], vec);\n\t\t\t\t\t\t\t\t\tbinormals[0].crossVectors(tangents[0], normals[0]);\n\n\t\t\t\t\t\t\t\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\t\t\t\t\t\t\tfor (i = 1; i <= segments; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnormals[i] = normals[i - 1].clone();\n\n\t\t\t\t\t\t\t\t\t\t\t\tbinormals[i] = binormals[i - 1].clone();\n\n\t\t\t\t\t\t\t\t\t\t\t\tvec.crossVectors(tangents[i - 1], tangents[i]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (vec.length() > Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvec.normalize();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttheta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tbinormals[i].crossVectors(tangents[i], normals[i]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\t\t\t\t\t\t\t\tif (closed === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttheta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));\n\t\t\t\t\t\t\t\t\t\t\t\ttheta /= segments;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttheta = -theta;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 1; i <= segments; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// twist a little...\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbinormals[i].crossVectors(tangents[i], normals[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\ttangents: tangents,\n\t\t\t\t\t\t\t\t\t\t\t\tnormals: normals,\n\t\t\t\t\t\t\t\t\t\t\t\tbinormals: binormals\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclone: function clone() {\n\n\t\t\t\t\t\t\t\t\treturn new this.constructor().copy(this);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source) {\n\n\t\t\t\t\t\t\t\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoJSON: function toJSON() {\n\n\t\t\t\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tversion: 4.5,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: 'Curve',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\t\t\t\t\t\t\t\tdata.type = this.type;\n\n\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromJSON: function fromJSON(json) {\n\n\t\t\t\t\t\t\t\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tfunction EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'EllipseCurve';\n\n\t\t\t\t\t\tthis.aX = aX || 0;\n\t\t\t\t\t\tthis.aY = aY || 0;\n\n\t\t\t\t\t\tthis.xRadius = xRadius || 1;\n\t\t\t\t\t\tthis.yRadius = yRadius || 1;\n\n\t\t\t\t\t\tthis.aStartAngle = aStartAngle || 0;\n\t\t\t\t\t\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\n\n\t\t\t\t\t\tthis.aClockwise = aClockwise || false;\n\n\t\t\t\t\t\tthis.aRotation = aRotation || 0;\n\t\t\t}\n\n\t\t\tEllipseCurve.prototype = Object.create(Curve.prototype);\n\t\t\tEllipseCurve.prototype.constructor = EllipseCurve;\n\n\t\t\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\t\t\tEllipseCurve.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector2();\n\n\t\t\t\t\t\tvar twoPi = Math.PI * 2;\n\t\t\t\t\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\t\t\t\t\tvar samePoints = Math.abs(deltaAngle) < Number.EPSILON;\n\n\t\t\t\t\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\t\t\t\t\twhile (deltaAngle < 0) {\n\t\t\t\t\t\t\t\t\tdeltaAngle += twoPi;\n\t\t\t\t\t\t}while (deltaAngle > twoPi) {\n\t\t\t\t\t\t\t\t\tdeltaAngle -= twoPi;\n\t\t\t\t\t\t}if (deltaAngle < Number.EPSILON) {\n\n\t\t\t\t\t\t\t\t\tif (samePoints) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeltaAngle = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeltaAngle = twoPi;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.aClockwise === true && !samePoints) {\n\n\t\t\t\t\t\t\t\t\tif (deltaAngle === twoPi) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeltaAngle = -twoPi;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\t\t\t\t\tvar x = this.aX + this.xRadius * Math.cos(angle);\n\t\t\t\t\t\tvar y = this.aY + this.yRadius * Math.sin(angle);\n\n\t\t\t\t\t\tif (this.aRotation !== 0) {\n\n\t\t\t\t\t\t\t\t\tvar cos = Math.cos(this.aRotation);\n\t\t\t\t\t\t\t\t\tvar sin = Math.sin(this.aRotation);\n\n\t\t\t\t\t\t\t\t\tvar tx = x - this.aX;\n\t\t\t\t\t\t\t\t\tvar ty = y - this.aY;\n\n\t\t\t\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\t\t\t\t\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\t\t\t\t\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn point.set(x, y);\n\t\t\t};\n\n\t\t\tEllipseCurve.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.aX = source.aX;\n\t\t\t\t\t\tthis.aY = source.aY;\n\n\t\t\t\t\t\tthis.xRadius = source.xRadius;\n\t\t\t\t\t\tthis.yRadius = source.yRadius;\n\n\t\t\t\t\t\tthis.aStartAngle = source.aStartAngle;\n\t\t\t\t\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\t\t\t\t\tthis.aClockwise = source.aClockwise;\n\n\t\t\t\t\t\tthis.aRotation = source.aRotation;\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tEllipseCurve.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.aX = this.aX;\n\t\t\t\t\t\tdata.aY = this.aY;\n\n\t\t\t\t\t\tdata.xRadius = this.xRadius;\n\t\t\t\t\t\tdata.yRadius = this.yRadius;\n\n\t\t\t\t\t\tdata.aStartAngle = this.aStartAngle;\n\t\t\t\t\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\t\t\t\t\tdata.aClockwise = this.aClockwise;\n\n\t\t\t\t\t\tdata.aRotation = this.aRotation;\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tEllipseCurve.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.aX = json.aX;\n\t\t\t\t\t\tthis.aY = json.aY;\n\n\t\t\t\t\t\tthis.xRadius = json.xRadius;\n\t\t\t\t\t\tthis.yRadius = json.yRadius;\n\n\t\t\t\t\t\tthis.aStartAngle = json.aStartAngle;\n\t\t\t\t\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\t\t\t\t\tthis.aClockwise = json.aClockwise;\n\n\t\t\t\t\t\tthis.aRotation = json.aRotation;\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tfunction ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\n\t\t\t\t\t\tEllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\n\t\t\t\t\t\tthis.type = 'ArcCurve';\n\t\t\t}\n\n\t\t\tArcCurve.prototype = Object.create(EllipseCurve.prototype);\n\t\t\tArcCurve.prototype.constructor = ArcCurve;\n\n\t\t\tArcCurve.prototype.isArcCurve = true;\n\n\t\t\t/**\r\n    * @author zz85 https://github.com/zz85\r\n    *\r\n    * Centripetal CatmullRom Curve - which is useful for avoiding\r\n    * cusps and self-intersections in non-uniform catmull rom curves.\r\n    * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n    *\r\n    * curve.type accepts centripetal(default), chordal and catmullrom\r\n    * curve.tension is used for catmullrom which defaults to 0.5\r\n    */\n\n\t\t\t/*\r\n   Based on an optimized c++ solution in\r\n    - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n    - http://ideone.com/NoEbVM\r\n   \n   This CubicPoly class could be used for reusing some variables and calculations,\r\n   but for three.js curve use, it could be possible inlined and flatten into a single function call\r\n   which can be placed in CurveUtils.\r\n   */\n\n\t\t\tfunction CubicPoly() {\n\n\t\t\t\t\t\tvar c0 = 0,\n\t\t\t\t\t\t    c1 = 0,\n\t\t\t\t\t\t    c2 = 0,\n\t\t\t\t\t\t    c3 = 0;\n\n\t\t\t\t\t\t/*\r\n       * Compute coefficients for a cubic polynomial\r\n       *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n       * such that\r\n       *   p(0) = x0, p(1) = x1\r\n       *  and\r\n       *   p'(0) = t0, p'(1) = t1.\r\n       */\n\t\t\t\t\t\tfunction init(x0, x1, t0, t1) {\n\n\t\t\t\t\t\t\t\t\tc0 = x0;\n\t\t\t\t\t\t\t\t\tc1 = t0;\n\t\t\t\t\t\t\t\t\tc2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\t\t\t\t\t\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\n\t\t\t\t\t\t\t\t\tinitCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tinit(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tinitNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\t\t\t\t\t\t\t\t\tvar t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n\t\t\t\t\t\t\t\t\t\t\t\tvar t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\t\t\t\t\t\t\t\t\t\tt1 *= dt1;\n\t\t\t\t\t\t\t\t\t\t\t\tt2 *= dt1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tinit(x1, x2, t1, t2);\n\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\tcalc: function calc(t) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar t2 = t * t;\n\t\t\t\t\t\t\t\t\t\t\t\tvar t3 = t2 * t;\n\t\t\t\t\t\t\t\t\t\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t};\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar tmp = new Vector3();\n\t\t\tvar px = new CubicPoly(),\n\t\t\t    py = new CubicPoly(),\n\t\t\t    pz = new CubicPoly();\n\n\t\t\tfunction CatmullRomCurve3(points, closed, curveType, tension) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'CatmullRomCurve3';\n\n\t\t\t\t\t\tthis.points = points || [];\n\t\t\t\t\t\tthis.closed = closed || false;\n\t\t\t\t\t\tthis.curveType = curveType || 'centripetal';\n\t\t\t\t\t\tthis.tension = tension || 0.5;\n\t\t\t}\n\n\t\t\tCatmullRomCurve3.prototype = Object.create(Curve.prototype);\n\t\t\tCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\n\n\t\t\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\n\t\t\tCatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector3();\n\n\t\t\t\t\t\tvar points = this.points;\n\t\t\t\t\t\tvar l = points.length;\n\n\t\t\t\t\t\tvar p = (l - (this.closed ? 0 : 1)) * t;\n\t\t\t\t\t\tvar intPoint = Math.floor(p);\n\t\t\t\t\t\tvar weight = p - intPoint;\n\n\t\t\t\t\t\tif (this.closed) {\n\n\t\t\t\t\t\t\t\t\tintPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n\t\t\t\t\t\t} else if (weight === 0 && intPoint === l - 1) {\n\n\t\t\t\t\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\t\t\t\t\tweight = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\t\t\t\tif (this.closed || intPoint > 0) {\n\n\t\t\t\t\t\t\t\t\tp0 = points[(intPoint - 1) % l];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// extrapolate first point\n\t\t\t\t\t\t\t\t\ttmp.subVectors(points[0], points[1]).add(points[0]);\n\t\t\t\t\t\t\t\t\tp0 = tmp;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tp1 = points[intPoint % l];\n\t\t\t\t\t\tp2 = points[(intPoint + 1) % l];\n\n\t\t\t\t\t\tif (this.closed || intPoint + 2 < l) {\n\n\t\t\t\t\t\t\t\t\tp3 = points[(intPoint + 2) % l];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// extrapolate last point\n\t\t\t\t\t\t\t\t\ttmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n\t\t\t\t\t\t\t\t\tp3 = tmp;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.curveType === 'centripetal' || this.curveType === 'chordal') {\n\n\t\t\t\t\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\t\t\t\t\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\t\t\t\t\tvar dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n\t\t\t\t\t\t\t\t\tvar dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n\t\t\t\t\t\t\t\t\tvar dt2 = Math.pow(p2.distanceToSquared(p3), pow);\n\n\t\t\t\t\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\t\t\t\t\tif (dt1 < 1e-4) dt1 = 1.0;\n\t\t\t\t\t\t\t\t\tif (dt0 < 1e-4) dt0 = dt1;\n\t\t\t\t\t\t\t\t\tif (dt2 < 1e-4) dt2 = dt1;\n\n\t\t\t\t\t\t\t\t\tpx.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n\t\t\t\t\t\t\t\t\tpy.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n\t\t\t\t\t\t\t\t\tpz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n\t\t\t\t\t\t} else if (this.curveType === 'catmullrom') {\n\n\t\t\t\t\t\t\t\t\tpx.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n\t\t\t\t\t\t\t\t\tpy.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n\t\t\t\t\t\t\t\t\tpz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpoint.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n\n\t\t\t\t\t\treturn point;\n\t\t\t};\n\n\t\t\tCatmullRomCurve3.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.points = [];\n\n\t\t\t\t\t\tfor (var i = 0, l = source.points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\tvar point = source.points[i];\n\n\t\t\t\t\t\t\t\t\tthis.points.push(point.clone());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.closed = source.closed;\n\t\t\t\t\t\tthis.curveType = source.curveType;\n\t\t\t\t\t\tthis.tension = source.tension;\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tCatmullRomCurve3.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.points = [];\n\n\t\t\t\t\t\tfor (var i = 0, l = this.points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\tvar point = this.points[i];\n\t\t\t\t\t\t\t\t\tdata.points.push(point.toArray());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata.closed = this.closed;\n\t\t\t\t\t\tdata.curveType = this.curveType;\n\t\t\t\t\t\tdata.tension = this.tension;\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tCatmullRomCurve3.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.points = [];\n\n\t\t\t\t\t\tfor (var i = 0, l = json.points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\tvar point = json.points[i];\n\t\t\t\t\t\t\t\t\tthis.points.push(new Vector3().fromArray(point));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.closed = json.closed;\n\t\t\t\t\t\tthis.curveType = json.curveType;\n\t\t\t\t\t\tthis.tension = json.tension;\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t/**\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    *\r\n    * Bezier Curves formulas obtained from\r\n    * http://en.wikipedia.org/wiki/Bézier_curve\r\n    */\n\n\t\t\tfunction CatmullRom(t, p0, p1, p2, p3) {\n\n\t\t\t\t\t\tvar v0 = (p2 - p0) * 0.5;\n\t\t\t\t\t\tvar v1 = (p3 - p1) * 0.5;\n\t\t\t\t\t\tvar t2 = t * t;\n\t\t\t\t\t\tvar t3 = t * t2;\n\t\t\t\t\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction QuadraticBezierP0(t, p) {\n\n\t\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\t\treturn k * k * p;\n\t\t\t}\n\n\t\t\tfunction QuadraticBezierP1(t, p) {\n\n\t\t\t\t\t\treturn 2 * (1 - t) * t * p;\n\t\t\t}\n\n\t\t\tfunction QuadraticBezierP2(t, p) {\n\n\t\t\t\t\t\treturn t * t * p;\n\t\t\t}\n\n\t\t\tfunction QuadraticBezier(t, p0, p1, p2) {\n\n\t\t\t\t\t\treturn QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction CubicBezierP0(t, p) {\n\n\t\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\t\treturn k * k * k * p;\n\t\t\t}\n\n\t\t\tfunction CubicBezierP1(t, p) {\n\n\t\t\t\t\t\tvar k = 1 - t;\n\t\t\t\t\t\treturn 3 * k * k * t * p;\n\t\t\t}\n\n\t\t\tfunction CubicBezierP2(t, p) {\n\n\t\t\t\t\t\treturn 3 * (1 - t) * t * t * p;\n\t\t\t}\n\n\t\t\tfunction CubicBezierP3(t, p) {\n\n\t\t\t\t\t\treturn t * t * t * p;\n\t\t\t}\n\n\t\t\tfunction CubicBezier(t, p0, p1, p2, p3) {\n\n\t\t\t\t\t\treturn CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n\t\t\t}\n\n\t\t\tfunction CubicBezierCurve(v0, v1, v2, v3) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'CubicBezierCurve';\n\n\t\t\t\t\t\tthis.v0 = v0 || new Vector2();\n\t\t\t\t\t\tthis.v1 = v1 || new Vector2();\n\t\t\t\t\t\tthis.v2 = v2 || new Vector2();\n\t\t\t\t\t\tthis.v3 = v3 || new Vector2();\n\t\t\t}\n\n\t\t\tCubicBezierCurve.prototype = Object.create(Curve.prototype);\n\t\t\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\n\t\t\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\n\t\t\tCubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector2();\n\n\t\t\t\t\t\tvar v0 = this.v0,\n\t\t\t\t\t\t    v1 = this.v1,\n\t\t\t\t\t\t    v2 = this.v2,\n\t\t\t\t\t\t    v3 = this.v3;\n\n\t\t\t\t\t\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\n\n\t\t\t\t\t\treturn point;\n\t\t\t};\n\n\t\t\tCubicBezierCurve.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.v0.copy(source.v0);\n\t\t\t\t\t\tthis.v1.copy(source.v1);\n\t\t\t\t\t\tthis.v2.copy(source.v2);\n\t\t\t\t\t\tthis.v3.copy(source.v3);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tCubicBezierCurve.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.v0 = this.v0.toArray();\n\t\t\t\t\t\tdata.v1 = this.v1.toArray();\n\t\t\t\t\t\tdata.v2 = this.v2.toArray();\n\t\t\t\t\t\tdata.v3 = this.v3.toArray();\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tCubicBezierCurve.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.v0.fromArray(json.v0);\n\t\t\t\t\t\tthis.v1.fromArray(json.v1);\n\t\t\t\t\t\tthis.v2.fromArray(json.v2);\n\t\t\t\t\t\tthis.v3.fromArray(json.v3);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tfunction CubicBezierCurve3(v0, v1, v2, v3) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'CubicBezierCurve3';\n\n\t\t\t\t\t\tthis.v0 = v0 || new Vector3();\n\t\t\t\t\t\tthis.v1 = v1 || new Vector3();\n\t\t\t\t\t\tthis.v2 = v2 || new Vector3();\n\t\t\t\t\t\tthis.v3 = v3 || new Vector3();\n\t\t\t}\n\n\t\t\tCubicBezierCurve3.prototype = Object.create(Curve.prototype);\n\t\t\tCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\n\n\t\t\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\n\t\t\tCubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector3();\n\n\t\t\t\t\t\tvar v0 = this.v0,\n\t\t\t\t\t\t    v1 = this.v1,\n\t\t\t\t\t\t    v2 = this.v2,\n\t\t\t\t\t\t    v3 = this.v3;\n\n\t\t\t\t\t\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\n\n\t\t\t\t\t\treturn point;\n\t\t\t};\n\n\t\t\tCubicBezierCurve3.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.v0.copy(source.v0);\n\t\t\t\t\t\tthis.v1.copy(source.v1);\n\t\t\t\t\t\tthis.v2.copy(source.v2);\n\t\t\t\t\t\tthis.v3.copy(source.v3);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tCubicBezierCurve3.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.v0 = this.v0.toArray();\n\t\t\t\t\t\tdata.v1 = this.v1.toArray();\n\t\t\t\t\t\tdata.v2 = this.v2.toArray();\n\t\t\t\t\t\tdata.v3 = this.v3.toArray();\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tCubicBezierCurve3.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.v0.fromArray(json.v0);\n\t\t\t\t\t\tthis.v1.fromArray(json.v1);\n\t\t\t\t\t\tthis.v2.fromArray(json.v2);\n\t\t\t\t\t\tthis.v3.fromArray(json.v3);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tfunction LineCurve(v1, v2) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'LineCurve';\n\n\t\t\t\t\t\tthis.v1 = v1 || new Vector2();\n\t\t\t\t\t\tthis.v2 = v2 || new Vector2();\n\t\t\t}\n\n\t\t\tLineCurve.prototype = Object.create(Curve.prototype);\n\t\t\tLineCurve.prototype.constructor = LineCurve;\n\n\t\t\tLineCurve.prototype.isLineCurve = true;\n\n\t\t\tLineCurve.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector2();\n\n\t\t\t\t\t\tif (t === 1) {\n\n\t\t\t\t\t\t\t\t\tpoint.copy(this.v2);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tpoint.copy(this.v2).sub(this.v1);\n\t\t\t\t\t\t\t\t\tpoint.multiplyScalar(t).add(this.v1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn point;\n\t\t\t};\n\n\t\t\t// Line curve is linear, so we can overwrite default getPointAt\n\n\t\t\tLineCurve.prototype.getPointAt = function (u, optionalTarget) {\n\n\t\t\t\t\t\treturn this.getPoint(u, optionalTarget);\n\t\t\t};\n\n\t\t\tLineCurve.prototype.getTangent = function () /* t */{\n\n\t\t\t\t\t\tvar tangent = this.v2.clone().sub(this.v1);\n\n\t\t\t\t\t\treturn tangent.normalize();\n\t\t\t};\n\n\t\t\tLineCurve.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.v1.copy(source.v1);\n\t\t\t\t\t\tthis.v2.copy(source.v2);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tLineCurve.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.v1 = this.v1.toArray();\n\t\t\t\t\t\tdata.v2 = this.v2.toArray();\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tLineCurve.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.v1.fromArray(json.v1);\n\t\t\t\t\t\tthis.v2.fromArray(json.v2);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tfunction LineCurve3(v1, v2) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'LineCurve3';\n\n\t\t\t\t\t\tthis.v1 = v1 || new Vector3();\n\t\t\t\t\t\tthis.v2 = v2 || new Vector3();\n\t\t\t}\n\n\t\t\tLineCurve3.prototype = Object.create(Curve.prototype);\n\t\t\tLineCurve3.prototype.constructor = LineCurve3;\n\n\t\t\tLineCurve3.prototype.isLineCurve3 = true;\n\n\t\t\tLineCurve3.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector3();\n\n\t\t\t\t\t\tif (t === 1) {\n\n\t\t\t\t\t\t\t\t\tpoint.copy(this.v2);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tpoint.copy(this.v2).sub(this.v1);\n\t\t\t\t\t\t\t\t\tpoint.multiplyScalar(t).add(this.v1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn point;\n\t\t\t};\n\n\t\t\t// Line curve is linear, so we can overwrite default getPointAt\n\n\t\t\tLineCurve3.prototype.getPointAt = function (u, optionalTarget) {\n\n\t\t\t\t\t\treturn this.getPoint(u, optionalTarget);\n\t\t\t};\n\n\t\t\tLineCurve3.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.v1.copy(source.v1);\n\t\t\t\t\t\tthis.v2.copy(source.v2);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tLineCurve3.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.v1 = this.v1.toArray();\n\t\t\t\t\t\tdata.v2 = this.v2.toArray();\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tLineCurve3.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.v1.fromArray(json.v1);\n\t\t\t\t\t\tthis.v2.fromArray(json.v2);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tfunction QuadraticBezierCurve(v0, v1, v2) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\t\t\t\t\tthis.v0 = v0 || new Vector2();\n\t\t\t\t\t\tthis.v1 = v1 || new Vector2();\n\t\t\t\t\t\tthis.v2 = v2 || new Vector2();\n\t\t\t}\n\n\t\t\tQuadraticBezierCurve.prototype = Object.create(Curve.prototype);\n\t\t\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\n\t\t\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\n\t\t\tQuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector2();\n\n\t\t\t\t\t\tvar v0 = this.v0,\n\t\t\t\t\t\t    v1 = this.v1,\n\t\t\t\t\t\t    v2 = this.v2;\n\n\t\t\t\t\t\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\n\n\t\t\t\t\t\treturn point;\n\t\t\t};\n\n\t\t\tQuadraticBezierCurve.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.v0.copy(source.v0);\n\t\t\t\t\t\tthis.v1.copy(source.v1);\n\t\t\t\t\t\tthis.v2.copy(source.v2);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tQuadraticBezierCurve.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.v0 = this.v0.toArray();\n\t\t\t\t\t\tdata.v1 = this.v1.toArray();\n\t\t\t\t\t\tdata.v2 = this.v2.toArray();\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tQuadraticBezierCurve.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.v0.fromArray(json.v0);\n\t\t\t\t\t\tthis.v1.fromArray(json.v1);\n\t\t\t\t\t\tthis.v2.fromArray(json.v2);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tfunction QuadraticBezierCurve3(v0, v1, v2) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\t\t\t\t\tthis.v0 = v0 || new Vector3();\n\t\t\t\t\t\tthis.v1 = v1 || new Vector3();\n\t\t\t\t\t\tthis.v2 = v2 || new Vector3();\n\t\t\t}\n\n\t\t\tQuadraticBezierCurve3.prototype = Object.create(Curve.prototype);\n\t\t\tQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\n\n\t\t\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\n\t\t\tQuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector3();\n\n\t\t\t\t\t\tvar v0 = this.v0,\n\t\t\t\t\t\t    v1 = this.v1,\n\t\t\t\t\t\t    v2 = this.v2;\n\n\t\t\t\t\t\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\n\n\t\t\t\t\t\treturn point;\n\t\t\t};\n\n\t\t\tQuadraticBezierCurve3.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.v0.copy(source.v0);\n\t\t\t\t\t\tthis.v1.copy(source.v1);\n\t\t\t\t\t\tthis.v2.copy(source.v2);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tQuadraticBezierCurve3.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.v0 = this.v0.toArray();\n\t\t\t\t\t\tdata.v1 = this.v1.toArray();\n\t\t\t\t\t\tdata.v2 = this.v2.toArray();\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tQuadraticBezierCurve3.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.v0.fromArray(json.v0);\n\t\t\t\t\t\tthis.v1.fromArray(json.v1);\n\t\t\t\t\t\tthis.v2.fromArray(json.v2);\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tfunction SplineCurve(points /* array of Vector2 */) {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'SplineCurve';\n\n\t\t\t\t\t\tthis.points = points || [];\n\t\t\t}\n\n\t\t\tSplineCurve.prototype = Object.create(Curve.prototype);\n\t\t\tSplineCurve.prototype.constructor = SplineCurve;\n\n\t\t\tSplineCurve.prototype.isSplineCurve = true;\n\n\t\t\tSplineCurve.prototype.getPoint = function (t, optionalTarget) {\n\n\t\t\t\t\t\tvar point = optionalTarget || new Vector2();\n\n\t\t\t\t\t\tvar points = this.points;\n\t\t\t\t\t\tvar p = (points.length - 1) * t;\n\n\t\t\t\t\t\tvar intPoint = Math.floor(p);\n\t\t\t\t\t\tvar weight = p - intPoint;\n\n\t\t\t\t\t\tvar p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n\t\t\t\t\t\tvar p1 = points[intPoint];\n\t\t\t\t\t\tvar p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n\t\t\t\t\t\tvar p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n\n\t\t\t\t\t\tpoint.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n\n\t\t\t\t\t\treturn point;\n\t\t\t};\n\n\t\t\tSplineCurve.prototype.copy = function (source) {\n\n\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\tthis.points = [];\n\n\t\t\t\t\t\tfor (var i = 0, l = source.points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\tvar point = source.points[i];\n\n\t\t\t\t\t\t\t\t\tthis.points.push(point.clone());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tSplineCurve.prototype.toJSON = function () {\n\n\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\tdata.points = [];\n\n\t\t\t\t\t\tfor (var i = 0, l = this.points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\tvar point = this.points[i];\n\t\t\t\t\t\t\t\t\tdata.points.push(point.toArray());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\tSplineCurve.prototype.fromJSON = function (json) {\n\n\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\tthis.points = [];\n\n\t\t\t\t\t\tfor (var i = 0, l = json.points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\tvar point = json.points[i];\n\t\t\t\t\t\t\t\t\tthis.points.push(new Vector2().fromArray(point));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tvar Curves = /*#__PURE__*/Object.freeze({\n\t\t\t\t\t\tArcCurve: ArcCurve,\n\t\t\t\t\t\tCatmullRomCurve3: CatmullRomCurve3,\n\t\t\t\t\t\tCubicBezierCurve: CubicBezierCurve,\n\t\t\t\t\t\tCubicBezierCurve3: CubicBezierCurve3,\n\t\t\t\t\t\tEllipseCurve: EllipseCurve,\n\t\t\t\t\t\tLineCurve: LineCurve,\n\t\t\t\t\t\tLineCurve3: LineCurve3,\n\t\t\t\t\t\tQuadraticBezierCurve: QuadraticBezierCurve,\n\t\t\t\t\t\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\t\t\t\t\t\tSplineCurve: SplineCurve\n\t\t\t});\n\n\t\t\t/**\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    *\r\n    **/\n\n\t\t\t/**************************************************************\r\n    *\tCurved Path - a curve path is simply a array of connected\r\n    *  curves, but retains the api of a curve\r\n    **************************************************************/\n\n\t\t\tfunction CurvePath() {\n\n\t\t\t\t\t\tCurve.call(this);\n\n\t\t\t\t\t\tthis.type = 'CurvePath';\n\n\t\t\t\t\t\tthis.curves = [];\n\t\t\t\t\t\tthis.autoClose = false; // Automatically closes the path\n\t\t\t}\n\n\t\t\tCurvePath.prototype = Object.assign(Object.create(Curve.prototype), {\n\n\t\t\t\t\t\tconstructor: CurvePath,\n\n\t\t\t\t\t\tadd: function add(curve) {\n\n\t\t\t\t\t\t\t\t\tthis.curves.push(curve);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tclosePath: function closePath() {\n\n\t\t\t\t\t\t\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\t\t\t\t\t\t\tvar startPoint = this.curves[0].getPoint(0);\n\t\t\t\t\t\t\t\t\tvar endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n\t\t\t\t\t\t\t\t\tif (!startPoint.equals(endPoint)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.curves.push(new LineCurve(endPoint, startPoint));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// To get accurate point with reference to\n\t\t\t\t\t\t// entire path distance at time t,\n\t\t\t\t\t\t// following has to be done:\n\n\t\t\t\t\t\t// 1. Length of each sub path have to be known\n\t\t\t\t\t\t// 2. Locate and identify type of curve\n\t\t\t\t\t\t// 3. Get t for the curve\n\t\t\t\t\t\t// 4. Return curve.getPointAt(t')\n\n\t\t\t\t\t\tgetPoint: function getPoint(t) {\n\n\t\t\t\t\t\t\t\t\tvar d = t * this.getLength();\n\t\t\t\t\t\t\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\t\t\t\t\t\t\tvar i = 0;\n\n\t\t\t\t\t\t\t\t\t// To think about boundaries points.\n\n\t\t\t\t\t\t\t\t\twhile (i < curveLengths.length) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (curveLengths[i] >= d) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar diff = curveLengths[i] - d;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar curve = this.curves[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn curve.getPointAt(u);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t\t\t\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t\t\t\t\t// getPoint() depends on getLength\n\n\t\t\t\t\t\tgetLength: function getLength() {\n\n\t\t\t\t\t\t\t\t\tvar lens = this.getCurveLengths();\n\t\t\t\t\t\t\t\t\treturn lens[lens.length - 1];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// cacheLengths must be recalculated.\n\t\t\t\t\t\tupdateArcLengths: function updateArcLengths() {\n\n\t\t\t\t\t\t\t\t\tthis.needsUpdate = true;\n\t\t\t\t\t\t\t\t\tthis.cacheLengths = null;\n\t\t\t\t\t\t\t\t\tthis.getCurveLengths();\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Compute lengths and cache them\n\t\t\t\t\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\t\t\t\t\t\tgetCurveLengths: function getCurveLengths() {\n\n\t\t\t\t\t\t\t\t\t// We use cache values if curves and cache array are same length\n\n\t\t\t\t\t\t\t\t\tif (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.cacheLengths;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Get length of sub-curve\n\t\t\t\t\t\t\t\t\t// Push sums into cached array\n\n\t\t\t\t\t\t\t\t\tvar lengths = [],\n\t\t\t\t\t\t\t\t\t    sums = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = this.curves.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tsums += this.curves[i].getLength();\n\t\t\t\t\t\t\t\t\t\t\t\tlengths.push(sums);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.cacheLengths = lengths;\n\n\t\t\t\t\t\t\t\t\treturn lengths;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetSpacedPoints: function getSpacedPoints(divisions) {\n\n\t\t\t\t\t\t\t\t\tif (divisions === undefined) divisions = 40;\n\n\t\t\t\t\t\t\t\t\tvar points = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i <= divisions; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoints.push(this.getPoint(i / divisions));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.autoClose) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoints.push(points[0]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn points;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetPoints: function getPoints(divisions) {\n\n\t\t\t\t\t\t\t\t\tdivisions = divisions || 12;\n\n\t\t\t\t\t\t\t\t\tvar points = [],\n\t\t\t\t\t\t\t\t\t    last;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, curves = this.curves; i < curves.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar curve = curves[i];\n\t\t\t\t\t\t\t\t\t\t\t\tvar resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar pts = curve.getPoints(resolution);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0; j < pts.length; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar point = pts[j];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpoints.push(point);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlast = point;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoints.push(points[0]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn points;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source) {\n\n\t\t\t\t\t\t\t\t\tCurve.prototype.copy.call(this, source);\n\n\t\t\t\t\t\t\t\t\tthis.curves = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = source.curves.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar curve = source.curves[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.curves.push(curve.clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.autoClose = source.autoClose;\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoJSON: function toJSON() {\n\n\t\t\t\t\t\t\t\t\tvar data = Curve.prototype.toJSON.call(this);\n\n\t\t\t\t\t\t\t\t\tdata.autoClose = this.autoClose;\n\t\t\t\t\t\t\t\t\tdata.curves = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = this.curves.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar curve = this.curves[i];\n\t\t\t\t\t\t\t\t\t\t\t\tdata.curves.push(curve.toJSON());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromJSON: function fromJSON(json) {\n\n\t\t\t\t\t\t\t\t\tCurve.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\t\t\t\tthis.autoClose = json.autoClose;\n\t\t\t\t\t\t\t\t\tthis.curves = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = json.curves.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar curve = json.curves[i];\n\t\t\t\t\t\t\t\t\t\t\t\tthis.curves.push(new Curves[curve.type]().fromJSON(curve));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    * Creates free form 2d path using series of points, lines or curves.\r\n    **/\n\n\t\t\tfunction Path(points) {\n\n\t\t\t\t\t\tCurvePath.call(this);\n\n\t\t\t\t\t\tthis.type = 'Path';\n\n\t\t\t\t\t\tthis.currentPoint = new Vector2();\n\n\t\t\t\t\t\tif (points) {\n\n\t\t\t\t\t\t\t\t\tthis.setFromPoints(points);\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tPath.prototype = Object.assign(Object.create(CurvePath.prototype), {\n\n\t\t\t\t\t\tconstructor: Path,\n\n\t\t\t\t\t\tsetFromPoints: function setFromPoints(points) {\n\n\t\t\t\t\t\t\t\t\tthis.moveTo(points[0].x, points[0].y);\n\n\t\t\t\t\t\t\t\t\tfor (var i = 1, l = points.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.lineTo(points[i].x, points[i].y);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmoveTo: function moveTo(x, y) {\n\n\t\t\t\t\t\t\t\t\tthis.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tlineTo: function lineTo(x, y) {\n\n\t\t\t\t\t\t\t\t\tvar curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n\t\t\t\t\t\t\t\t\tthis.curves.push(curve);\n\n\t\t\t\t\t\t\t\t\tthis.currentPoint.set(x, y);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tquadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {\n\n\t\t\t\t\t\t\t\t\tvar curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n\n\t\t\t\t\t\t\t\t\tthis.curves.push(curve);\n\n\t\t\t\t\t\t\t\t\tthis.currentPoint.set(aX, aY);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tbezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n\n\t\t\t\t\t\t\t\t\tvar curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n\n\t\t\t\t\t\t\t\t\tthis.curves.push(curve);\n\n\t\t\t\t\t\t\t\t\tthis.currentPoint.set(aX, aY);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsplineThru: function splineThru(pts /*Array of Vector*/) {\n\n\t\t\t\t\t\t\t\t\tvar npts = [this.currentPoint.clone()].concat(pts);\n\n\t\t\t\t\t\t\t\t\tvar curve = new SplineCurve(npts);\n\t\t\t\t\t\t\t\t\tthis.curves.push(curve);\n\n\t\t\t\t\t\t\t\t\tthis.currentPoint.copy(pts[pts.length - 1]);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tarc: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\n\t\t\t\t\t\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\t\t\t\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\t\t\t\t\t\t\tthis.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tabsarc: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\n\t\t\t\t\t\t\t\t\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tellipse: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\n\t\t\t\t\t\t\t\t\tvar x0 = this.currentPoint.x;\n\t\t\t\t\t\t\t\t\tvar y0 = this.currentPoint.y;\n\n\t\t\t\t\t\t\t\t\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tabsellipse: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\n\t\t\t\t\t\t\t\t\tvar curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\n\t\t\t\t\t\t\t\t\tif (this.curves.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\t\t\t\t\t\t\t\t\tvar firstPoint = curve.getPoint(0);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!firstPoint.equals(this.currentPoint)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.lineTo(firstPoint.x, firstPoint.y);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.curves.push(curve);\n\n\t\t\t\t\t\t\t\t\tvar lastPoint = curve.getPoint(1);\n\t\t\t\t\t\t\t\t\tthis.currentPoint.copy(lastPoint);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source) {\n\n\t\t\t\t\t\t\t\t\tCurvePath.prototype.copy.call(this, source);\n\n\t\t\t\t\t\t\t\t\tthis.currentPoint.copy(source.currentPoint);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoJSON: function toJSON() {\n\n\t\t\t\t\t\t\t\t\tvar data = CurvePath.prototype.toJSON.call(this);\n\n\t\t\t\t\t\t\t\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromJSON: function fromJSON(json) {\n\n\t\t\t\t\t\t\t\t\tCurvePath.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\t\t\t\tthis.currentPoint.fromArray(json.currentPoint);\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t/**\r\n    * @author zz85 / http://www.lab4games.net/zz85/blog\r\n    * Defines a 2d shape plane using paths.\r\n    **/\n\n\t\t\t// STEP 1 Create a path.\n\t\t\t// STEP 2 Turn path into shape.\n\t\t\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t\t\t// STEP 3a - Extract points from each shape, turn to vertices\n\t\t\t// STEP 3b - Triangulate each shape, add faces.\n\n\t\t\tfunction Shape(points) {\n\n\t\t\t\t\t\tPath.call(this, points);\n\n\t\t\t\t\t\tthis.uuid = _Math.generateUUID();\n\n\t\t\t\t\t\tthis.type = 'Shape';\n\n\t\t\t\t\t\tthis.holes = [];\n\t\t\t}\n\n\t\t\tShape.prototype = Object.assign(Object.create(Path.prototype), {\n\n\t\t\t\t\t\tconstructor: Shape,\n\n\t\t\t\t\t\tgetPointsHoles: function getPointsHoles(divisions) {\n\n\t\t\t\t\t\t\t\t\tvar holesPts = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = this.holes.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tholesPts[i] = this.holes[i].getPoints(divisions);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn holesPts;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// get points of shape and holes (keypoints based on segments parameter)\n\n\t\t\t\t\t\textractPoints: function extractPoints(divisions) {\n\n\t\t\t\t\t\t\t\t\treturn {\n\n\t\t\t\t\t\t\t\t\t\t\t\tshape: this.getPoints(divisions),\n\t\t\t\t\t\t\t\t\t\t\t\tholes: this.getPointsHoles(divisions)\n\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcopy: function copy(source) {\n\n\t\t\t\t\t\t\t\t\tPath.prototype.copy.call(this, source);\n\n\t\t\t\t\t\t\t\t\tthis.holes = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = source.holes.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar hole = source.holes[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.holes.push(hole.clone());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttoJSON: function toJSON() {\n\n\t\t\t\t\t\t\t\t\tvar data = Path.prototype.toJSON.call(this);\n\n\t\t\t\t\t\t\t\t\tdata.uuid = this.uuid;\n\t\t\t\t\t\t\t\t\tdata.holes = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = this.holes.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar hole = this.holes[i];\n\t\t\t\t\t\t\t\t\t\t\t\tdata.holes.push(hole.toJSON());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfromJSON: function fromJSON(json) {\n\n\t\t\t\t\t\t\t\t\tPath.prototype.fromJSON.call(this, json);\n\n\t\t\t\t\t\t\t\t\tthis.uuid = json.uuid;\n\t\t\t\t\t\t\t\t\tthis.holes = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = json.holes.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar hole = json.holes[i];\n\t\t\t\t\t\t\t\t\t\t\t\tthis.holes.push(new Path().fromJSON(hole));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t});\n\n\t\t\texports.Box3 = Box3;\n\t\t\texports.BufferAttribute = BufferAttribute;\n\t\t\texports.BufferGeometry = BufferGeometry;\n\t\t\texports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\n\t\t\texports.ExtrudeGeometry = ExtrudeGeometry;\n\t\t\texports.Float32BufferAttribute = Float32BufferAttribute;\n\t\t\texports.Float64BufferAttribute = Float64BufferAttribute;\n\t\t\texports.Int16BufferAttribute = Int16BufferAttribute;\n\t\t\texports.Int32BufferAttribute = Int32BufferAttribute;\n\t\t\texports.Int8BufferAttribute = Int8BufferAttribute;\n\t\t\texports.Shape = Shape;\n\t\t\texports.ShapeBufferGeometry = ShapeBufferGeometry;\n\t\t\texports.ShapeGeometry = ShapeGeometry;\n\t\t\texports.Uint16BufferAttribute = Uint16BufferAttribute;\n\t\t\texports.Uint32BufferAttribute = Uint32BufferAttribute;\n\t\t\texports.Uint8BufferAttribute = Uint8BufferAttribute;\n\t\t\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\n\t\t\texports.Vector2 = Vector2;\n\t\t\texports.Vector3 = Vector3;\n\n\t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n});\n\n//# sourceURL=webpack:///./lib/threejs/extrudeAndBufferAttribute.js?");

/***/ }),

/***/ "./node_modules/_babel-loader@7.1.5@babel-loader/lib/index.js?!./lib/threejs/createBigBuildingByUearth.worker.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/_babel-loader@7.1.5@babel-loader/lib??ref--5!./lib/threejs/createBigBuildingByUearth.worker.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar THREE = __webpack_require__(/*! ./extrudeAndBufferAttribute.js */ \"./lib/threejs/extrudeAndBufferAttribute.js\");\n__webpack_require__(/*! ./BufferGeometryUtils.js */ \"./lib/threejs/BufferGeometryUtils.js\");\nself.addEventListener('message', function (event) {\n    return processData(event.data);\n});\n\nfunction processData(e) {\n    var data = e.data;\n    var idStartNum = e.idStartNum;\n    var startId = e.start;\n    var geoArray = createGeometryArr(data, idStartNum, startId);\n    var res = THREE.BufferGeometryUtils1.mergeBufferGeometries1(geoArray, 10000000, true);\n    for (var i = 0, len = res.length; i < len; i++) {\n        var geometry = res[i];\n        var resPos = geometry.attributes.position.array;\n        var nums = resPos.length / 3;\n        var resNormal = geometry.attributes.normal.array;\n        var uv = geometry.attributes.uv.array;\n        var uv2 = geometry.attributes.uv2.array;\n        var uv3 = geometry.attributes.uv3.array;\n        var id = geometry.attributes.id ? geometry.attributes.id.array : new Float32Array(nums);\n        var _needMerge = geometry._needMerge || {};\n        var groups = geometry.groups;\n        self.postMessage({ position: resPos, normal: resNormal, uv: uv, uv2: uv2, uv3: uv3, groups: groups, id: id, _needMerge: _needMerge }, [resPos.buffer, resNormal.buffer, uv.buffer, uv2.buffer, uv3.buffer, id.buffer]);\n    }\n}\nfunction createGeometryArr(data, idStartNum, startId) {\n    var geoArray = [];\n    for (var i = 0, len = data.length; i < len; i++) {\n        var positions = data[i].positions;\n        var holes = data[i].holes;\n        var height = data[i].height;\n        var buildingTextureSize = data[i].buildingTextureSize;\n        var buildingMaskTextureSize = data[i].buildingMaskTextureSize;\n        var id = idStartNum | startId + i;\n        var geometry = createBuilding(positions, holes, height, buildingTextureSize, buildingMaskTextureSize, id);\n        geoArray.push(geometry);\n    }\n    return geoArray;\n}\n\nfunction createBuilding(positions, holes, height, buildingTextureSize, buildingMaskTextureSize, id) {\n    var vertices = [];\n    for (var i = 0; i < positions.length / 3; i++) {\n        //设置y为0\n        var v = new THREE.Vector3(positions[3 * i], positions[3 * i + 2], 0);\n        vertices.push(v);\n    }\n    var shape = new THREE.Shape(vertices);\n    if (holes) {\n        for (var j = 0; j < holes.length; j++) {\n            var hv = [];\n            var hole = holes[j];\n            for (var k = 0; k < hole.length / 3; k++) {\n                var _v = new THREE.Vector3(hole[3 * i], hole[3 * i + 2], 0);\n                hv.push(_v);\n            }\n            var holePath = new THREE.Path(hv);\n            shape.holes.push(holePath);\n        }\n    }\n\n    var geo = new THREE.BufferGeometry();\n    geo.topUV = []; //top始终是不变的,目前通过包围盒计算\n    geo.sideUV1 = []; //u:0-1,v:0-1;\n    geo.sideUV2 = []; //u:0-1,v:0-y;\n    geo.sideUV3 = []; //u:0-x,v:0-1;\n    geo.sideUV4 = []; //u:0-x,v:0-y;\n    //mask\n    geo.sideUV5 = []; //u:0-1,v:0-y;\n    geo.sideUV6 = []; //u:0-x,v:0-1;\n    geo.sideUV7 = []; //u:0-x,v:0-y;\n\n    var geometry = new THREE.ExtrudeBufferGeometry(shape, {\n        // extrudePath: path,\n        steps: 1,\n        depth: height,\n        material: 0,\n        extrudeMaterial: 1,\n        bevelEnabled: false,\n        UVGenerator: _uvgenerator(geo, height, vertices, buildingTextureSize, buildingMaskTextureSize)\n    });\n\n    //继续转换顶点，这里确实有点绕, 获取真正的底面数组\n    var normalArray = geometry.attributes.normal.array;\n    for (var _i = 0, array = geometry.attributes.position.array, length = array.length; _i < length; _i += 3) {\n        //从xy平面转换到xz平面\n        var y = array[_i + 1];\n        array[_i + 1] = array[_i + 2];\n        array[_i + 2] = y;\n        //继续转换法线，这里threejs会进行内部转换,所以必须转回来\n        normalArray[_i] = -normalArray[_i];\n        normalArray[_i + 1] = -normalArray[_i + 1];\n        normalArray[_i + 2] = -normalArray[_i + 2];\n        var y1 = normalArray[_i + 1];\n        normalArray[_i + 1] = normalArray[_i + 2];\n        normalArray[_i + 2] = y1;\n    }\n    geometry.addAttribute('uv', new THREE.BufferAttribute(arrayToFloat32Array(geo.topUV.concat(geo.sideUV2)), 2));\n    geometry.addAttribute('uv2', new THREE.BufferAttribute(arrayToFloat32Array(geo.topUV.concat(geo.sideUV1)), 2));\n    geometry.addAttribute('uv3', new THREE.BufferAttribute(arrayToFloat32Array(geo.topUV.concat(geo.sideUV4)), 2));\n    if (id !== undefined) {\n        var idArray = new Float32Array(geometry.attributes.position.count);\n        idArray.fill(id);\n        geometry.addAttribute('id', new THREE.BufferAttribute(idArray, 1));\n    }\n    return geometry;\n}\n\n//为building计算uv\nfunction _uvgenerator(geo, height, vertices, buildingTextureSize, buildingMaskTextureSize) {\n    //计算包围盒\n    if (geo.boundingBox === null) {\n        geo.boundingBox = new THREE.Box3();\n    }\n    geo.boundingBox.setFromPoints(vertices);\n    var minX = geo.boundingBox.min.x,\n        maxX = geo.boundingBox.max.x,\n        minY = geo.boundingBox.min.y,\n        maxY = geo.boundingBox.max.y,\n        minZ = 0,\n        maxZ = height;\n    var dx = buildingTextureSize[0];\n    var dy = buildingTextureSize[1];\n    var dx1 = buildingMaskTextureSize[0];\n    var dy1 = buildingMaskTextureSize[1];\n\n    var UVGenerator = {\n\n        generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {\n\n            var a_x = (vertices[indexA * 3] - minX) / (maxX - minX);\n            var a_y = 1 - (vertices[indexA * 3 + 1] - minY) / (maxY - minY);\n            var b_x = (vertices[indexB * 3] - minX) / (maxX - minX);\n            var b_y = 1 - (vertices[indexB * 3 + 1] - minY) / (maxY - minY);\n            var c_x = (vertices[indexC * 3] - minX) / (maxX - minX);\n            var c_y = 1 - (vertices[indexC * 3 + 1] - minY) / (maxY - minY);\n\n            var result = [new THREE.Vector2(a_x, a_y), new THREE.Vector2(b_x, b_y), new THREE.Vector2(c_x, c_y)];\n            geo.topUV.push.call(geo.topUV, result[0].x, result[0].y, result[1].x, result[1].y, result[2].x, result[2].y);\n            return result;\n        },\n\n        generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {\n            var a = [vertices[indexA * 3], vertices[indexA * 3 + 1]];\n            var b = [vertices[indexB * 3], vertices[indexB * 3 + 1]];\n\n            var x = getDistanceFromArray(a, b) / dx;\n            var y = height / dy;\n\n            var x1 = getDistanceFromArray(a, b) / dx1;\n            var y1 = height / dy1;\n\n            function setSideUV(x, y, uv) {\n                var res = [new THREE.Vector2(0, 0), new THREE.Vector2(x, 0), new THREE.Vector2(x, y), new THREE.Vector2(0, y)];\n                uv.push.call(uv, res[0].x, res[0].y, res[1].x, res[1].y, res[3].x, res[3].y);\n                uv.push.call(uv, res[1].x, res[1].y, res[2].x, res[2].y, res[3].x, res[3].y);\n            }\n\n            var sideUV1 = [new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)];\n\n            setSideUV(-1, 1, geo.sideUV1);\n            setSideUV(-1, y, geo.sideUV2);\n            setSideUV(-x, 1, geo.sideUV3);\n            setSideUV(-x, y, geo.sideUV4);\n\n            setSideUV(-1, y1, geo.sideUV5);\n            setSideUV(-x1, 1, geo.sideUV6);\n            setSideUV(-x1, y1, geo.sideUV7);\n\n            return sideUV1;\n        }\n    };\n\n    return UVGenerator;\n}\n\nfunction getDistanceFromArray(a, b) {\n    return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n}\nfunction arrayToFloat32Array(arr) {\n    var len = arr.length;\n    var res = new Float32Array(len);\n    for (var i = 0; i < len; i++) {\n        res[i] = arr[i];\n    }\n    return res;\n}\n\n//# sourceURL=webpack:///./lib/threejs/createBigBuildingByUearth.worker.js?./node_modules/_babel-loader@7.1.5@babel-loader/lib??ref--5");

/***/ })

/******/ });